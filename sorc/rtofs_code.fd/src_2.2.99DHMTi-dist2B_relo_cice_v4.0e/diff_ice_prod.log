setenv HC /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc
foreach f ( comp_ice.csh */*.F90 */*/*.F90 )
diff -ibw comp_ice.csh /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/comp_ice.csh
0a1,2
> #! /bin/csh -f
> 
1a4
> module load EnvVars/1.0.2
9,21d11
< # #
< # DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< # agencies based upon the reasons of possible Premature Distribution
< # and the possibility of containing Software Documentation as listed
< # on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< # Technical Documents, of 23 August 2012. Other requests for this
< # document shall be made to Dr. Ruth H. Preller, Superintendent,
< # Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< # OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< # 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< # #
< #! /bin/csh -f
< 
24a15,26
> #setenv SITE NAVO.davinci
> #setenv SITE NAVO.einstein
> #setenv SITE ERDC.garnet
> #setenv SITE ERDC.diamond
> #module switch mpi/sgi_mpi-2.04 mpi/sgi_mpi-1.26
> #module list
> #setenv SITE ERDC.diamondI12
> #module switch mpi mpi/intelmpi-4.0.3
> #module switch compiler compiler/intel12.1.003
> #module list
> #setenv SITE NAVO.kilrainSMSSE
> #setenv SITE NCEP.wcossSMSSE
26,31c28,33
< #unset echo
< #module switch  intel intel/15.0.0.090
< #module switch  cray-mpich cray-mpich/7.2.4
< #module switch  cray-libsci cray-libsci/12.2.0
< #module switch ics ics/12.1
< #module load NetCDF/4.2/serial
---
> #module switch mpi mpi/intel/impi/4.1.0
> #module switch compiler compiler/intel/12.1.3
> #--- module switch ics ics/12.1
> #module load ESMF/400rp1
> #--- module load NetCDF/4.2/serial
> #module load zlib
33d34
< #set echo
37a39
> setenv SYSTEM_USERDIR /ptmp/$user
39d40
< setenv SYSTEM_USERDIR /gpfs/dell2/emc/modeling/noscrub/$LOGNAME/tmp
181d181
< #    setenv BEI_HOME /p/home/wallcraf/pkgs
195,198c195
< #setenv ARCH Aintelsse-impi
< #setenv ARCH Axc30-intel-relo
< #setenv ARCH Axc40-intel-relo
< setenv ARCH Aintelsse-impi-relo
---
> setenv ARCH Aintelsse-impi
end
diff -ibw csm_share/shr_orb_mod.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/csm_share/shr_orb_mod.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw mpi/ice_boundary.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/mpi/ice_boundary.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw mpi/ice_broadcast.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/mpi/ice_broadcast.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw mpi/ice_communicate.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/mpi/ice_communicate.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw mpi/ice_exit.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/mpi/ice_exit.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw mpi/ice_gather_scatter.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/mpi/ice_gather_scatter.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw mpi/ice_global_reductions.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/mpi/ice_global_reductions.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw mpi/ice_timers.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/mpi/ice_timers.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_age.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_age.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_atmo.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_atmo.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_blocks.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_blocks.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_calendar.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_calendar.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
83,84d71
< !ajw
<          zulu     , & ! elapsed hours into date
96,99d82
< !ajw
<          insert_now   , & ! if 1, insert ssmi and sih
<          inserthr     , & ! insert input hour (0,1,2,3,4,6,12,24)
< !ajw
131c114
<          dumpfreq           ! restart frequency, 'y','m','d','e','x','o','r','1','2','3','4,'5','6'
---
>          dumpfreq           ! restart frequency, 'y','m','d','e','x','o','2', 'r'
279,280d261
< !zg
<          npt3hr                    , & ! time steps in 3 hours
299d279
<       insert_now=0
303,305d282
< !ajw
<       zulu = int(  sec/c3600)           ! elapsed hours into date
<       hour = int(ttime/c3600) + c1      ! hour
306a284
>       hour = int((ttime-dt)/c3600) + c1 ! hour
351c329
<       elapsed_hours = int(ttime/c3600)
---
>       elapsed_hours = int(ttime/3600)
375,376c353
< !ajw      use hour in day for histfreq_n
<           if (new_hour .and. mod(zulu, histfreq_n)==0) &
---
>           if (new_hour .and. mod(elapsed_hours,histfreq_n)==0) &
381d357
<         npt3hr = nint(secday/dt)/8
401,427d376
<         case ("3")
<           if (istep == nint(( 3.d0*secday/24.d0)/dt) ) &
<                 write_restart = 1  ! 3 hours into the run
<           if (istep == 2*npt12hr)  &
<                 write_restart = 1  !24 hours into the run
<         case ("5")
<           if (istep == nint((15.d0*secday/24.d0)/dt) ) &
<                 write_restart = 1  !15 hours into the run
<           if (istep == 2*npt12hr)  &
<                 write_restart = 1  !24 hours into the run
<         case ("6")
<           if (istep == nint(( 6.d0*secday/24.d0)/dt) ) &
<                 write_restart = 1  ! 6 hours into the run
<         case ("1")
< !zg changed from write restart at hour 21, 24 
< !zg write restart at end of run, and 3 hours from end of run
<           if (istep == npt-npt3hr)  &
<                 write_restart = 1  !3 hours before end of run
<           if (istep >= npt)  &
<                 write_restart = 1  !last time step
< !         if (istep == nint((21.d0*secday/24.d0)/dt) ) &
< !               write_restart = 1  !21 hours into the run
< !          if (istep == 2*npt12hr)  &
< !                write_restart = 1  !24 hours into the run
<         case ("4")
<           if (istep == 2*npt12hr)  &
<                 write_restart = 1  !24 hours into the run
441,445d389
< !ajw
<       if ( istep == nint((inserthr*secday/24.d0)/dt) ) then
<         insert_now=1  ! inserthr hours into the run
<       endif
< !ajw
end
diff -ibw source/ice_coupling.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_coupling.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_diagnostics.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_diagnostics.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_distribution.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_distribution.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_domain.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_domain.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_domain_size.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_domain_size.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_dyn_evp.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_dyn_evp.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_fileunits.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_fileunits.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_flux.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_flux.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_forcing.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_forcing.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_grid.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_grid.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_history.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_history.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_init.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_init.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
83,85c72
<                               npt, dt, ndyn_dt, days_per_year, write_ic, &
<                               inserthr
< !ajw
---
>                               npt, dt, ndyn_dt, days_per_year, write_ic
88,89c75
<           runid, runtype, insert_ssmi, insert_sih
< !ajw
---
>           runid, runtype, insert_ssmi
147,149c133
<         write_ic,       incond_dir,     incond_file,                    &
< !ajw
<         inserthr
---
>         write_ic,       incond_dir,     incond_file
171,172c155
<         restore_ice,    insert_ssmi,     insert_sih
< !ajw
---
>         restore_ice, insert_ssmi    
188,189d170
< !ajw
<       inserthr = 0           ! when to insert ssmi and sih (hours from start)
273,275c254
< !ajw
<       insert_ssmi = .false.       ! if true, update concentration using SSMI
<       insert_sih  = .false.       ! if true, update thickness from a file
---
>       insert_ssmi = .true.        ! if true, update concentration using SSMI
415,416d393
< !ajw
<       call broadcast_scalar(inserthr,           master_task)
488d464
<       call broadcast_scalar(insert_sih,         master_task)
524,525d499
< !ajw
<          write(nu_diag,1020) ' inserthr                  = ', inserthr
616,617d589
< !ajw
<          write(nu_diag,1010) ' insert_sih                = ', insert_sih
end
diff -ibw source/ice_itd.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_itd.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_kinds_mod.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_kinds_mod.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_mechred.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_mechred.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_meltpond.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_meltpond.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_ocean.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_ocean.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_orbital.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_orbital.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_read_write.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_read_write.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_restart.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_restart.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
54,55c43
<          insert_sih    , &! if true, update restart ice thickness from a file
<          insert_ssmi      ! if true, update restart concentation  from a file
---
>          insert_ssmi      ! if true, update restart concentation using SSMI 
260,263c248
<       use ice_calendar, only: istep0, istep1, time, time_forc, calendar, &
<                               inserthr
< !ajw
< 
---
>       use ice_calendar, only: istep0, istep1, time, time_forc, calendar
299d283
<       real (kind=dbl_kind)               :: vice_m,vice_o
501c485
<       if     (inserthr == 0 .and. insert_ssmi) then
---
>       if     (insert_ssmi) then
572c556
<                     aice_i = aice_m - aice_t   !>=0.0
---
>                     aice_i = aice_m - aice_t
656,713d639
<       ! update ice thickness using (say) NCODA?
<       ! this version by Alan Wallcraft, May 2015.
<       !-----------------------------------------------------------------
< 
<       if     (inserthr == 0 .and. insert_sih) then
<          nu2 = 36
<          call ice_open(nu2,trim(restart_dir)//'sih.r',64)
<          call ice_read(nu2,1,work1,'rda8',diag)
<          if (my_task == master_task) close (nu2)
< 
<          do iblk = 1, nblocks
<            call aggregate (nx_block, ny_block, &
<                            aicen(:,:,:,iblk),  &
<                            trcrn(:,:,:,:,iblk),&
<                            vicen(:,:,:,iblk),  &
<                            vsnon(:,:,:,iblk),  &
<                            eicen(:,:,:,iblk),  &
<                            esnon(:,:,:,iblk),  &
<                            aice (:,:,  iblk),  &
<                            trcr (:,:,:,iblk),  &
<                            vice (:,:,  iblk),  &
<                            vsno (:,:,  iblk),  &
<                            eice (:,:,  iblk),  &
<                            esno (:,:,  iblk),  &
<                            aice0(:,:,  iblk),  &
<                            tmask(:,:,  iblk),  &
<                            trcr_depend)
< 
<             do j = 1, ny_block
<             do i = 1, nx_block
< 
<                vice_o = work1(i,j,iblk)  !obs.  ice thickness
<                vice_m =  vice(i,j,iblk)  !model ice thickness
< 
<                if     (vice_m.gt.0.01) then !model area thickness > 1 cm
<                   if     (vice_o.lt.0.01) then  !obs. area thickness < 1 cm
<                      ! --- do nothing where this is no observed sea ice
<                      ! --- model and observation may be incompatible
<                   else !vice_o.ge.0.01
<                     q = vice_o/vice_m
<                     do n=1,ncat
<                        vicen(i,j,n,iblk) = q*vicen(i,j,n,iblk)
<                        do k=1,nilyr
<                           eicen(i,j,ilyr1(n)+k-1,iblk) = &
<                           q*eicen(i,j,ilyr1(n)+k-1,iblk)
<                        enddo !k
<                     enddo !n
<                   endif !vice_o
<                else !model area thickness < 1 cm
<                   ! --- do nothing where there is no existing ice
<                   ! --- model and observation may be incompatible
<                endif !vice_m
<             enddo !j
<             enddo !i
<          enddo !iblk
<       endif !insert_sih
< 
<       !-----------------------------------------------------------------
827,1223d752
< 
< !=======================================================================
< !BOP
< !
< ! !IROUTINE: insertfile  - inserts SSMI or SIH
< !
< ! !INTERFACE:
< !
<       subroutine insertfile
< !
< ! !DESCRIPTION:
< !
< ! inserts SSMI or SIH
< !
< ! !REVISION HISTORY:
< !
< ! author Alan J. Wallcraft
< !
< ! !USES:
< !
<       use ice_broadcast
<       use ice_boundary
<       use ice_domain_size
<       use ice_domain
<       use ice_calendar, only: istep0, istep1, time, time_forc, calendar
< 
<       use ice_flux
<       use ice_state
<       use ice_grid, only: tmask
<       use ice_itd
<       use ice_work, only: work1, work_g1, work_g2
< !
< ! !INPUT/OUTPUT PARAMETERS:
< !
< !EOP
< !
<       integer (kind=int_kind) :: &
<          i, j, k, n, it, iblk, nu2 !counting indices
< 
<       integer (kind=int_kind) :: &
<          ilo,ihi,jlo,jhi,istop,jstop
< 
<       real (kind=dbl_kind) :: &
<          dt
< 
<       type (block) :: &
<          this_block
< 
<       character(len=char_len_long) :: &
<          filename, filename0
< 
<       logical (kind=log_kind) :: &
<          diag, l_stop, heat_capacity
< 
<       real (kind=dbl_kind), dimension(4) :: Tmlt
<       real (kind=dbl_kind)               :: slope, Ti, q
<       real (kind=dbl_kind)               :: aice_m,aice_o,aice_t,aice_i
<       real (kind=dbl_kind)               :: vice_m,vice_o
<       real (kind=dbl_kind)               :: edge_om,diff_om,hin_om
< 
<       if     (.not. insert_ssmi .and. .not. insert_sih ) then
<         return
<       endif
< 
<       dt =  600.0
<       l_stop =  .false.
<       heat_capacity =  .true.
< 
<       !-----------------------------------------------------------------
<       ! update concentration using NCODA?
<       ! this version by Alan Wallcraft, April 2013.
<       !-----------------------------------------------------------------
< 
<       if     (insert_ssmi) then
<          nu2 = 36
<          call ice_open(nu2,trim(restart_dir)//'ssmi.r',64)
<          call ice_read(nu2,1,work1,'rda8',diag)  ! 0 <= ssmi <= 1
<          if (my_task == master_task) close (nu2)
< 
<          edge_om = 0.20  ! nominal ice edge zone
<          diff_om = 0.10  ! allowed model vs obs difference
<          hin_om  = hin_max(1)*0.9  !new ice thickness
< 
<          do iblk = 1, nblocks
<             call aggregate_area (nx_block, ny_block, &
<                                  aicen(:,:,:,iblk),  &
<                                  aice (:,:,  iblk),  &
<                                  aice0(:,:,  iblk) )
< 
<             do j = 1, ny_block
<             do i = 1, nx_block
< 
<                aice_o = work1(i,j,iblk)  !obs.  ice concentration
<                aice_m =  aice(i,j,iblk)  !model ice concentration
< 
<                if     (.not.tmask(i,j,iblk)) then
<                   ! land - do nothing
<                elseif (aice_o.gt.0.01 .and. &
<                        abs(aice_o-aice_m).le.0.01) then
<                   ! model and obs are very close - do nothing
<                elseif (min(aice_o,aice_m).ge.edge_om .and. &
<                        abs(aice_o-aice_m).le.diff_om) then
<                   ! model and obs are close enough - do nothing
<                elseif (aice_o.eq.aice_m) then
<                   !  model and obs are identical - do nothing
<                elseif (aice_o.lt.aice_m) then
<                   if (aice_o.lt.0.01)then
<                      ! --- remove all ice ---
<                      ! warm sst so the ice won't grow immediately
<                      sst(i,j,iblk) = sst(i,j,iblk) + 0.2
<                      do n=1,ncat
<                        aicen(i,j,n,iblk) = c0  
<                        vicen(i,j,n,iblk) = c0
<                        vsnon(i,j,n,iblk) = c0
<                        do k=1,nslyr
<                           esnon(i,j,slyr1(n)+k-1,iblk) = c0
<                        enddo !k
<                        do k=1,nilyr
<                           eicen(i,j,ilyr1(n)+k-1,iblk) = c0
<                        enddo !k
<                        trcrn(i,j,nt_Tsfc,n,iblk) = c0
<                      enddo !n
<                      stressp_1 (i,j,iblk) = c0
<                      stressp_2 (i,j,iblk) = c0
<                      stressp_3 (i,j,iblk) = c0
<                      stressp_4 (i,j,iblk) = c0
<                      stressm_1 (i,j,iblk) = c0
<                      stressm_2 (i,j,iblk) = c0
<                      stressm_3 (i,j,iblk) = c0
<                      stressm_4 (i,j,iblk) = c0
<                      stress12_1(i,j,iblk) = c0
<                      stress12_2(i,j,iblk) = c0
<                      stress12_3(i,j,iblk) = c0
<                      stress12_4(i,j,iblk) = c0
<                   else !aice_o.ge.0.01
<                     if     (aice_o.lt.edge_om) then
<                        ! --- target ice conc. is obs.
<                        aice_t = aice_o
<                     else !aice_m-aice_o.gt.diff_om
<                        ! --- target ice conc. is obs.+diff_om
<                        aice_t = aice_o + diff_om
<                     endif
<                     ! --- reduce ice to the target concentration,
<                     !     completely exhasting ice categories in order ---
<                     aice_i = aice_m - aice_t   !>=0.0
<                     do n=1,ncat
<                        if     (aice_i.le.0.001) then
<                           exit
<                        elseif (aice_i.ge.aicen(i,j,n,iblk)) then
<                           ! --- remove all of this category
<                           aice_i = aice_i - aicen(i,j,n,iblk)
<  
<                           aicen(i,j,n,iblk) = c0  
<                           vicen(i,j,n,iblk) = c0
<                           vsnon(i,j,n,iblk) = c0
<                           do k=1,nslyr
<                              esnon(i,j,slyr1(n)+k-1,iblk) = c0
<                           enddo !k
<                           do k=1,nilyr
<                              eicen(i,j,ilyr1(n)+k-1,iblk) = c0
<                           enddo !k
<                           trcrn(i,j,nt_Tsfc,n,iblk) = c0
<                        else  !aice_i.lt.aicen(i,j,n,iblk)
<                           ! --- remove part of this category
<                           q = (aicen(i,j,n,iblk) - aice_i) &
<                               /aicen(i,j,n,iblk)              !<1
<                           aice_i = c0
<  
<                           aicen(i,j,n,iblk) = q*aicen(i,j,n,iblk)
<                           vicen(i,j,n,iblk) = q*vicen(i,j,n,iblk)
<                           vsnon(i,j,n,iblk) = q*vsnon(i,j,n,iblk)
<                           do k=1,nslyr
<                              esnon(i,j,slyr1(n)+k-1,iblk) = &
<                              q*esnon(i,j,slyr1(n)+k-1,iblk)
<                           enddo !k
<                           do k=1,nilyr
<                              eicen(i,j,ilyr1(n)+k-1,iblk) = &
<                              q*eicen(i,j,ilyr1(n)+k-1,iblk)
<                           enddo !k
<                        endif !aice_i
<                     enddo !n
<                   endif
<                elseif (aice_o.gt.0.01) then  ! .and. aice_o.gt.aice_m
<                   if     (aice_m.lt.edge_om) then
<                      ! --- target ice conc. is obs.
<                      aice_t = aice_o
<                   else !aice_o-aice_m.gt.diff_om
<                      ! --- target ice conc. is obs.-diff_om
<                      aice_t = aice_o - diff_om
<                   endif
<                   q = (aice_t-aice_m)
<                   ! --- add ice to the target concentration,
<                   !     with all new ice in category 1 ---
<                   ! cool sst so the ice won't melt immediately
<                   sst(  i,j,  iblk) = sst(  i,j,  iblk) - q  ! 0 <= q <= 1
<                   aicen(i,j,1,iblk) = aicen(i,j,1,iblk) + q
<                   vicen(i,j,1,iblk) = vicen(i,j,1,iblk) + q*hin_om
<                   vsnon(i,j,1,iblk) = vsnon(i,j,1,iblk) + q*hin_om*p2
<                   trcrn(i,j,nt_Tsfc,1,iblk) =   &
<                     min(Tsmelt,Tair(i,j,iblk) - Tffresh)  ! Tsfc
<                   Ti = min(c0,trcrn(i,j,nt_Tsfc,1,iblk))
<                   do k=1,nslyr
<                      esnon(i,j,slyr1(1)+k-1,iblk) = &
<                      esnon(i,j,slyr1(1)+k-1,iblk)   &
<                        -rhos*(Lfresh - cp_ice*Ti)   &
<                        *q*hin_om*p2                 &  !change in vsnon.1
<                        /real(nslyr,kind=dbl_kind)
<                   enddo !k
<                   do k=1,nilyr
<                      Tmlt(k) = c0
<                      slope   = Tf(i,j,iblk) - trcrn(i,j,nt_Tsfc,1,iblk)
<                      Ti      = trcrn(i,j,nt_Tsfc,1,iblk)    &
<                                  + slope*(real(k)-p5)*c4
<                      eicen(i,j,ilyr1(1)+k-1,iblk) =   &
<                      eicen(i,j,ilyr1(1)+k-1,iblk)     &
<                        -(rhoi*(cp_ice*(Tmlt(k)-Ti)    &
<                           + Lfresh * (c1-Tmlt(k)/Ti)  &
<                           - cp_ocn*Tmlt(k)))          &
<                        * q*hin_om                     & !change in vicen.1
<                        / real(nilyr,kind=dbl_kind)
<                   enddo !k
<                endif !aice_o vs aice_m
<             enddo !j
<             enddo !i
<          enddo !iblk
<       endif !insert_ssmi
< 
<       !-----------------------------------------------------------------
<       ! update ice thickness using (say) NCODA?
<       ! this version by Alan Wallcraft, May 2015.
<       !-----------------------------------------------------------------
< 
<       if     (insert_sih) then
<          nu2 = 36
<          call ice_open(nu2,trim(restart_dir)//'sih.r',64)
<          call ice_read(nu2,1,work1,'rda8',diag)
<          if (my_task == master_task) close (nu2)
< 
<          do iblk = 1, nblocks
<            call aggregate (nx_block, ny_block, &
<                            aicen(:,:,:,iblk),  &
<                            trcrn(:,:,:,:,iblk),&
<                            vicen(:,:,:,iblk),  &
<                            vsnon(:,:,:,iblk),  &
<                            eicen(:,:,:,iblk),  &
<                            esnon(:,:,:,iblk),  &
<                            aice (:,:,  iblk),  &
<                            trcr (:,:,:,iblk),  &
<                            vice (:,:,  iblk),  &
<                            vsno (:,:,  iblk),  &
<                            eice (:,:,  iblk),  &
<                            esno (:,:,  iblk),  &
<                            aice0(:,:,  iblk),  &
<                            tmask(:,:,  iblk),  &
<                            trcr_depend)
< 
<             do j = 1, ny_block
<             do i = 1, nx_block
< 
<                vice_o = work1(i,j,iblk)  !obs.  ice thickness
<                vice_m =  vice(i,j,iblk)  !model ice thickness
< 
<                if     (vice_m.gt.0.01) then !model area thickness > 1 cm
<                   if     (vice_o.lt.0.01) then  !obs. area thickness < 1 cm
<                      ! --- do nothing where this is no observed sea ice
<                      ! --- model and observation may be incompatible
<                   else !vice_o.ge.0.01
<                     q = vice_o/vice_m
<                     do n=1,ncat
<                        vicen(i,j,n,iblk) = q*vicen(i,j,n,iblk)
<                        do k=1,nilyr
<                           eicen(i,j,ilyr1(n)+k-1,iblk) = &
<                           q*eicen(i,j,ilyr1(n)+k-1,iblk)
<                        enddo !k
<                     enddo !n
<                   endif !vice_o
<                else !model area thickness < 1 cm
<                   ! --- do nothing where there is no existing ice
<                   ! --- model and observation may be incompatible
<                endif !vice_m
<             enddo !j
<             enddo !i
<          enddo !iblk
<       endif !insert_sih
< 
<       !-----------------------------------------------------------------
<       ! Ensure unused stress values in west and south ghost cells are 0
<       !-----------------------------------------------------------------
<       do iblk = 1, nblocks
<          do j = 1, nghost
<          do i = 1, nx_block
<             stressp_1 (i,j,iblk) = c0
<             stressp_2 (i,j,iblk) = c0
<             stressp_3 (i,j,iblk) = c0
<             stressp_4 (i,j,iblk) = c0
<             stressm_1 (i,j,iblk) = c0
<             stressm_2 (i,j,iblk) = c0
<             stressm_3 (i,j,iblk) = c0
<             stressm_4 (i,j,iblk) = c0
<             stress12_1(i,j,iblk) = c0
<             stress12_2(i,j,iblk) = c0
<             stress12_3(i,j,iblk) = c0
<             stress12_4(i,j,iblk) = c0
<          enddo
<          enddo
<          do j = 1, ny_block
<          do i = 1, nghost
<             stressp_1 (i,j,iblk) = c0
<             stressp_2 (i,j,iblk) = c0
<             stressp_3 (i,j,iblk) = c0
<             stressp_4 (i,j,iblk) = c0
<             stressm_1 (i,j,iblk) = c0
<             stressm_2 (i,j,iblk) = c0
<             stressm_3 (i,j,iblk) = c0
<             stressm_4 (i,j,iblk) = c0
<             stress12_1(i,j,iblk) = c0
<             stress12_2(i,j,iblk) = c0
<             stress12_3(i,j,iblk) = c0
<             stress12_4(i,j,iblk) = c0
<          enddo
<          enddo
<       enddo
< 
<       !-----------------------------------------------------------------
<       ! Ensure ice is binned in correct categories
<       ! (should not be necessary unless restarting from a run with
<       !  different category boundaries).
<       !-----------------------------------------------------------------
< !      call cleanup_itd
< 
<          do iblk = 1, nblocks
<          this_block = get_block(blocks_ice(iblk), iblk)
<          ilo = this_block%ilo
<          ihi = this_block%ihi
<          jlo = this_block%jlo
<          jhi = this_block%jhi
< 
<       !-----------------------------------------------------------------
<       ! ITD cleanup: Rebin thickness categories if necessary, and remove
<       !  categories with very small areas.
<       !-----------------------------------------------------------------
< 
<          call cleanup_itd (nx_block,             ny_block,             &
<                            ilo, ihi,             jlo, jhi,             &
<                            dt,                                         &
<                            aicen   (:,:,:,iblk), trcrn (:,:,:,:,iblk), &
<                            vicen   (:,:,:,iblk), vsnon (:,:,  :,iblk), &
<                            eicen   (:,:,:,iblk), esnon (:,:,  :,iblk), &
<                            aice0   (:,:,  iblk), aice      (:,:,iblk), &
<                            trcr_depend,                                &
<                            fresh   (:,:,  iblk), fsalt     (:,:,iblk), &
<                            fhocn   (:,:,  iblk),                       &
<                            heat_capacity,        l_stop,               &
<                            istop,                jstop)
< 
<          if (l_stop) then
<             write (nu_diag,*) 'istep1, my_task, iblk =', &
<                                istep1, my_task, iblk
<             write (nu_diag,*) 'Global block:', this_block%block_id
<             if (istop > 0 .and. jstop > 0) &
<                  write(nu_diag,*) 'Global i and j:', &
<                                   this_block%i_glob(istop), &
<                                   this_block%j_glob(jstop)
<             call abort_ice ('ice: ITD cleanup error')
<          endif
< 
<       enddo                     ! iblk
< 
< 
<       !-----------------------------------------------------------------
<       ! compute aggregate ice state and open water area
<       !-----------------------------------------------------------------
< 
<       do iblk = 1, nblocks
< 
<          call aggregate (nx_block, ny_block, &
<                          aicen(:,:,:,iblk),  &
<                          trcrn(:,:,:,:,iblk),&
<                          vicen(:,:,:,iblk),  &
<                          vsnon(:,:,:,iblk),  &
<                          eicen(:,:,:,iblk),  &
<                          esnon(:,:,:,iblk),  &
<                          aice (:,:,  iblk),  &
<                          trcr (:,:,:,iblk),  &
<                          vice (:,:,  iblk),  &
<                          vsno (:,:,  iblk),  &
<                          eice (:,:,  iblk),  &
<                          esno (:,:,  iblk),  &
<                          aice0(:,:,  iblk),  &
<                          tmask(:,:,  iblk),  &
<                          trcr_depend)
< 
<          aice_init(:,:,iblk) = aice(:,:,iblk)
< 
<       enddo
< 
<       end subroutine insertfile
end
diff -ibw source/ice_restoring.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_restoring.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_shortwave.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_shortwave.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_spacecurve.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_spacecurve.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_state.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_state.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_step_mod.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_step_mod.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_therm_itd.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_therm_itd.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_therm_vertical.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_therm_vertical.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_transport_driver.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_transport_driver.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_transport_remap.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_transport_remap.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw source/ice_work.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/source/ice_work.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw drivers/esmf/CICE_ComponentMod.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/drivers/esmf/CICE_ComponentMod.F90
end
diff -ibw drivers/esmf/CICE_FinalMod.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/drivers/esmf/CICE_FinalMod.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw drivers/esmf/CICE_InitMod.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/drivers/esmf/CICE_InitMod.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
diff -ibw drivers/esmf/CICE_RunMod.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/drivers/esmf/CICE_RunMod.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
370,378d358
< 
< !ajw
<       !-----------------------------------------------------------------
<       ! insert SSMI or SIH
<       !-----------------------------------------------------------------
< 
<          if (insert_now == 1) then
<             call insertfile
<          endif
end
diff -ibw drivers/esmf/ice_constants.F90 /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/drivers/esmf/ice_constants.F90
1,11d0
< ! #
< ! DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< ! agencies based upon the reasons of possible Premature Distribution
< ! and the possibility of containing Software Documentation as listed
< ! on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< ! Technical Documents, of 23 August 2012. Other requests for this
< ! document shall be made to Dr. Ruth H. Preller, Superintendent,
< ! Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< ! OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< ! 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< ! #
end
foreach f ( config/*_cice hycom/*.[Ffh] )
diff -ibw config/Aintelsse-impi_cice /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/Aintelsse-impi_cice
25c25
< INCLUDES      = -I${ESMF_DIR}/mod/modO/Linux.intel.64.intelmpi.default -I${ESMF_DIR}/include -I${CICE_DIR}/esmf/compile -I/apps/hdf5/1.8.14-intel/include  -I/apps/zlib/1.2.8-intel-15.0.0/1.2.8/include -I/apps/szip/2.1/include 
---
> INCLUDES      = -I${ESMF_DIR}/mod/modO/Linux.intel.64.intelmpi.default -I${ESMF_DIR}/include -I${CICE_DIR}/esmf/compile -I/usrx/local/prod/packages/ips/18.0.1/impi/18.0.1/hdf5/1.10.1/include  -I/usrx/local/prod/packages/ips/18.0.1/zlib/1.2.11/include
34c34,35
< EXTRALIBS     = -L${ESMF_DIR}/lib/libO/Linux.intel.64.intelmpi.default -L/apps/netcdf/4.3.0-intel/lib -L/apps/hdf5/1.8.14-intel/lib  -L/apps/zlib/1.2.8-intel-15.0.0/1.2.8/lib -L/apps/szip/2.1/lib -Bstatic -lesmf -Bdynamic -ldl -ldl -ldl -ldl -lpthread -lpthread -lpthread -lpthread -lrt -limf -lsvml -lm -lipgo -ldecimal -lcilkrts -lstdc++ -lgcc -lgcc_s -lirc -lpthread -lgcc -lgcc_s -lirc_s -ldl -lrt -ldl -Bstatic -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz -lsz -lnetcdf_c++4  -Bdynamic
---
> #EXTRALIBS     = -L${ESMF_DIR}/lib/libO/Linux.intel.64.intelmpi.default -L/usrx/local/prod/packages/ips/18.0.1/netcdf/3.6.3/lib -L/usrx/local/prod/packages/ips/18.0.1/hdf5/1.10.1/lib  -L/usrx/local/prod/packages/ips/18.0.1/zlib/1.2.11/lib -Bstatic -lesmf -Bdynamic -ldl -ldl -ldl -ldl -lpthread -lpthread -lpthread -lpthread -lrt -limf -lsvml -lm -lipgo -ldecimal -lcilkrts -lstdc++ -lgcc -lgcc_s -lirc -lpthread -lgcc -lgcc_s -lirc_s -ldl -lrt -ldl -Bstatic -lnetcdff -lnetcdf -lhdf5_hl -lhdf5 -lz -lnetcdf_c++  -Bdynamic
> EXTRALIBS     = -L${ESMF_DIR}/lib/libO/Linux.intel.64.intelmpi.default -L/usrx/local/prod/packages/ips/18.0.1/netcdf/3.6.3/lib -L/usrx/local/prod/packages/ips/18.0.1/hdf5/1.10.1/lib  -L/usrx/local/prod/packages/ips/18.0.1/zlib/1.2.11/lib -Bstatic -lesmf -Bdynamic -ldl -ldl -ldl -ldl -lpthread -lpthread -lpthread -lpthread -lrt -limf -lsvml -lm -lipgo -ldecimal -lcilkrts -lstdc++ -lgcc -lgcc_s -lirc -lpthread -lgcc -lgcc_s -lirc_s -ldl -lrt -ldl -Bstatic -lnetcdf -lhdf5_hl -lhdf5 -lz -lnetcdf_c++  -Bdynamic
end
diff -ibw config/Aintelsse-impi-relo_cice /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/Aintelsse-impi-relo_cice
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/Aintelsse-impi-relo_cice: No such file or directory
end
diff -ibw config/Axc30-intel-relo_cice /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/Axc30-intel-relo_cice
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/Axc30-intel-relo_cice: No such file or directory
end
diff -ibw config/Axc40-intel-relo_cice /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/Axc40-intel-relo_cice
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/Axc40-intel-relo_cice: No such file or directory
end
diff -ibw config/xc40-intel-relo_cice /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/xc40-intel-relo_cice
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/config/xc40-intel-relo_cice: No such file or directory
end
diff -ibw hycom/barotp.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/barotp.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
27d2
<       use mod_cb_arrays  ! HYCOM saved arrays
34a10,11
>       include 'common_blocks.h'
> c
57c34
<       integer i,j,l,lll,ml,nl,mn,lstep1,margin,mbdy
---
>       integer i,j,l,lll,ml,nl,mn,lstep1,mbdy
63,83d39
< #if defined(RELO)
<       real, save, allocatable, dimension(:,:) ::
<      &        pbavo,ubavo,vbavo,displd,gslpr,gtide
< c
<       if     (.not.allocated(pbavo)) then
<         allocate(
<      &          pbavo(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          ubavo(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          vbavo(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &         displd(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          gslpr(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy), 
<      &          gtide(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) )
<         call mem_stat_add( 6*(idm+2*nbdy)*(jdm+2*nbdy) )
<                 pbavo = r_init
<                 ubavo = r_init
<                 vbavo = r_init
<                displd = r_init
<                 gslpr = r_init
<                 gtide = r_init
<       endif
< #else
85,86c41
<      &        pbavo,ubavo,vbavo,displd,gslpr,gtide
< #endif
---
>      &        pbavo,ubavo,vbavo,displd
90,126d44
<       margin = mbdy
< c --- atmospheric pressure forcing
< c
<       do j=1-margin,jj+margin
<         do i=1-margin,ii+margin
<           if     (mslprf) then
<             if     (natm.eq.2) then
<               gslpr(i,j) =( mslprs(i,j,l0)*w0+
<      &                      mslprs(i,j,l1)*w1 )*thref
<             else
<               gslpr(i,j) =( mslprs(i,j,l0)*w0+
<      &                      mslprs(i,j,l1)*w1+
<      &                      mslprs(i,j,l2)*w2+
<      &                      mslprs(i,j,l3)*w3 )*thref
<             endif !natm
<           else
<             gslpr(i,j) = 0.0
<           endif !mslprf
< c
<           if (SEA_P) then
< c
< c ---       tidal body forcing, including Scalar SAL,
< c ---       SAL should only be applied to the mass anomally, i.e. to
< c ---       non-steric SSH, so use sshflg>0 except in tides-only cases.
<             if     (tidflg.gt.0 .and. sshflg.eq.0) then !tides
<               gtide(i,j)=-g*etide(i,j)
<      &                   -salfac(i,j)* srfhgt(i,j)
<             elseif (tidflg.gt.0 .and. sshflg.ne.0) then !tides
<               gtide(i,j)=-g*etide(i,j)
<      &                   -salfac(i,j)*(srfhgt(i,j)-steric(i,j))
<             else
<               gtide(i,j)=0.0
<             endif !tides (sshflg)
<           endif !ip
<         enddo !i
<       enddo !j
< c
236c154
< !$OMP PARALLEL DO PRIVATE(j,i,pbudel,pbvdel,
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,pbudel,pbvdel,
240,241c158,159
<         do i=1-margin,ii+margin
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
248,249c166
<      &              -(ubavg(i,  j,ml)+usdbavg(i,  j))*
<      &                    (depthu(i,  j)*scuy(i,  j))
---
>      &-(ubavg(i,j,ml)+usdbavg(i,j))*(depthu(i,j)*scuy(i,j))
252,253c169
<      &              -(vbavg(i,j,  ml)+vsdbavg(i,j  ))*
<      &                    (depthv(i,j  )*scvx(i,j  ))
---
>      &-(vbavg(i,j,ml)+vsdbavg(i,j))*(depthv(i,j)*scvx(i,j))
306,308c222,224
<           endif !ip
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
319c235
< !$OMP PARALLEL DO PRIVATE(j,i,utndcy)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,utndcy)
322,326c238,240
<         do i=1-margin,ii+margin
<           if (SEA_U) then
<             utndcy=-thref*(pbavg(i,j,nl)-pbavg(i-1,j,nl))*scuxi(i,j)-
<      &                    (gtide(i,j)   -gtide(i-1,j)   )*scuxi(i,j)-
<      &                    (gslpr(i,j)   -gslpr(i-1,j)   )*scuxi(i,j)+
---
>         do l=1,isu(j)
>           do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
>             utndcy=-thref*(pbavg(i,j,nl)-pbavg(i-1,j,nl))*scuxi(i,j)+
340c254
< *             write (lp,'(i9,2i5,i3,3x,a,8g15.6)')
---
> *             write (lp,'(i9,2i5,i3,3x,a,6g15.6)')
342c256
< *    &          'u_old,u_new,p_grad,t_g,m_g,corio,u_star,drag =',
---
> *    &          'u_old,u_new,p_grad,corio,u_star,drag =',
345,346d258
< *    &                 -(gtide(i,j)   -gtide(i-1,j)   )*scuxi(i,j)*dlt,
< *    &                 -(gslpr(i,j)   -gslpr(i-1,j)   )*scuxi(i,j)*dlt,
355,357c267,269
<           endif !iu
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
367c279
< !$OMP PARALLEL DO PRIVATE(j,i,vtndcy)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,vtndcy)
370,371c282,283
<         do i=1-margin,ii+margin
<           if (SEA_V) then
---
>         do l=1,isv(j)
>           do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
373,374d284
<      &                    (gtide(i,j)   -gtide(i,j-1)   )*scvyi(i,j)-
<      &                    (gslpr(i,j)   -gslpr(i,j-1)   )*scvyi(i,j)-
388c298
< *             write (lp,'(i9,2i5,i3,3x,a,8g15.6)')
---
> *             write (lp,'(i9,2i5,i3,3x,a,6g15.6)')
390c300
< *    &          'v_old,v_new,p_grad,t_g,m_g,corio,v_star,drag =',
---
> *    &          'v_old,v_new,p_grad,corio,v_star,drag =',
393,394d302
< *    &                -(gtide(i,j)   -gtide(i,j-1)   )*scvyi(i,j)*dlt,
< *    &                -(gslpr(i,j)   -gslpr(i,j-1)   )*scvyi(i,j)*dlt,
403,405c311,313
<           endif !iv
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
407,409c315,317
< *     if     (ldebug_barotp) then
< *       call xcsync(flush_lp)
< *     endif
---
>       if     (ldebug_barotp) then
>         call xcsync(flush_lp)
>       endif
411d318
< #if ! defined(RELO)
416,418c323
<       endif
< #endif
<       if     (lbflag.eq.2) then
---
>       elseif (lbflag.eq.2) then
421a327,328
>       elseif (lbflag.eq.6) then
>         call latbdtc(nl,lll)
450c357
< !$OMP PARALLEL DO PRIVATE(j,i,pbudel,pbvdel,
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,pbudel,pbvdel,
454,455c361,367
<         do i=1-margin,ii+margin
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
> C=================================================================
> CDAN  Barotropic Stokes Drift Velocities included here
> CDAN
> CDAN  August 2013
> CDAN_______________________________________________________________
462,463c374,378
<      &              -(ubavg(i,  j,ml)+usdbavg(i,  j))*
<      &                     (depthu(i ,j)*scuy(i,  j))
---
>      & -(ubavg(i,j,ml)+usdbavg(i,j))*(depthu(i ,j)*scuy(i,j))
> c 
> 
> c            pbvdel =  vbavg(i,j+1,ml)*(depthv(i,j+1)*scvx(i,j+1))
> c     &               -vbavg(i,j  ,ml)*(depthv(i,j  )*scvx(i,j  ))     
466,467c381
<      &              -(vbavg(i,j,  ml)+vsdbavg(i,j  ))*
<      &                    (depthv(i,j  )*scvx(i,j  ))
---
>      & -(vbavg(i,j,ml)+vsdbavg(i,j))*(depthv(i,j)*scvx(i,j))
474a389,404
> c      if((iffstep.lt.50).and.(iffstep.gt.1))then
> c	  write(6,*)'&&&&&&barotp i,j,iffstep,pbudel,pbvdel,vbavg='
> c      write(6,*)i,j,iffstep,pbudel,pbvdel,vbavg(i,j,ml),vbavg(i,j+1,ml)
> c      write(6,*)'depthv,scvx=',depthv(i,j),scvx(i,j)
> c      write(6,*)'depthv,scvx=',depthv(i,j+1),scvx(i,j+1)
> c	  write(6,*)'vsdbavg=',vsdbavg(i,j),vsdbavg(i,j+1)
> c	  write(6,*)'term 1=',(vbavg(i,j+1,ml)+vsdbavg(i,j+1))*
> c     &                       *depthv(i,j+1)*scvx(i,j+1)
> c	  write(6,*)'term 2=',(vbavg(i,j,ml)+
> c     &   vsdbavg(i,j))*depthv(i,j)*scvx(i,j)
> c	   endif
> c      if((iffstep.lt.1450).and.(iffstep.gt.1350))then
> c	  write(6,*)'&&&&&&barotp i,j,iffstep,pbudel,pbvdel,vbavg='
> c      write(6,*)i,j,iffstep,pbudel,pbvdel,vbavg(i,j,ml),vbavg(i,j+1,ml)
> c	   endif
> c	   iffstep=iffstep+1
520,522c450,452
<           endif !ip
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
533c463
< !$OMP PARALLEL DO PRIVATE(j,i,vtndcy)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,vtndcy)
536,537c466,467
<         do i=1-margin,ii+margin
<           if (SEA_V) then
---
>         do l=1,isv(j)
>           do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
539,540d468
<      &                    (gtide(i,j)   -gtide(i,j-1)   )*scvyi(i,j)-
<      &                    (gslpr(i,j)   -gslpr(i,j-1)   )*scvyi(i,j)-
554c482
< *             write (lp,'(i9,2i5,i3,3x,a,8g15.6)')
---
> *             write (lp,'(i9,2i5,i3,3x,a,6g15.6)')
556c484
< *    &          'v_old,v_new,p_grad,t_g,m_g,corio,v_star,drag =',
---
> *    &          'v_old,v_new,p_grad,corio,v_star,drag =',
559,560d486
< *    &                -(gtide(i,j)   -gtide(i,j-1)   )*scvyi(i,j)*dlt,
< *    &                -(gslpr(i,j)   -gslpr(i,j-1)   )*scvyi(i,j)*dlt,
569,571c495,497
<           endif !iv
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
582c508
< !$OMP PARALLEL DO PRIVATE(j,i,utndcy)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,utndcy)
585,589c511,513
<         do i=1-margin,ii+margin
<           if (SEA_U) then
<             utndcy=-thref*(pbavg(i,j,nl)-pbavg(i-1,j,nl))*scuxi(i,j)-
<      &                    (gtide(i,j)   -gtide(i-1,j)   )*scuxi(i,j)-
<      &                    (gslpr(i,j)   -gslpr(i-1,j)   )*scuxi(i,j)+
---
>         do l=1,isu(j)
>           do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
>             utndcy=-thref*(pbavg(i,j,nl)-pbavg(i-1,j,nl))*scuxi(i,j)+
603c527
< *             write (lp,'(i9,2i5,i3,3x,a,7g15.6)')
---
> *             write (lp,'(i9,2i5,i3,3x,a,6g15.6)')
605c529
< *    &          'u_old,u_new,p_grad,t_g,m_g,corio,u_star,drag =',
---
> *    &          'u_old,u_new,p_grad,corio,u_star,drag =',
608,609d531
< *    &                -(gtide(i,j)   -gtide(i-1,j)   )*scuxi(i,j)*dlt,
< *    &                -(gslpr(i,j)   -gslpr(i-1,j)   )*scuxi(i,j)*dlt,
618,620c540,542
<           endif !iu
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
622,624c544,546
< *     if     (ldebug_barotp) then
< *       call xcsync(flush_lp)
< *     endif
---
>       if     (ldebug_barotp) then
>         call xcsync(flush_lp)
>       endif
626d547
< #if ! defined(RELO)
631,633c552
<       endif
< #endif
<       if     (lbflag.eq.2) then
---
>       elseif (lbflag.eq.2) then
636a556,557
>       elseif (lbflag.eq.6) then
>         call latbdtc(nl,lll+1)
650c571
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i)
653,654c574,575
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
656,659c577,580
<             endif !ip
<           enddo !i
<         enddo !j
<         call xcsum(sump, util1,ipa)
---
>             enddo
>           enddo
>         enddo
>         call xcsum(sump, util1,ip)
667c588
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i)
670,671c591,592
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
676,678c597,599
<             endif !ip
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
729,733d649
< c> Apr. 2014 - replace ip with ipa for mass sums
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
< c> May  2014 - removed lbflag==6 for latbdtc
< c> Apr. 2015 - added atmospheric pressure forcing
< c> Apr. 2015 - added tidal body forcing
end
diff -ibw hycom/bigrid.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/bigrid.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
310,385d298
< c --- logical alliX indicates entire row is sea
< !$OMP PARALLEL DO PRIVATE(j,i)
< !$OMP&         SCHEDULE(STATIC,jblk)
<       do j=1-nbdy+1,jj+nbdy-1
<         allip(j) = .true.
<         alliq(j) = .true.
<         alliu(j) = .true.
<         alliv(j) = .true.
<         do i=1-nbdy,ii+nbdy
< c ---     are all iX(:,j) sea points?
<           allip(j) = allip(j) .and. ip(i,j).ne.0
<           alliq(j) = alliq(j) .and. iq(i,j).ne.0
<           alliu(j) = alliu(j) .and. iu(i,j).ne.0
<           alliv(j) = alliv(j) .and. iv(i,j).ne.0
<         enddo !i
<       enddo !j
< c
< c --- determine sea-only i-1, i+1, j-1, and j+1 indexes
< !$OMP PARALLEL DO PRIVATE(j,i)
< !$OMP&         SCHEDULE(STATIC,jblk)
<       do j=1-nbdy+1,jj+nbdy-1
<         do i=1-nbdy+1,ii+nbdy-1
< c ---     W,E,S,N if sea, otherwise center point
<           if     (ip(i-1,j).ne.0) then
<             ipim1(i,j) = i-1
<           else
<             ipim1(i,j) = i
<           endif
<           if     (ip(i+1,j).ne.0) then
<             ipip1(i,j) = i+1
<           else
<             ipip1(i,j) = i
<           endif
<           if     (ip(i,j-1).ne.0) then
<             ipjm1(i,j) = j-1
<           else
<             ipjm1(i,j) = j
<           endif
<           if     (ip(i,j+1).ne.0) then
<             ipjp1(i,j) = j+1
<           else
<             ipjp1(i,j) = j
<           endif
< c
< c ---     W,E,S,N if sea, otherwise E,W,N,S if sea, otherwise center point
<           if     (ip(i-1,j).ne.0) then
<             ipim1x(i,j) = i-1
<           elseif (ip(i+1,j).ne.0) then
<             ipim1x(i,j) = i+1
<           else
<             ipim1x(i,j) = i
<           endif
<           if     (ip(i+1,j).ne.0) then
<             ipip1x(i,j) = i+1
<           elseif (ip(i-1,j).ne.0) then
<             ipip1x(i,j) = i-1
<           else
<             ipip1x(i,j) = i
<           endif
<           if     (ip(i,j-1).ne.0) then
<             ipjm1x(i,j) = j-1
<           elseif (ip(i,j+1).ne.0) then
<             ipjm1x(i,j) = j+1
<           else
<             ipjm1x(i,j) = j
<           endif
<           if     (ip(i,j+1).ne.0) then
<             ipjp1x(i,j) = j+1
<           elseif (ip(i,j-1).ne.0) then
<             ipjp1x(i,j) = j-1
<           else
<             ipjp1x(i,j) = j
<           endif
<         enddo !i
<       enddo !j
< c
549,550d461
< c> May  2014 - added ipim1,ipip1,ipjm1,ipjp1,ipim1x,ipip1x,ipjm1x,ipjp1x
< c> May  2014 - added allip,alliq,alliu,alliv
end
diff -ibw hycom/blkdat.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/blkdat.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
14c3
<       use ccsm3_io       ! CCSM3 I/O interface, uses mod_cb_arrays
---
>       use ccsm3_io    ! CCSM3 I/O interface, includes common_blocks.h
19,20d7
<       use mod_cb_arrays  ! HYCOM saved arrays
< 
29a17,20
> #if ! defined(USE_CCSM3)
>       include 'common_blocks.h'
> #endif
> c
32c23
<       integer   lngblk
---
>       logical   lngblk
41,48d31
< #elif defined(OCEANS2)
<       if     (nocean.eq.2) then
< c ---   slave HYCOM works from ./OCEAN2
<         flnminp = './OCEAN2/'
<       else
< c ---   master HYCOM
<         flnminp = './'
<       endif
56a40,58
> c --- 'g'      = gravitational acceleration (m/s**2)
> c --- 'thref'  = reference value of specific volume (m**3/kg)
>       g     =   9.806
>       thref =   1.0e-3
> c
> c --- layer thicknesses in units of pressure:
>       tenm   = 98060.0    ! g/thref *10.0
>       onem   =  9806.0    ! g/thref
>       tencm  =   980.6    ! g/thref * 0.1
>       onecm  =    98.06   ! g/thref * 0.01
>       onemm  =     9.806  ! g/thref * 0.001
> c
>       qonem  = 1.0/onem   ! thref/g
>       qthref = 1.0/thref
> c
> c --- pi-related values
>       pi = 4.d0*atan(1.d0)
>       radian=pi/180.0
> c
91,99d92
<       if     (itdm.eq.-1) then !serial relo case only
<         itdm = itest
<         idm  = itest
<         ii   = itest
<         jtdm = jtest
<         jdm  = jtest
<         jj   = jtest
<       endif
< c
168,194d160
<       if (mnproc.eq.1) then
<       write(lp,*)
<       endif !1st tile
<       call blkini(kdmblk,'kdm   ')
< c
< #if defined(RELO)
<       kdm = kdmblk
<       kk  = kdmblk
< c
<       allocate(
<      &    dp0k(kdm),
<      &    ds0k(kdm),
<      &   sigma(kdm),
<      &  salmin(kdm) )
<       call mem_stat_add( 4*kdm )
< #else
<       if     (kdmblk.ne.kdm) then
<         if (mnproc.eq.1) then
<         write(lp,'(/ a,i3 /)') 
<      &    'error - expected kdm =',kdm
<         call flush(lp)
<         endif !1st tile
<         call xcstop('(blkdat)')
<                stop '(blkdat)'
<       endif !error
< #endif
< c
248a215,218
>       if (mnproc.eq.1) then
>       write(lp,*)
>       endif !1st tile
>       call blkini(kdmblk,'kdm   ')
301a272,280
>       if     (kdmblk.ne.kdm) then
>         if (mnproc.eq.1) then
>         write(lp,'(/ a,i3 /)') 
>      &    'error - expected kdm =',kdm
>         call flush(lp)
>         endif !1st tile
>         call xcstop('(blkdat)')
>                stop '(blkdat)'
>       endif !error
594c573
< c ---              0.0 if lbflag is not 2 or 4)
---
> c ---              0.0 if lbflag is not 2 or 4 or 6)
601c580
< c --- 'batrop' = barotropic time step (seconds), int. divisor of baclin/2
---
> c --- 'batrop' = barotropic time step (seconds), int. divisor of baclin
628,656d606
< #if defined(RELO)
<       if     (yrflag.lt.2) then
<         natm = 4  !monthly forcing
<       else
<         natm = 2  !high-frequency forcing
<       endif
< #else
<       if     (yrflag.lt.2) then
<         if (natm.lt.4) then
<           if (mnproc.eq.1) then
<           write(lp,'(/ a /)') 
<      &      'error - natm must be 4 for monthly forcing (yrflag==0,1)'
<           call flush(lp)
<           endif !1st tile
<           call xcstop('(blkdat)')
<                  stop '(blkdat)'
<         endif
<       else
<         if (natm.ne.2) then
<           if (mnproc.eq.1) then
<           write(lp,'(/ a /)') 
<      &      'warning - natm can be 2 for this forcing (yrflag!=0,1)'
<           call flush(lp)
<           endif !1st tile
<           call xcstop('(blkdat)')
<                  stop '(blkdat)'
<         endif
<       endif
< #endif
714,715c664,666
<       if     (abs(nint(0.5*baclin/batrop)-
<      &                 0.5*baclin/batrop  ).gt.0.01) then
---
> c --- assume btrlfr (leapfrog time step), converse tested later
>       if     (abs(nint(baclin/batrop)-
>      &                 baclin/batrop  ).gt.0.01) then
718c669
<      &    'error - batrop not an integer divisor of baclin/2'
---
>      &    'error - batrop not an integer divisor of baclin'
803,809d753
< #if defined(RELO)
<       if (nestfq.ne.0.0) then
<         kknest = kdm
<       else
<         kknest =   1
<       endif
< #else
819d762
< #endif
821,822c764
< c --- 'incflg' = incremental update flag (0=no, -/+1=yes, -/+2=full-velocity)
< c                  -ve to read in difference archive for increment
---
> c --- 'incflg' = incremental update flag (0=no, 1=yes, 2=full-velocity)
917a860,871
>       if     (.not.btrlfr .and.
>      &        abs(nint(0.5*baclin/batrop)-
>      &                 0.5*baclin/batrop  ).gt.0.01) then
>         if (mnproc.eq.1) then
>         write(lp,'(/ a /)')
>      &    'error - batrop not an integer divisor of baclin/2'
>         call flush(lp)
>         endif !1st tile
>         call xcstop('(blkdat)')
>                stop '(blkdat)'
>       endif
> c
1100d1053
< c --- 'ishelf' = ice shelf flag (0=none,1=ice shelf over ocean)
1143,1144d1095
<       call blkini(ishelf,'ishelf')
< c
1236a1188
> c --- 'langmr' = KPP:     activate Langmuir turb. factor    (0=F,1=T)
1254,1259d1205
< c --- 'langmr' = KPP:     Langmuir flag (0=no;1=Sul;2=Smy;3=Har;4=Tak)
< c ---                       0:None
< c ---                       1:McWilliams-Sullivan
< c ---                       2:Smyth
< c ---                       3:McWilliams-Harcourt
< c ---                       4:Takaya
1276,1277d1221
<       mxl_no = mlflag.eq.0
< c
1332d1275
< #if ! defined(RELO)
1341,1343c1284
<         endif
< #endif
<         if     (dypflg.ne.0) then
---
>         elseif (dypflg.ne.0) then
1356d1296
< #if ! defined(RELO)
1365,1367c1305
<         endif
< #endif
<         if     (dypflg.ne.0) then
---
>         elseif (dypflg.ne.0) then
1413a1352
>       call blkinl(lngblk,'langmr')  !lngblk is local for testing
1431d1369
<       call blkini(lngblk,'langmr')  !lngblk is local for testing 0 <= 4
1436c1374
<       if     (lngblk.ne.0) then
---
>       if     (lngblk) then
1439c1377
<      &    'error - langmr must be =0 unless the macro STOKES',
---
>      &    'error - langmr must be .false. unless the macro STOKES',
1537c1475
< c --- 'lbflag' = lateral baro. bndy flag (0=none;nest:2=B-K,4=Flather)
---
> c --- 'lbflag' = lateral baro. bndy flag (0=none;nest:2=B-K,4=Flather,6=clamped)
1656a1595,1599
> c --- 'spcifh' = specific heat of sea water (j/kg/deg)
> c --- 'epsil'  = small nonzero number used to prevent division by zero
>       spcifh=3990.
>       epsil =1.0e-11
> c
1662,1668c1605,1606
< c --- 'flxflg' = thermal forcing flag   (0=none,3=net_flux,1-2,4-6=sst-based)
< c ---             (=1 MICOM bulk parameterization)
< c ---             (=2 Kara  bulk parameterization)
< c ---             (=4 COARE bulk parameterization, approx.)
< c ---             (=5 L&Y   bulk parameterization)
< c ---             (=6 COARE bulk parameterization, approx., better pressure)
< c --- 'empflg' = E-P     forcing flag   (0=none,3=net_E-P, 1-2,4-6=sst-based_E)
---
> c --- 'flxflg' = thermal forcing flag   (0=none,3=net_flux,1,2,4,5=sst-based)
> c --- 'empflg' = E-P     forcing flag   (0=none,3=net_E-P, 1,2,4,5=sst-based_E)
1677,1678d1614
< c --- 'prsbas' = msl prs is input field + prsbas (Pa)
< c --- 'mslprf' = msl prs forcing flag   (0=F,1=T)
1696,1697d1631
<       call blkinr(prsbas,'prsbas','(a6," =",f10.1," Pa")')
<       call blkinl(mslprf,'mslprf')
1711,1712c1645
< #if defined(RELO)
<       if (lbflag.eq.1 .or. lbflag.eq.3) then
---
>       if (lbflag.lt.0 .or. lbflag.gt.6 .or. lbflag.eq.5) then
1715c1648
<      &    'error - lbflag 1 and 3 not supported with dynamic memory'
---
>      &    'error - lbflag must be 6 or between 0 and 4'
1721,1722c1654,1655
< #endif
<       if (lbflag.lt.0 .or. lbflag.gt.4) then
---
>       if (lbflag.ne.2 .and. lbflag.ne.4 .and.
>      &    lbflag.ne.6 .and. bnstfq.ne.0.0    ) then
1725,1734c1658
<      &    'error - lbflag must be between 0 and 4'
<         call flush(lp)
<         endif !1st tile
<         call xcstop('(blkdat)')
<                stop '(blkdat)'
<       endif
<       if (lbflag.ne.2 .and. lbflag.ne.4 .and. bnstfq.ne.0.0) then
<         if (mnproc.eq.1) then
<         write(lp,'(/ a /)') 
<      &    'error - bnstfq must be 0.0 unless lbflag is 2 or 4'
---
>      &    'error - bnstfq must be 0.0 unless lbflag is 2 or 4 or 6'
1758c1682
<       if (flxflg.lt.0 .or. flxflg.gt.6) then
---
>       if (flxflg.lt.0 .or. flxflg.gt.5) then
1761c1685
<      &    'error - flxflg must be between 0 and 6'
---
>      &    'error - flxflg must be between 0 and 5'
1777,1786d1700
<       if (flxflg.eq.6 .and.
<      &    wndflg.ne.4      ) then
<         if (mnproc.eq.1) then
<         write(lp,'(/ a /)') 
<      &    'error - wndflg must be 4 when flxflg==6'
<         call flush(lp)
<         endif !1st tile
<         call xcstop('(blkdat)')
<                stop '(blkdat)'
<       endif
1797c1711
<       if (abs(empflg).lt.0 .or. abs(empflg).gt.6) then
---
>       if (abs(empflg).lt.0 .or. abs(empflg).gt.5) then
1800c1714
<      &    'error - empflg must be between 0 and 6'
---
>      &    'error - empflg must be between 0 and 5'
2051c1965
< c --- 'stdsur'  = STOKES: add Stokes Drift Surface Stresses  to dynamics
---
> c --- 'stdsur'  = STOKES: add Stokes Drift Surface Stresses  to dnamics
2053,2056d1966
< c --- 'stdarc'  = STOKES: Stokes Drift Velocities in Archive
< c
< c ---  s w i t c h e s  for Stokes Drift effects  (Integers)
< c
2065d1974
<       call blkinl(stdarc,'stdarc')
2095c2004
<       if (nsdzi .eq.0 .and. langmr.ne.0) then
---
>       if (nsdzi .eq.0 .and. langmr) then
2098c2007
<      &  'error - nsdzi  must be > 0 with langmr >0'
---
>      &  'error - nsdzi  must be > 0 with langmr'
2124,2136d2032
< #if defined(RELO)
<       if (relaxf .and. .not. relaxs) then
<         kkwall = kdm
<       elseif (relaxt) then
<         kkwall = kdm  !needed for tracers
<       else
<         kkwall =   1
<       endif
<       if (mnproc.eq.1) then
<       write(lp,'(a,i10)') 'kkwall =',kkwall
<       write(lp,*)
<       endif !1st tile
< #else
2146c2042,2044
< #endif
---
> c
> c --- use 'hugel' to initialize array portions that the code should never access
>       hugel = 2.0**100  ! 2^100, or about 1.2676506e30
2152d2049
<       flnmshlf   = trim(flnmdepd)//'regional.iceshelf'
2172d2068
<         flnmshlf = './OCEAN2/regional.iceshelf'
2193d2088
<         flnmshlf = 'regional.iceshelf'
2214d2108
<       flnmshlf = 'regional.iceshelf'
2235d2128
<       use mod_cb_arrays  ! HYCOM saved arrays
2237a2131,2132
>       include 'common_blocks.h'
> c
2266d2160
<       use mod_cb_arrays  ! HYCOM saved arrays
2268a2163,2164
>       include 'common_blocks.h'
> c
2306d2201
<       use mod_cb_arrays  ! HYCOM saved arrays
2308a2204,2205
>       include 'common_blocks.h'
> c
2337d2233
<       use mod_cb_arrays  ! HYCOM saved arrays
2339a2236,2237
>       include 'common_blocks.h'
> c
2369d2266
<       use mod_cb_arrays  ! HYCOM saved arrays
2371a2269,2270
>       include 'common_blocks.h'
> c
2498,2515c2397,2401
< c> Nov  2013 - added wndlfg=5 for 10m wind component input, COREv2 stress
< c> Nov  2013 - added flxlfg=5 for COREv2 heat flux
< c> Nov  2013 - added lwflag=-1 for radflx=Qlwdn
< c> Nov  2013 - added albflg for ocean albedo, >0 for shwflx=Qswdn
< c> Jan  2014 - added prsbas and mslprf for sea level pressure forcing
< c> Jan  2014 - /consts/ replaced by parameters
< c> Jan  2014 - kdm    is defined here when macro /* RELO */ is set
< c> Jan  2014 - natm   is defined here when macro /* RELO */ is set
< c> Jan  2014 - kkwall is defined here when macro /* RELO */ is set
< c> Jan  2014 - kknest is defined here when macro /* RELO */ is set
< c> Jan  2014 - lbflag 1 and 3 not supported with dynamic memory allocation
< c> Apr  2014 - added ishelf and flnmshlf
< c> May  2014 - removed lbflag=6
< c> Sep  2014 - langmr can now be 0 to 4
< c> Oct  2014 - added flxlfg=6, sea level pressure is input even if .not. mslprf
< c> Aug  2015 - added stdarc
< c> Aug  2015 - added mxl_no
< c> Nov  2015 - added iniflg<0 for reading a difference archive
---
> c> Nov  2015 - added wndlfg=5 for 10m wind component input, COREv2 stress
> c> Nov  2015 - added flxlfg=5 for COREv2 heat flux
> c> Nov  2015 - added lwflag=-1 for radflx=Qlwdn
> c> Nov  2015 - added albflg for ocean albedo, >0 for shwflx=Qswdn
> c> May  2015 - when btrlfr is set, batrop must be an int. divisor of baclin
end
diff -ibw hycom/cnuity.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/cnuity.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
27d2
<       use mod_cb_arrays  ! HYCOM saved arrays
31c6
<       use mod_stokes     ! HYCOM Stokes drift
---
>       use mod_stokes   !  Stokes Drift Velocity Module
36a12,13
>       include 'common_blocks.h'
> c
64,71d40
< #if defined(RELO)
<       integer, save, allocatable, dimension (:,:) ::
<      & masku,maskv
<       real,    save, allocatable, dimension (:,:) ::
<      & pold
<       real,    save, allocatable, dimension (:) ::
<      & dpmn
< #else
78d46
< #endif
80c48
<       integer i,iflip,iprint,isave,j,jsave,k,l,ia,ib,ja,jb,margin,mbdy
---
>       integer i,iflip,iprint,isave,j,jsave,k,l,ia,ib,ja,jb,mbdy
87,103d54
< #if defined(RELO)
<       if     (.not.allocated(masku)) then
<         allocate(
<      &          masku(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          maskv(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           pold(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) )
<         call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy) ) !real=2*int
<                 masku = -99
<                 maskv = -99
<                  pold = r_init
<         allocate(
<      &           dpmn(1-nbdy:jdm+nbdy) )
<         call mem_stat_add( jdm+2*nbdy )
<                  dpmn = r_init
<       endif
< c
< #endif
148c99
<           do l=1,isu(j) !ok
---
>           do l=1,isu(j)
153d103
<                 utotm(i,j)=(u(i+1,j,k,m)+ubavg(i,j,m))*scuy(i,j)
155c105,109
<                 utotm(i,j)=utotm(i,j)+usd(i+1,j,k)*scuy(i,j)
---
> !             write(6,*)'cnuity.F line 106,i+1,j,k= ',i+1,j,k
>                 utotm(i,j)=(u(i+1,j,k,m)+ubavg(i,j,m)+
>      &                     usd(i+1,j,k))*scuy(i,j)
> #else                
>                 utotm(i,j)=(u(i+1,j,k,m)+ubavg(i,j,m))*scuy(i,j)
164d117
<                 utotm(i,j)=(u(i-1,j,k,m)+ubavg(i,j,m))*scuy(i,j)
166c119,123
<                 utotm(i,j)=utotm(i,j)+usd(i-1,j,k)*scuy(i,j)
---
> !               write(6,*)'cnuity.F line 119,i-1,j,k= ',i-1,j,k
>                 utotm(i,j)=(u(i-1,j,k,m)+ubavg(i,j,m)+
>      &                      usd(i-1,j,k))*scuy(i,j)
> #else               
>                 utotm(i,j)=(u(i-1,j,k,m)+ubavg(i,j,m))*scuy(i,j)
181c138
<           do l=1,jsv(i) !ok
---
>           do l=1,jsv(i)
186d142
<                 vtotm(i,j)=(v(i,j+1,k,m)+vbavg(i,j,m))*scvx(i,j)
188c144,148
<                 vtotm(i,j)=vtotm(i,j)+vsd(i,j+1,k)*scvx(i,j)
---
> !             write(6,*)'cnuity.F line 144,i,j+1,k= ',i,j+1,k
>                 vtotm(i,j)=(v(i,j+1,k,m)+vbavg(i,j,m)+
>      &                      vsd(i,j+1,k))*scvx(i,j)
> #else               
>                 vtotm(i,j)=(v(i,j+1,k,m)+vbavg(i,j,m))*scvx(i,j)
197d156
<                 vtotm(i,j)=(v(i,j-1,k,m)+vbavg(i,j,m))*scvx(i,j)
199c158,162
<                 vtotm(i,j)=vtotm(i,j)+vsd(i,j-1,k)*scvx(i,j)
---
> !             write(6,*)'cnuity.F line 144,i,j-1,k= ',i,j-1,k
>                 vtotm(i,j)=(v(i,j-1,k,m)+vbavg(i,j,m)+vsd(i,j-1,k)
>      &                                   )*scvx(i,j)
> #else              
>                 vtotm(i,j)=(v(i,j-1,k,m)+vbavg(i,j,m))*scvx(i,j)
215c178
< !$OMP   PARALLEL DO PRIVATE(j,i,q)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,q)
218,220c181,183
<           do i=1-margin,ii+margin
<             if (SEA_U) then
<               utotm(i,j)=(u(i,j,k,m)+ubavg(i,j,m))*scuy(i,j)
---
> c
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
222c185,189
<               utotm(i,j)=utotm(i,j)+usd(i,j,k)*scuy(i,j)
---
> !             write(6,*)'cnuity.F line 181,i,j,k= ',i,j,k
>               utotm(i,j)=(u(i,j,k,m)+ubavg(i,j,m)+
>      &                    usd(i,j,k))*scuy(i,j)
> #else               
>               utotm(i,j)=(u(i,j,k,m)+ubavg(i,j,m))*scuy(i,j)
232,233c199,200
<             endif !iu
<           enddo !i
---
>             enddo
>           enddo
236,238c203,204
<           do i=1-margin,ii+margin
<             if (SEA_V) then
<               vtotm(i,j)=(v(i,j,k,m)+vbavg(i,j,m))*scvx(i,j)
---
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
240c206,209
<               vtotm(i,j)=vtotm(i,j)+vsd(i,j,k)*scvx(i,j)
---
>               vtotm(i,j)=(v(i,j,k,m)+vbavg(i,j,m)+vsd(i,j,k)
>      &                               )*scvx(i,j)
> #else                
>               vtotm(i,j)=(v(i,j,k,m)+vbavg(i,j,m))*scvx(i,j)
250,251c219,220
<             endif !iv
<           enddo !i
---
>             enddo
>           enddo
253,254c222
<         enddo !j
< !$OMP   END PARALLEL DO
---
>         enddo
255a224
> !$OMP   END PARALLEL DO
263c232
< !$OMP   PARALLEL DO PRIVATE(j,i,dpmin)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,dpmin)
267,268c236,237
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
275,276c244,245
<             endif !ip
<           enddo !i
---
>             enddo
>           enddo
278c247
<         enddo  !j, loop 19
---
>         enddo  ! loop 19
294c263
<           do l=1,isu(j) !ok
---
>           do l=1,isu(j)
311c280
<           do l=1,jsv(i) !ok
---
>           do l=1,jsv(i)
368c337
< !$OMP   PARALLEL DO PRIVATE(j,i,ia,ib,ja,jb)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,ia,ib,ja,jb)
371,372c340,341
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
374,377c343,350
<               ia=ipim1(i,j) !i-1 if sea and i if land
<               ib=ipip1(i,j) !i+1 if sea and i if land
<               ja=ipjm1(i,j) !j-1 if sea and j if land
<               jb=ipjp1(i,j) !j+1 if sea and j if land
---
>               ia=i-1
>               if (ip(ia,j).eq.0) ia=i
>               ib=i+1
>               if (ip(ib,j).eq.0) ib=i
>               ja=j-1
>               if (ip(i,ja).eq.0) ja=j
>               jb=j+1
>               if (ip(i,jb).eq.0) jb=j
393,395c366,368
<             endif !ip
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
410c383
< !$OMP   PARALLEL DO PRIVATE(j,i,clip)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,clip)
413,414c386,388
<           do i=1-margin,ii+margin
<             if (SEA_U) then
---
> c
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
423,424c397,398
<             endif !iu
<           enddo !i
---
>             enddo
>           enddo
426,427c400,401
<           do i=1-margin,ii+margin
<             if (SEA_V) then
---
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
436,438c410,412
<             endif !iv
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
448c422
< !$OMP   PARALLEL DO PRIVATE(j,i,dpmin)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,dpmin)
452,453c426,427
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
459,460c433,434
<             endif !ip
<           enddo !i
---
>             enddo
>           enddo
462c436
<         enddo  !j, loop 15
---
>         enddo  ! loop 15
490,491c464,465
<               do i=1,ii
<                 if (SEA_P) then
---
>               do l=1,isp(j)
>                 do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
497d470
<                 endif !ip
498a472
>               enddo !l
503,504c477,478
<                 do i=1,ii
<                   if (SEA_P) then
---
>                 do l=1,isp(j)
>                   do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
511d484
<                   endif !ip
512a486
>                 enddo !l
523,524c497,498
<               do i=1,ii
<                 if (SEA_P) then
---
>               do l=1,isp(j)
>                 do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
530d503
<                 endif !ip
531a505
>               enddo !l
536,537c510,511
<                 do i=1,ii
<                   if (SEA_P) then
---
>                 do l=1,isp(j)
>                   do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
544d517
<                   endif !ip
545a519
>                 enddo !l
576c550
< !$OMP   PARALLEL DO PRIVATE(j,i,q)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,q)
579,580c553,555
<           do i=1-margin,ii+margin
<             if (SEA_U) then
---
> c
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
600,601c575,576
<             endif !iu
<           enddo !i
---
>             enddo
>           enddo
603,604c578,579
<           do i=1-margin,ii+margin
<             if (SEA_V) then
---
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
624,626c599,601
<             endif !iv
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
634c609
< !$OMP   PARALLEL DO PRIVATE(j,i,dpmin)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,dpmin)
638,639c613,614
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
645,646c620,621
<             endif !ip
<           enddo !i
---
>             enddo
>           enddo
648c623
<         enddo  !j, loop 14
---
>         enddo  ! loop 14
674,675c649,650
<               do i=1,ii
<                 if (SEA_P) then
---
>               do l=1,isp(j)
>                 do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
680d654
<                 endif !ip
681a656
>               enddo !l
696c671
< !$OMP PARALLEL DO PRIVATE(j,k,i,q)
---
> !$OMP PARALLEL DO PRIVATE(j,l,k,i,q)
699,700c674,675
<         do i=1-margin,ii+margin
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
709d683
<           endif !ip
710a685
>         enddo !l
742c717
< !$OMP PARALLEL DO PRIVATE(j,i)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i)
745,746c720,721
<         do i=1-margin,ii+margin
<           if (SEA_U) then
---
>         do l=1,isu(j)
>           do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
748,749c723,726
<           endif !iu
<           if (SEA_V) then
---
>           enddo
>         enddo
>         do l=1,isv(j)
>           do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
751,752c728,731
<           endif !iv
<           if (SEA_P) then
---
>           enddo
>         enddo
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
758,760c737,739
<           endif !ip
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
772c751
< !$OMP   PARALLEL DO PRIVATE(j,i,ia,ib,ja,jb)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,ia,ib,ja,jb)
775,776c754,769
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
> c ---         assume margin<nblk
>               ia=i-1
>               if (ip(ia,j) .eq. 0) ia=i+1
>               if (ip(ia,j) .eq. 0) ia=i
>               ib=i+1
>               if (ip(ib,j) .eq. 0) ib=i-1
>               if (ip(ib,j) .eq. 0) ib=i
>               ja=j-1
>               if (ip(i,ja) .eq. 0) ja=j+1
>               if (ip(i,ja) .eq. 0) ja=j
>               jb=j+1
>               if (ip(i,jb) .eq. 0) jb=j-1
>               if (ip(i,jb) .eq. 0) jb=j
> c
781,784d773
<                 ia=ipim1x(i,j) !i-1 if sea; else i+1 if sea; otherwise i
<                 ib=ipip1x(i,j) !i+1 if sea; else i-1 if sea; otherwise i
<                 ja=ipjm1x(i,j) !j-1 if sea; else j+1 if sea; otherwise j
<                 jb=ipjp1x(i,j) !j+1 if sea; else j-1 if sea; otherwise j
805,808c794,797
<               endif !min(dp):else
<             endif !ip
<           enddo !i
<         enddo !j
---
>               endif
>             enddo
>           enddo
>         enddo
820c809
< !$OMP   PARALLEL DO PRIVATE(j,i,flxhi,flxlo,thkdfu,thkdfv)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,flxhi,flxlo,thkdfu,thkdfv)
824,825c813,814
<           do i=1-margin,ii+margin
<             if (SEA_U) then
---
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
853,854c842,843
<             endif !iu
<           enddo !i
---
>             enddo
>           enddo
856,857c845,846
<           do i=1-margin,ii+margin
<             if (SEA_V) then
---
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
885,887c874,876
<             endif !iv
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
895c884
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i)
898,899c887,888
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
903,905c892,894
<             endif !ip
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
920c909
< !$OMP PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP PARALLEL DO PRIVATE(j,k,l,i)
924,925c913,914
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
936,939c925,928
<             endif !ip
<           enddo !i
<         enddo !k
<       enddo !j
---
>             enddo
>           enddo
>         enddo
>       enddo
971c960
< !$OMP PARALLEL DO PRIVATE(j,i)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i)
974,975c963,964
<         do i=1-margin,ii+margin
<           if (SEA_U) then
---
>         do l=1,isu(j)
>           do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
977,981c966,969
<           endif !iu
<           if (SEA_V) then
<             vflux(i,j)=0.
<           endif !iv
<           if (SEA_P) then
---
>           enddo
>         enddo
>         do l=1,isv(j)
>           do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
982a971,974
>           enddo
>         enddo
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
988,990c980,982
<           endif !ip
<         enddo !i
<       enddo !j
---
>           enddo
>         enddo
>       enddo
1009c1001
< !$OMP   PARALLEL DO PRIVATE(j,i,flxhi,flxlo,thkdfu,thkdfv)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,flxhi,flxlo,thkdfu,thkdfv)
1013,1014c1005,1006
<           do i=1-margin,ii+margin
<             if (SEA_U) then
---
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
1024,1025c1016,1017
<             endif !iu
<           enddo !i
---
>             enddo
>           enddo
1027,1028c1019,1020
<           do i=1-margin,ii+margin
<             if (SEA_V) then
---
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
1038,1040c1030,1032
<             endif !iv
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
1048c1040
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i)
1051,1052c1043,1044
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1056,1058c1048,1050
<             endif !ip
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
1073c1065
< !$OMP PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP PARALLEL DO PRIVATE(j,k,l,i)
1077,1078c1069,1070
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1089,1092c1081,1084
<             endif !ip
<           enddo !i
<         enddo !k
<       enddo !j
---
>             enddo
>           enddo
>         enddo
>       enddo
1108c1100
< !$OMP   PARALLEL DO PRIVATE(j,i,k)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,k)
1111,1112c1103,1104
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1117,1120c1109,1112
<               enddo !k
<             endif !ip
<           enddo !i
<         enddo !j
---
>               enddo
>             enddo
>           enddo
>         enddo
1131c1123
< 
---
> c
1134c1126
< !$OMP   PARALLEL DO PRIVATE(j,k,i,dpup,dpdn,q)
---
> !$OMP   PARALLEL DO PRIVATE(j,k,l,i,dpup,dpdn,q)
1137,1138c1129,1130
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1141,1142c1133
<             endif !ip
<           enddo !i
---
>             enddo
1144,1145c1135
<             do i=1-margin,ii+margin
<               if (SEA_P) then
---
>               do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1155,1158c1145,1148
<               endif !ip
<             enddo !i
<           enddo !k
<         enddo !j
---
>               enddo
>             enddo
>           enddo
>         enddo
1167c1157
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
1170,1171c1160,1161
<             do i=1-margin,ii+margin
<               if (SEA_U) then
---
>             do l=1,isu(j)
>               do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
1173,1174c1163,1166
<               endif !iu
<               if (SEA_V) then
---
>               enddo
>             enddo
>             do l=1,isv(j)
>               do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
1176,1178c1168,1170
<               endif !iu
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
1186c1178
< !$OMP     PARALLEL DO PRIVATE(j,i,ia,ib,ja,jb)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i,ia,ib,ja,jb)
1189,1194c1181,1196
<             do i=1-margin,ii+margin
<               if (SEA_P) then
<                 ia=ipim1x(i,j) !i-1 if sea; else i+1 if sea; otherwise i
<                 ib=ipip1x(i,j) !i+1 if sea; else i-1 if sea; otherwise i
<                 ja=ipjm1x(i,j) !j-1 if sea; else j+1 if sea; otherwise j
<                 jb=ipjp1x(i,j) !j+1 if sea; else j-1 if sea; otherwise j
---
>             do l=1,isp(j)
>               do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
> c ---           assume margin<nblk
>                 ia=i-1
>                 if (ip(ia,j) .eq. 0) ia=i+1
>                 if (ip(ia,j) .eq. 0) ia=i
>                 ib=i+1
>                 if (ip(ib,j) .eq. 0) ib=i-1
>                 if (ip(ib,j) .eq. 0) ib=i
>                 ja=j-1
>                 if (ip(i,ja) .eq. 0) ja=j+1
>                 if (ip(i,ja) .eq. 0) ja=j
>                 jb=j+1
>                 if (ip(i,jb) .eq. 0) jb=j-1
>                 if (ip(i,jb) .eq. 0) jb=j
> c
1199,1201c1201,1203
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
1209c1211
< !$OMP     PARALLEL DO PRIVATE(j,i,thkdfu,thkdfv)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i,thkdfu,thkdfv)
1212,1213c1214,1216
<             do i=1-margin,ii+margin
<               if (SEA_U) then
---
> c
>             do l=1,isu(j)
>               do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
1217,1218c1220,1223
<               endif !iu
<               if (SEA_V) then
---
>               enddo
>             enddo
>             do l=1,isv(j)
>               do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
1222,1224c1227,1229
<               endif !iv
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
1232c1237
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
1235,1236c1240,1241
<             do i=1-margin,ii+margin
<               if (SEA_P) then
---
>             do l=1,isp(j)
>               do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1240,1242c1245,1247
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
1250c1255
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
1253,1254c1258,1259
<             do i=1-margin,ii+margin
<               if (SEA_U) then
---
>             do l=1,isu(j)
>               do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
1256,1257c1261,1264
<               endif !iu
<               if (SEA_V) then
---
>               enddo
>             enddo
>             do l=1,isv(j)
>               do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
1259,1261c1266,1268
<               endif !iu
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
1269c1276
< !$OMP     PARALLEL DO PRIVATE(j,i,thkdfu,thkdfv)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i,thkdfu,thkdfv)
1272,1273c1279,1281
<             do i=1-margin,ii+margin
<               if (SEA_U) then
---
> c
>             do l=1,isu(j)
>               do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
1277,1278c1285,1289
<               endif !iu
<               if (SEA_V) then
---
>               enddo
>             enddo
> c
>             do l=1,isv(j)
>               do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
1282,1284c1293,1295
<               endif !iv
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
1292c1303
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
1295,1296c1306,1307
<             do i=1-margin,ii+margin
<               if (SEA_P) then
---
>             do l=1,isp(j)
>               do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1300,1302c1311,1313
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
1316c1327
< !$OMP PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP PARALLEL DO PRIVATE(j,k,l,i)
1320,1321c1331,1332
<           do i=1-margin,ii+margin
<             if (SEA_U) then
---
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
1323,1324c1334,1337
<             endif !iu
<             if (SEA_V) then
---
>             enddo
>           enddo
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
1326,1327c1339,1342
<             endif !iv
<             if (SEA_P) then
---
>             enddo
>           enddo
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1329,1332c1344,1347
<             endif !ip
<           enddo !i
<         enddo !k
<       enddo !j
---
>             enddo
>           enddo
>         enddo
>       enddo
1344c1359
< !$OMP PARALLEL DO PRIVATE(j,i,k,
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,k,
1348,1349c1363,1364
<         do i=1-margin,ii+margin
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1358d1372
<           endif !ip
1359a1374
>         enddo !l
1384,1386d1398
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
< c> May  2014 - use ipim1, ipip1, ipjm1, ipjp1  as sea-only neighbors
< c> May  2014 - use ipim1x,ipip1x,ipjm1x,ipjp1x as sea-only neighbors
end
diff -ibw hycom/convec.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/convec.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/convec.F: No such file or directory
end
diff -ibw hycom/diapfl.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/diapfl.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
27d2
<       use mod_cb_arrays  ! HYCOM saved arrays
32a8,9
>       include 'common_blocks.h'
> c
60c37
<       do j=1,jj
---
>       do j=1-margin,jj+margin
70c47
<       do j=1,jj
---
>       do j=1-margin,jj+margin
79d55
<       use mod_cb_arrays  ! HYCOM saved arrays
81a58,59
>       include 'common_blocks.h'
> c
83c61
<       integer i
---
>       integer i,l
85,86c63,64
<       do i=1,ii
<         if (SEA_P) then
---
>       do l=1,isp(j)
>         do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
88,89c66,67
<         endif !ip
<       enddo !i
---
>         enddo
>       enddo
95d72
<       use mod_cb_arrays  ! HYCOM saved arrays
97a75,76
>       include 'common_blocks.h'
> c
99c78
<       integer i
---
>       integer i,l
101,102c80,81
<       do i=1,ii
<         if (SEA_U) then
---
>       do l=1,isu(j)
>         do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
104,105c83,87
<         endif !iu
<         if (SEA_V) then
---
>         enddo
>       enddo
> c
>       do l=1,isv(j)
>         do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
107,108c89,90
<         endif !iv
<       enddo !i
---
>         enddo
>       enddo
114d95
<       use mod_cb_arrays  ! HYCOM saved arrays
116c97
<       use mod_stokes     ! HYCOM Stokes drift
---
>       use mod_stokes   !  Stokes Drift Velocity Module
123a105,106
>       include 'common_blocks.h'
> c
345a329
> cdiag do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
349a334
> cdiag end do
492d476
<       use mod_cb_arrays  ! HYCOM saved arrays
497a482,483
>       include 'common_blocks.h'
> c
576d561
<       use mod_cb_arrays  ! HYCOM saved arrays
581a567,568
>       include 'common_blocks.h'
> c
662d648
<       use mod_cb_arrays  ! HYCOM saved arrays
667a654,655
>       include 'common_blocks.h'
> c
679c667
<       do 31 j=1,jj
---
>       do 31 j=1-margin,jj+margin
686c674
<      &            p,depthu,depthv, 0,0)
---
>      &            p,depthu,depthv, max(0,margin-1))
693d680
<       use mod_cb_arrays  ! HYCOM saved arrays
695a683,684
>       include 'common_blocks.h'
> c
698c687
<       integer i,k,k1,k2,ka,kmin(idm),kmax(idm),ktr
---
>       integer i,k,k1,k2,ka,kmin(idm),kmax(idm),ktr,l
721,722c710
<       do i=1,ii
<       if (SEA_P) then
---
>       do 31 l=1,isp(j)
724a713
> *     do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
730a720
> *     end do
732c722,723
<       do k=1,kk
---
>       do 33 k=1,kk
>       do 33 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
734c725
<       enddo !k
---
>    33 continue
735a727
>       do 32 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
746c738
<       enddo !ktr
---
>       enddo
755a748
>    32 continue
757c750,752
<       do k=2,kk
---
>       do 36 k=2,kk
> c
>       do 36 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
767c762
<       enddo !k
---
>    36 continue
775c770
<       do k=2,kk-1
---
>       do 43 k=2,kk-1
778a774
>       do 43 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
824c820
<       enddo !k
---
>    43 continue
829c825,827
<       do k=1,kk
---
>       do 37 k=1,kk
> c
>       do 37 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
870c868
<       enddo !k
---
>    37 continue
874,877c872,874
<       do k=1,kk
<       if (k.gt.kmin(i) .and. k.le.kmax(i)) then
<           pdot(i,k)=flxu(i,k)-flxl(i,k-1)
<       else
---
>       do 38 k=1,kk
> c
>       do 38 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
879,880c876,878
<       endif
<       enddo !k
---
>       if (k.gt.kmin(i) .and. k.le.kmax(i))
>      .    pdot(i,k)=flxu(i,k)-flxl(i,k-1)
>    38 continue
884c882,884
<       do k=1,kk
---
>       do 35 k=1,kk
> c
>       do 35 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
903,904c903,904
<       enddo !ktr
<       enddo !k
---
>       enddo
>    35 continue
905a906
>       do 34 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
908c909
<       enddo !ktr
---
>       enddo
910a912
>    34 continue
913c915
<       do k=kk,1,-1
---
>       do 39 k=kk,1,-1
915a918
>       do 39 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
965c968
<       enddo !k
---
>    39 continue
966a970
>       do 30 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
971c975,976
<       enddo !ktr
---
>       enddo
>    30 continue
973c978,979
<       do k=1,kk
---
>       do 41 k=1,kk
>       do 41 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
981c987
<       enddo !ktr
---
>       enddo
986c992
<       enddo !k
---
>    41 continue
988a995
> *     do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1001a1009
> *     end do
1002a1011
> cdiag do 31 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1010,1011c1019
<       endif !ip
<       enddo !i
---
>    31 continue
1018d1025
<       use mod_cb_arrays  ! HYCOM saved arrays
1023a1031,1032
>       include 'common_blocks.h'
> c
1035c1044
<       do 31 j=1,jj
---
>       do 31 j=1-margin,jj+margin
1041c1050
<      &            p,depthu,depthv, 0,0)
---
>      &            p,depthu,depthv, max(0,margin-1))
1048d1056
<       use mod_cb_arrays  ! HYCOM saved arrays
1053a1062,1063
>       include 'common_blocks.h'
> c
1078,1079c1088
<       do i=1,ii
<       if (SEA_P) then
---
>       do 31 l=1,isp(j)
1081c1090,1091
<       do k=1,kk
---
>       do 33 k=1,kk
>       do 33 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1083c1093
<       enddo !k
---
>  33   continue
1084a1095
>       do 32 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1088c1099
<       enddo !ktr
---
>       enddo
1100c1111
<       kmax(i)=1
---
>  32   kmax(i)=1
1102c1113,1115
<       do k=2,kk
---
>       do 36 k=2,kk
> c
>       do 36 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1118c1131
<       enddo !k
---
>  36   continue
1126c1139,1141
<       do k=3,kk
---
>       do 40 k=3,kk
> c
>       do 40 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1148c1163
<       enddo !k
---
>  40   continue
1152c1167
<       do k=2,kk
---
>       do 43 k=2,kk
1155a1171
>       do 43 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1200c1216
<       enddo !k
---
>  43   continue
1205c1221,1223
<       do k=2,kk
---
>       do 37 k=2,kk
> c
>       do 37 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1247c1265
<       enddo !k
---
>  37   continue
1251c1269,1271
<       do k=2,kk
---
>       do 38 k=2,kk
> c
>       do 38 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1254c1274
<       enddo !k
---
>  38   continue
1258c1278,1280
<       do k=2,kk
---
>       do 35 k=2,kk
> c
>       do 35 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1269c1291
<       enddo !k
---
>  35   continue
1272c1294,1296
<       do k=kk,2,-1
---
>       do 39 k=kk,2,-1
> c
>       do 39 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1307c1331
<       enddo !k
---
>  39   continue
1311c1335,1337
<       do k=3,kk
---
>       do 44 k=3,kk
> c
>       do 44 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1331c1357
<       enddo !k
---
>  44   continue
1333c1359,1360
<       do k=kk,2,-1
---
>       do 42 k=kk,2,-1
>       do 42 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1353c1380
<       enddo !k
---
>  42   continue
1355c1382,1383
<       do k=1,kk
---
>       do 41 k=1,kk
>       do 41 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1361,1362c1389
<       p(i,j,k+1)=p(i,j,k)+dp(i,j,k,n)
<       enddo !k
---
>  41   p(i,j,k+1)=p(i,j,k)+dp(i,j,k,n)
1363a1391
>       do 31 i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1373,1374c1401
<       endif !ip
<       enddo !i
---
>  31   continue
1381c1408
<      &            p,depthu,depthv, 0,0)
---
>      &            p,depthu,depthv, max(0,margin-1))
1402c1429
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
---
> 
end
diff -ibw hycom/dimensions.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/dimensions.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
20c9
<       parameter (itdm=500,jtdm=382,kdm=32)  ! GLBT0.72
---
>       parameter (itdm=4500,jtdm=3298,kdm=41)  ! GLBb0.08
25c14
<       parameter (iqr=10,jqr=10)  ! multiple tiles (TYPE=ompi or mpi or shmem)
---
>       parameter (iqr=99,jqr=99)  ! multiple tiles (TYPE=ompi or mpi or shmem)
31c20
<       parameter (idm= 250,jdm= 191)  ! NMPI=4,8,16,24,32,40,47,64
---
>       parameter (idm= 250,jdm=  92)  ! NMPI=900
40c29
<       parameter (kkwall=  1)  ! must be 1 or kdm
---
>       parameter (kkwall=kdm)  ! must be 1 or kdm
49c38
<       parameter (nlgiss=  1)  ! must be 1 (no GISS) or 762
---
>       parameter (nlgiss=762)  ! must be 1 (no GISS) or 762
55,57c44,46
< c --- natm  = number of saved atmospheric fields
<       integer    natm
<       parameter (natm=2)      ! must be 2 (high freq.) or 4 (monthly)
---
> c --- nsteps_baclin = maximum baroclinic steps per day
>       integer    nsteps_baclin
>       parameter (nsteps_baclin =1440)  !one minute or longer time step
59a49,103
> c-----------------------------------------------------------------------------
> c
> c --- halo size
>       integer    nbdy
>       parameter (nbdy=6)
> c
> c --- OpenMP will allocate jblk rows to each thread in turn
>       integer    jblk
>       parameter (jblk=(jdm+2*nbdy+mxthrd-1)/mxthrd)
> c
> c --- for CCSM array dimensions
>       integer    imt1,imt2,jmt1,jmt2
>       parameter (imt1=1-nbdy,imt2=idm+nbdy,
>      &           jmt1=1-nbdy,jmt2=jdm+nbdy )
> c
> c --- how far out the halo is valid (margin<=nbdy)
>       integer      margin
>       common/edge/ margin
>       save  /edge/
> c
> c --- actual extent of this tile is (i0+1:i0+ii,j0+1:j0+jj,1:kk)
>       integer      i0,j0,ii,jj
>       common/dimi/ i0,j0,ii,jj
>       save  /dimi/
>       integer      kk
>       parameter   (kk=kdm)
> c
> c --- ijqr  = maximum total number of active tiles (= ipr*jpr)
>       integer    ijqr
>       parameter (ijqr=iqr*jqr)
> c
> c --- ms-1  = max. number of interruptions of any tile row or column by land
>       integer    ms
>       parameter (ms=99)  ! should be enough for any region
> c
> c --- information in /gindex/ keeps do loops from running into land
>       integer, dimension (1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) ::
>      &         ip,iu,iv,iq, iuopn,ivopn
>       integer, dimension (1-nbdy:jdm+nbdy,ms) :: 
>      &         ifp,ilp,ifq,ilq,ifu,ilu,ifv,ilv
>       integer, dimension (1-nbdy:idm+nbdy,ms) :: 
>      &         jfp,jlp,jfq,jlq,jfu,jlu,jfv,jlv
>       integer, dimension (1-nbdy:jdm+nbdy) :: 
>      &         isp,isq,isu,isv
>       integer, dimension (1-nbdy:idm+nbdy) :: 
>      &         jsp,jsq,jsu,jsv
>       common/gindex/ ip,iu,iv,iq, iuopn,ivopn,
>      &               ifp,ilp,isp,jfp,jlp,jsp,ifq,ilq,isq,jfq,jlq,jsq,
>      &               ifu,ilu,isu,jfu,jlu,jsu,ifv,ilv,isv,jfv,jlv,jsv
>       save  /gindex/
> c
> c --- line printer unit (stdout)
>       integer        lp
>       common/linepr/ lp
>       save  /linepr/
end
diff -ibw hycom/dimensions_relo.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/dimensions_relo.h
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/dimensions_relo.h: No such file or directory
end
diff -ibw hycom/dpthuv.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/dpthuv.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/dpthuv.F: No such file or directory
end
diff -ibw hycom/dpudpv.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/dpudpv.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/dpudpv.F: No such file or directory
end
diff -ibw hycom/forfun.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/forfun.f
1,51d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
<       subroutine datefor(wday, iyr,mon,idy,ihr)
<       implicit none
< c
<       real*8  wday
<       integer iyr,mon,idy,ihr
< c
< c**********
< c*
< c  1) convert date into 'model day', for yrflag=3 only.
< c
< c  2) the 'model day' is the number of days since 001/1901 (which is 
< c      model day 1.0).
< c     for example:
< c      a) iyr=1901,mon=1,idy=1, represents 0000z hrs on 01/01/1901
< c         so wday would be 1.0.
< c      a) iyr=1901,mon=1,idy=2, represents 0000z hrs on 02/01/1901
< c         so wday would be 2.0.
< c     year must be no less than 1901.0, and no greater than 2099.0.
< c     note that year 2000 is a leap year (but 1900 and 2100 are not).
< c*
< c**********
< c
<       integer nleap
< c
<       integer month(13)
<       data    month / 0,  31,  59,  90, 120, 151, 181,
<      &                   212, 243, 273, 304, 334, 365 /
< c
< c     find the right year.
< c
<       nleap = (iyr-1901)/4
<       wday  = 365.0d0*(iyr-1901) + nleap + month(mon) + idy + ihr/24.0d0
<       if     (mod(iyr,4).eq.0 .and. mon.gt.2) then
<         wday  = wday + 1.0d0
<       endif
<       return
< c     end of datefor
<       end
< c
< c
115,156d63
<       subroutine fordate(dtime,yrflag, iyear,month,iday,ihour)
<       implicit none
< c
<       real*8  dtime
<       integer yrflag, iyear,month,iday,ihour
< c
< c --- converts model day to "calendar" date (year,month,day,hour).
< c
<       integer jday,k,m
< c
<       integer month0(13,3)
<       data    month0 / 1,  31,  61,  91, 121, 151, 181,
<      +                    211, 241, 271, 301, 331, 361,
<      +                 1,  32,  60,  91, 121, 152, 182,
<      +                    213, 244, 274, 305, 335, 366,
<      +                 1,  32,  61,  92, 122, 153, 183,
<      +                    214, 245, 275, 306, 336, 367 /
< c
<       call forday(dtime,yrflag, iyear,jday,ihour)
< c
<       if (yrflag.eq.3) then
<         if     (mod(iyear,4).eq.0) then
<           k = 3
<         else
<           k = 2
<         endif
<       elseif (yrflag.eq.0) then
<         k = 1
<       else
<         k = 3
<       endif
<       do m= 1,12
<         if     (jday.ge.month0(m,  k) .and.
<      +          jday.lt.month0(m+1,k)      ) then
<           month = m
<           iday  = jday - month0(m,k) + 1
<         endif
<       enddo
<       return
<       end
< c
< c
159d65
<       use mod_cb_arrays  ! HYCOM saved arrays
161a68
>       include 'common_blocks.h'
174,175c81
< c --- units of vapmix are kg/k
< c --- units of mslprs are Pa     (anomaly, offset from total by prsbas)
---
> c --- units of vapmix are kg/kg
189c95
< c --- I/O and array I/O units 899-910 are reserved for the entire run.
---
> c --- I/O and array I/O units 900-910 are reserved for the entire run.
191c97
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
210,222d115
<       if     (mslprf .or. flxflg.eq.6) then
<       call zaiopf(flnmfor(1:lgth)//'forcing.mslprs.a', 'old', 899)
<       if     (mnproc.eq.1) then  ! .b file from 1st tile only
<       open (unit=uoff+899,file=flnmfor(1:lgth)//'forcing.mslprs.b',
<      &   status='old', action='read')
<       read (uoff+899,'(a79)') preambl
<       endif !1st tile
<       call preambl_print(preambl)
<       call rdmonth(util1, 899)
< cdiag call prtmsk(ip,util1,util2,idm,idm,jdm,  0.,1.,
< cdiag.     'mslprs (Pa)')
<       endif !mslprf
< c
330d222
<       if     (flxflg.ne.3) then
352d243
<       endif !flxflg.ne.3
497d387
<       use mod_cb_arrays  ! HYCOM saved arrays
499a390
>       include 'common_blocks.h'
510c401
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
579d469
<       use mod_cb_arrays  ! HYCOM saved arrays
581a472
>       include 'common_blocks.h'
597d487
< c --- units of mslprs are Pa     (anomaly, offset from total by prsbas)
609c499
< c --- I/O and array I/O units 899-910 are reserved for the entire run.
---
> c --- I/O and array I/O units 900-910 are reserved for the entire run.
611c501
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
643d532
<         if     (natm.eq.4) then
649,672c538,557
<                 taux(i,j,natm-1) = 0.0
<                 taux(i,j,natm)   = 0.0
<                 tauy(i,j,natm-1) = 0.0
<                 tauy(i,j,natm)   = 0.0
<               wndspd(i,j,natm-1) = 0.0
<               wndspd(i,j,natm)   = 0.0
<               ustara(i,j,natm-1) = 0.0
<               ustara(i,j,natm)   = 0.0
<               airtmp(i,j,natm-1) = 0.0
<               airtmp(i,j,natm)   = 0.0
<               vapmix(i,j,natm-1) = 0.0
<               vapmix(i,j,natm)   = 0.0
<               mslprs(i,j,natm-1) = 0.0
<               mslprs(i,j,natm)   = 0.0
<               precip(i,j,natm-1) = 0.0
<               precip(i,j,natm)   = 0.0
<               radflx(i,j,natm-1) = 0.0
<               radflx(i,j,natm)   = 0.0
<                swflx(i,j,natm-1) = 0.0
<                swflx(i,j,natm)   = 0.0
<               surtmp(i,j,natm-1) = 0.0
<               surtmp(i,j,natm)   = 0.0
<               seatmp(i,j,natm-1) = 0.0
<               seatmp(i,j,natm)   = 0.0
---
>               taux(i,j,3) = 0.0
>               taux(i,j,4) = 0.0
>               tauy(i,j,3) = 0.0
>               tauy(i,j,4) = 0.0
>             wndspd(i,j,3) = 0.0
>             wndspd(i,j,4) = 0.0
>             airtmp(i,j,3) = 0.0
>             airtmp(i,j,4) = 0.0
>             vapmix(i,j,3) = 0.0
>             vapmix(i,j,4) = 0.0
>             precip(i,j,3) = 0.0
>             precip(i,j,4) = 0.0
>             radflx(i,j,3) = 0.0
>             radflx(i,j,4) = 0.0
>              swflx(i,j,3) = 0.0
>              swflx(i,j,4) = 0.0
>             surtmp(i,j,3) = 0.0
>             surtmp(i,j,4) = 0.0
>             seatmp(i,j,3) = 0.0
>             seatmp(i,j,4) = 0.0
675d559
<         endif !natm.eq.4
685,694d568
<         if     (mslprf .or. flxflg.eq.6) then
<         call zaiopf(flnmfor(1:lgth)//'forcing.mslprs.a', 'old', 899)
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<         open (unit=uoff+899,file=flnmfor(1:lgth)//'forcing.mslprs.b',
<      &     status='old', action='read')
<         read (uoff+899,'(a79)') preambl
<         endif !1st tile
<         call preambl_print(preambl)
<         endif !mslprf
< c
778d651
<         if     (flxflg.ne.3) then
794d666
<         endif !flxflg.ne.3
796d667
<         if     (pcipf) then
804d674
<         endif !pcipf
1046,1295d915
<       subroutine forfunhp(dtime)
<       use mod_xc         ! HYCOM communication interface
<       use mod_cb_arrays  ! HYCOM saved arrays
<       use mod_za         ! HYCOM I/O interface
<       implicit none
< c
<       real*8    dtime
< c
< c --- high frequency atmospheric pressure forcing field processing.
< c --- call either forfunh or forfunhp, not both.
< c
< c --- units of mslprs are Pa (anomaly, offset from total by prsbas)
< c
< c --- mslprs is always on the p grid.
< c --- mslprs must be defined at all grid points
< c
< c --- I/O and array I/O unit 899 is reserved for the entire run.
< c
< c
<       real*8    dtime0,dtime1
<       save      dtime0,dtime1
< c
<       character preambl(5)*79,cline*80
<       integer   i,ios,iunit,j,lgth,nrec
< c
< c --- w0 negative on first call only.
<       if     (w0.lt.-1.0) then
< c
< c ---   initialize forcing fields
< c
<         if      (.not.mslprf) then
<           if     (mnproc.eq.1) then
<           write(lp,*)
<           write(lp,*) 'error in forfunhp - mslprf must be .true.'
<           write(lp,*)
<           endif !1st tile
<           call xcstop('(forfunhp)')
<                  stop '(forfunhp)'
<         elseif  (windf) then
<           if     (mnproc.eq.1) then
<           write(lp,*)
<           write(lp,*) 'error in forfunhp - windf must be .false.'
<           write(lp,*)
<           endif !1st tile
<           call xcstop('(forfunhp)')
<                  stop '(forfunhp)'
<         elseif (thermo) then
<           if     (mnproc.eq.1) then
<           write(lp,*)
<           write(lp,*) 'error in forfunhp - thermo must be .false.'
<           write(lp,*)
<           endif !1st tile
<           call xcstop('(forfunhp)')
<                  stop '(forfunhp)'
<         endif
< c
<         if     (natm.eq.4) then
< c ---     linear interpolation in time, so slots 3 and 4 are zero.
< !$OMP     PARALLEL DO PRIVATE(j,i)
< !$OMP&             SCHEDULE(STATIC,jblk)
<           do j=1-nbdy,jj+nbdy
<             do i=1-nbdy,ii+nbdy
<               mslprs(i,j,natm-1) = 0.0
<               mslprs(i,j,natm)   = 0.0
<             enddo
<           enddo
<         endif !natm.eq.4
< c
< c ---   open pressure forcing file.
<         if     (mnproc.eq.1) then
<         write (lp,*) ' now initializing forcing fields ...'
<         endif !1st tile
<         call xcsync(flush_lp)
< c
<         lgth = len_trim(flnmfor)
< c
<         call zaiopf(flnmfor(1:lgth)//'forcing.mslprs.a', 'old', 899)
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<         open (unit=uoff+899,file=flnmfor(1:lgth)//'forcing.mslprs.b',
<      &     status='old', action='read')
<         read (uoff+899,'(a79)') preambl
<         endif !1st tile
<         call preambl_print(preambl)
< c
< c ---   skip ahead to the start time.
<         nrec   = 0
<         dtime1 = huge(dtime1)
<         do  ! infinate loop, with exit at end
<           dtime0 = dtime1
<           nrec   = nrec + 1
<           call zagetc(cline,ios, uoff+899)
<           if     (ios.ne.0) then
<             if     (mnproc.eq.1) then
<               write(lp,*)
<               write(lp,*) 'error in forfunhp - hit end of input'
<               write(lp,*) 'dtime0,dtime1 = ',dtime0,dtime1
<               write(lp,*) 'dtime = ',dtime
<               write(lp,*)
<             endif !1st tile
<             call xcstop('(forfunhp)')
<                    stop '(forfunhp)'
<           endif
<           i = index(cline,'=')
<           read (cline(i+1:),*) dtime1
<           if     (yrflag.eq.2) then
<             if     (nrec.eq.1 .and. abs(dtime1-1096.0d0).gt.0.01) then
< c
< c ---         climatology must start on wind day 1096.0, 01/01/1904.
<               if     (mnproc.eq.1) then
<               write(lp,'(a)')  cline
<               write(lp,'(/ a,a / a,g15.6 /)')
<      &          'error in forfunhp - forcing climatology',
<      &          ' must start on wind day 1096',
<      &          'dtime1 = ',dtime1
<               endif !1st tile
<               call xcstop('(forfunhp)')
<                      stop '(forfunhp)'
<             endif
<             dtime1 = (dtime1 - 1096.0d0) + 
<      &               wndrep*int((dtime+0.00001d0)/wndrep)  !wndrep=366 or 732
<             if     (nrec.ne.1 .and. dtime1.lt.dtime0) then
<               dtime1 = dtime1 + wndrep
<             endif
<           elseif (nrec.eq.1 .and. dtime1.lt.1462.0d0) then
< c
< c ---       otherwise, must start after wind day 1462.0, 01/01/1905.
<             if     (mnproc.eq.1) then
<             write(lp,'(a)')  cline
<             write(lp,'(/ a,a / a,g15.6 /)')
<      &        'error in forfunhp - actual forcing',
<      &        ' must start after wind day 1462',
<      &        'dtime1 = ',dtime1
<             endif !1st tile
<             call xcstop('(forfunhp)')
<                    stop '(forfunhp)'
<           endif
<           if     (dtime0.le.dtime .and. dtime1.gt.dtime) then
<             exit
<           endif
<         enddo   ! infinate loop, with exit above
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           rewind(unit=uoff+899)
<           read (uoff+899,'(a79)') preambl
<         endif
< c
<         do i= 1,nrec-2
<           call skmonth(899)
<         enddo
<         dtime0 = huge(dtime1)
<         call rdpall1(mslprs,dtime1,899,.true.)
<         if     (yrflag.eq.2) then
<           dtime1 = (dtime1 - 1096.0d0) + 
<      &             wndrep*int((dtime+0.00001d0)/wndrep)
<         endif
<         dtime0 = dtime1
<         call rdpall1(mslprs,dtime1,899,.true.)
<         if     (yrflag.eq.2) then
<           dtime1 = (dtime1 - 1096.0d0) + 
<      &             wndrep*int((dtime+0.00001d0)/wndrep)  !wndrep=366 or 732
<           if     (dtime1.lt.dtime0) then
<             dtime1 = dtime1 + wndrep
<           endif
<         endif
<         if     (mnproc.eq.1) then
<         write (lp,*) 
<         write (lp,*) ' dtime,dtime0,dtime1 = ',dtime,dtime0,dtime1
<         write (lp,*) 
<         write (lp,*) ' ...finished initializing forcing fields'
<         endif !1st tile
<         call xcsync(flush_lp)
<       endif  ! initialization
< c
<       if     (dtime.gt.dtime1) then
< c
< c ---   get the next set of fields.
< *           if     (mnproc.eq.1) then
< *           write(lp,*) 'enter rdpall - ',dtime,dtime0,dtime1
< *           endif !1st tile
< *           call xcsync(flush_lp)
<         dtime0 = dtime1
<         call rdpall1(mslprs,dtime1,899,.true.)
<         if     (yrflag.eq.2) then
<           dtime1 = (dtime1 - 1096.0d0) + 
<      &             wndrep*int((dtime+0.00001d0)/wndrep)  !wndrep=366 or 732
<           if     (dtime1.lt.dtime0) then
<             dtime1 = dtime1 + wndrep
<           endif
<         endif
< *           if     (mnproc.eq.1) then
< *           write(lp,*) ' exit rdpall - ',dtime,dtime0,dtime1
< *           endif !1st tile
< *           call xcsync(flush_lp)
<       endif
< c
< c --- linear interpolation in time.
<       w0 = (dtime1-dtime)/(dtime1-dtime0)
<       w1 = 1.0 - w0
< *           if     (mnproc.eq.1) then
< *           write(lp,*) 'rdpall - dtime,w0,w1 = ',dtime,w0,w1
< *           endif !1st tile
< *           call xcsync(flush_lp)
<       return
<       end
< c
< c
<       subroutine forfunhz
<       use mod_xc         ! HYCOM communication interface
<       use mod_cb_arrays  ! HYCOM saved arrays
<       use mod_za         ! HYCOM I/O interface
<       implicit none
< c
< c --- high frequency atmospheric forcing field processing.
< c --- set all fields to zero.
< c
<       integer   i,j,l
< c
<       if     (mnproc.eq.1) then
<       write (lp,*) ' now zeroing forcing fields ...'
<       endif !1st tile
<       call xcsync(flush_lp)
< c
< !$OMP   PARALLEL DO PRIVATE(l,j,i)
< !$OMP&           SCHEDULE(STATIC,jblk)
<       do l=1,natm
<         do j=1-nbdy,jj+nbdy
<           do i=1-nbdy,ii+nbdy
<               taux(i,j,l) = 0.0
<               tauy(i,j,l) = 0.0
<             wndspd(i,j,l) = 0.0
<             ustara(i,j,l) = 0.0
<             airtmp(i,j,l) = 0.0
<             vapmix(i,j,l) = 0.0
<             mslprs(i,j,l) = 0.0
<             precip(i,j,l) = 0.0
<             radflx(i,j,l) = 0.0
<              swflx(i,j,l) = 0.0
<             surtmp(i,j,l) = 0.0
<             seatmp(i,j,l) = 0.0
<           enddo !i
<         enddo !j
<       enddo !l
< c
<       if     (mnproc.eq.1) then
<       write (lp,*) ' ...finished zeroing forcing fields'
<       endif !1st tile
<       call xcsync(flush_lp)
<       return
<       end
< c
< c
1298d917
<       use mod_cb_arrays  ! HYCOM saved arrays
1300a920
>       include 'common_blocks.h'
1310c930
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
1367d986
<       use mod_cb_arrays  ! HYCOM saved arrays
1369a989
>       include 'common_blocks.h'
1379c999
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
1438d1057
<       use mod_cb_arrays  ! HYCOM saved arrays
1440a1060
>       include 'common_blocks.h'
1449c1069
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
1522d1141
<       use mod_cb_arrays  ! HYCOM saved arrays
1524a1144
>       include 'common_blocks.h'
1536c1156
< c --- pwall  is interface   climatology for all layers (pressure units, Pa)
---
> c --- pwall  is interface   climatology for all layers (pressure units)
1545c1165
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
1761d1380
<       use mod_cb_arrays  ! HYCOM saved arrays
1763a1383
>       include 'common_blocks.h'
1771c1391
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
1806d1425
<       use mod_cb_arrays  ! HYCOM saved arrays
1808a1428
>       include 'common_blocks.h'
1816c1436
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
1836c1456
< c --- convert to pressure units (Pa).
---
> c --- convert to pressure units.
1854d1473
<       use mod_cb_arrays  ! HYCOM saved arrays
1856a1476
>       include 'common_blocks.h'
1865c1485
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
1905d1524
<       use mod_cb_arrays  ! HYCOM saved arrays
1907a1527
>       include 'common_blocks.h'
1929c1549
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
2181d1800
<       use mod_cb_arrays  ! HYCOM saved arrays
2183a1803
>       include 'common_blocks.h'
2206d1825
<       use mod_cb_arrays  ! HYCOM saved arrays
2208a1828
>       include 'common_blocks.h'
2236d1855
<       use mod_cb_arrays  ! HYCOM saved arrays
2238a1858
>       include 'common_blocks.h'
2446d2065
<       use mod_cb_arrays  ! HYCOM saved arrays
2448a2068
>       include 'common_blocks.h'
2475d2094
<       use mod_cb_arrays  ! HYCOM saved arrays
2476a2096
>       include 'common_blocks.h'
2486c2106
<       real*8  dtime(899:910)
---
>       real*8  dtime(900:910)
2528d2147
<       if     (flxflg.ne.3) then
2531,2539d2149
<       else
<         dtime(904) = dtime(900)
<         dtime(905) = dtime(900)
<       endif
<       if     (mslprf .or. flxflg.eq.6) then
<         call rdpall1(mslprs,dtime(899),899,mod(icall,3).eq.2)
<       else
<         dtime(899) = dtime(905)
<       endif
2611d2220
<       use mod_cb_arrays  ! HYCOM saved arrays
2613a2223
>       include 'common_blocks.h'
2710,2715d2319
< c --- msl pressure uses the the halo.
< c
<       if     (iunit.eq.899) then
<         call xctilr(field(1-nbdy,1-nbdy,2),1,1, nbdy,nbdy, halo_ps)
<       endif
< c
2733d2336
<       use mod_cb_arrays  ! HYCOM saved arrays
2735a2339
>       include 'common_blocks.h'
2755,2766d2358
<         if     (mslprf .or. flxflg.eq.6) then
<           iunit = 899
<             if     (mnproc.eq.1) then  ! .b file from 1st tile only
<               rewind uoff+iunit
<               read  (uoff+iunit,*)
<               read  (uoff+iunit,*)
<               read  (uoff+iunit,*)
<               read  (uoff+iunit,*)
<               read  (uoff+iunit,*)
<             endif
<             call zaiorw(iunit)
<         endif
2845,2847d2436
<         if     (mslprf .or. flxflg.eq.6) then
<           call skmonth(899)
<         endif
2872,2875d2460
<       if     (mslprf .or. flxflg.eq.6) then
<         call rdmonthck(mslprs(1-nbdy,1-nbdy,lslot),899,mnth)
<         call xctilr(mslprs(1-nbdy,1-nbdy,lslot),1,1, nbdy,nbdy, halo_ps)
<       endif
2917d2501
<         if     (flxflg.ne.3) then
2920d2503
<         endif
2992d2574
<       use mod_cb_arrays  ! HYCOM saved arrays
2994a2577
>       include 'common_blocks.h'
3059d2641
<       use mod_cb_arrays  ! HYCOM saved arrays
3061a2644
>       include 'common_blocks.h'
3126d2708
<       use mod_cb_arrays  ! HYCOM saved arrays
3128a2711
>       include 'common_blocks.h'
3261,3264c2844,2845
<                 p23min(1) = min( p23min(1), 
<      &                           pwall(i,j,min(2,kkwall),lslot) )
<                 p23min(2) = min( p23min(2), 
<      &                           pwall(i,j,min(3,kkwall),lslot) )
---
>                 p23min(1) = min( p23min(1), pwall(i,j,min(2,kk),lslot) )
>                 p23min(2) = min( p23min(2), pwall(i,j,min(3,kk),lslot) )
3347d2927
<       use mod_cb_arrays  ! HYCOM saved arrays
3349a2930
>       include 'common_blocks.h'
3359c2940
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
3361,3362c2942,2943
<       logical   larchm,lmonth
<       save      larchm,lmonth
---
>       logical   larchm
>       save      larchm
3368d2948
<       integer   iyr,mon,idy,ihr
3370d2949
<       real*8    wdaymn(-1:2)
3387d2965
< c
3389,3424d2966
<         lmonth = yrflag.eq.3 .and. abs(bnstfq+30.5).lt.0.1  !monthly mean archives
<         if     (lmonth) then
<           call fordate(dtime,yrflag, iyr,mon,idy,ihr)
<           if     (mon.eq.1) then
<             call datefor(wdaymn(-1), iyr-1,   12,1,0)
<             call datefor(wdaymn( 0), iyr,      1,1,0)
<             call datefor(wdaymn( 1), iyr,      2,1,0)
<             call datefor(wdaymn( 2), iyr,      3,1,0)
<           elseif (mon.eq.11) then
<             call datefor(wdaymn(-1), iyr,     10,1,0)
<             call datefor(wdaymn( 0), iyr,     11,1,0)
<             call datefor(wdaymn( 1), iyr,     12,1,0)
<             call datefor(wdaymn( 2), iyr+1,    1,1,0)
<           elseif (mon.eq.12) then
<             call datefor(wdaymn(-1), iyr,     11,1,0)
<             call datefor(wdaymn( 0), iyr,     12,1,0)
<             call datefor(wdaymn( 1), iyr+1,    1,1,0)
<             call datefor(wdaymn( 2), iyr+1,    2,1,0)
<           else
<             call datefor(wdaymn(-1), iyr,  mon-1,1,0)
<             call datefor(wdaymn( 0), iyr,  mon,  1,0)
<             call datefor(wdaymn( 1), iyr,  mon+1,1,0)
<             call datefor(wdaymn( 2), iyr,  mon+2,1,0)
<           endif
<           if     (dtime.lt.0.5d0*(wdaymn(0)+wdaymn(1))) then
<             dtime0 = 0.5d0*(wdaymn(-1)+wdaymn( 0))
<             dtime1 = 0.5d0*(wdaymn( 0)+wdaymn( 1))
<           else
<             dtime0 = 0.5d0*(wdaymn( 0)+wdaymn( 1))
<             dtime1 = 0.5d0*(wdaymn( 1)+wdaymn( 2))
<           endif
<           lb0    = 1
<           call rdbaro_in(dtime0,larchm,1)
<           lb1    = 2
<           call rdbaro_in(dtime1,larchm,2)
<         else
3440d2981
<         endif
3463,3478d3003
<         if     (lmonth) then
<           dtime0 = dtime1
<           call fordate(dtime1,yrflag, iyr,mon,idy,ihr)
<           if     (mon.eq.11) then
<             call datefor(wdaymn( 1), iyr,     12,1,0)
<             call datefor(wdaymn( 2), iyr+1,    1,1,0)
<           elseif (mon.eq.12) then
<             call datefor(wdaymn( 1), iyr+1,    1,1,0)
<             call datefor(wdaymn( 2), iyr+1,    2,1,0)
<           else
<             call datefor(wdaymn( 1), iyr,  mon+1,1,0)
<             call datefor(wdaymn( 2), iyr,  mon+2,1,0)
<           endif
<           dtime1 = 0.5d0*(wdaymn( 1)+wdaymn( 2))
<           call rdbaro_in(dtime1,larchm,2)
<         else
3483d3007
<         endif
3504d3027
<       use mod_cb_arrays  ! HYCOM saved arrays
3506a3030
>       include 'common_blocks.h'
3533c3057
<       write (lp,"(a,a,a,f12.5,a)") 'rdbaro_in: ',flnm," (",dtime,")"
---
>       write (lp,*) 'rdbaro_in: ',flnm
3731d3254
<       use mod_cb_arrays  ! HYCOM saved arrays
3733a3257
>       include 'common_blocks.h'
3745c3269
< c --- all input fields must be defined at all grid points
---
> c --- all input fields much be defined at all grid points
3747,3748c3271,3272
<       logical   larchm,lmonth
<       save      larchm,lmonth
---
>       logical   larchm
>       save      larchm
3754d3277
<       integer   iyr,mon,idy,ihr
3757d3279
<       real*8    wdaymn(-1:2)
3800d3321
< c
3802,3837d3322
<         lmonth = yrflag.eq.3 .and. abs(nestfq+30.5).lt.0.1  !monthly mean archives
<         if     (lmonth) then
<           call fordate(dtime,yrflag, iyr,mon,idy,ihr)
<           if     (mon.eq.1) then
<             call datefor(wdaymn(-1), iyr-1,   12,1,0)
<             call datefor(wdaymn( 0), iyr,      1,1,0)
<             call datefor(wdaymn( 1), iyr,      2,1,0)
<             call datefor(wdaymn( 2), iyr,      3,1,0)
<           elseif (mon.eq.11) then
<             call datefor(wdaymn(-1), iyr,     10,1,0)
<             call datefor(wdaymn( 0), iyr,     11,1,0)
<             call datefor(wdaymn( 1), iyr,     12,1,0)
<             call datefor(wdaymn( 2), iyr+1,    1,1,0)
<           elseif (mon.eq.12) then
<             call datefor(wdaymn(-1), iyr,     11,1,0)
<             call datefor(wdaymn( 0), iyr,     12,1,0)
<             call datefor(wdaymn( 1), iyr+1,    1,1,0)
<             call datefor(wdaymn( 2), iyr+1,    2,1,0)
<           else
<             call datefor(wdaymn(-1), iyr,  mon-1,1,0)
<             call datefor(wdaymn( 0), iyr,  mon,  1,0)
<             call datefor(wdaymn( 1), iyr,  mon+1,1,0)
<             call datefor(wdaymn( 2), iyr,  mon+2,1,0)
<           endif
<           if     (dtime.lt.0.5d0*(wdaymn(0)+wdaymn(1))) then
<             dtime0 = 0.5d0*(wdaymn(-1)+wdaymn( 0))
<             dtime1 = 0.5d0*(wdaymn( 0)+wdaymn( 1))
<           else
<             dtime0 = 0.5d0*(wdaymn( 0)+wdaymn( 1))
<             dtime1 = 0.5d0*(wdaymn( 1)+wdaymn( 2))
<           endif
<           ln0    = 1
<           call rdnest_in(dtime0,larchm,1)
<           ln1    = 2
<           call rdnest_in(dtime1,larchm,2)
<         else
3839c3324
<             dnesti = 0.5d0*dnestf
---
>           dnesti = 0.5*dnestf
3853d3337
<         endif
3878,3893d3361
<         if     (lmonth) then
<           dtime0 = dtime1
<           call fordate(dtime1,yrflag, iyr,mon,idy,ihr)
<           if     (mon.eq.11) then
<             call datefor(wdaymn( 1), iyr,     12,1,0)
<             call datefor(wdaymn( 2), iyr+1,    1,1,0)
<           elseif (mon.eq.12) then
<             call datefor(wdaymn( 1), iyr+1,    1,1,0)
<             call datefor(wdaymn( 2), iyr+1,    2,1,0)
<           else
<             call datefor(wdaymn( 1), iyr,  mon+1,1,0)
<             call datefor(wdaymn( 2), iyr,  mon+2,1,0)
<           endif
<           dtime1 = 0.5d0*(wdaymn( 1)+wdaymn( 2))
<           call rdnest_in(dtime1,larchm,2)
<         else
3898d3365
<         endif
3919d3385
<       use mod_cb_arrays  ! HYCOM saved arrays
3921a3388
>       include 'common_blocks.h'
3950c3417
<       write (lp,"(a,a,a,f12.5,a)") 'rdnest_in: ',flnm," (",dtime,")"
---
>       write (lp,*) 'rdnest_in: ',flnm
4253d3719
<       use mod_cb_arrays  ! HYCOM saved arrays
4255a3722
>       include 'common_blocks.h'  ! for ip.
4313d3779
<       use mod_cb_arrays  ! HYCOM saved arrays
4315a3782
>       include 'common_blocks.h'
4383,4391c3850,3851
< c> Nov. 2013 - added wndflg=5 (also) for reading 10m wind components
< c> Nov. 2013 - added lwflag.eq.-1 for radflx=Qlwdn, swflx=Qswdn
< c> Jan. 2014 - added mslprf and mslprs and forfunhp
< c> Jan. 2014 - added natm logic
< c> Jan. 2014 - modified natm and pwall logic to avoid gfortran warnings
< c> May  2014 - added forfunhz
< c> Oct  2014 - flxflg==6 requires mslprs input
< c> Aug  2015 - flxflg==3 does not read airtmp and vapmix
< c> Jun  2016 - nestfq and bnstfq -30.5 now for actual monthly means
---
> c> Nov. 2015 - added wndflg=5 (also) for reading 10m wind components
> c> Nov. 2015 - added lwflag.eq.-1 for radflx=Qlwdn, swflx=Qswdn
end
diff -ibw hycom/forfun_test.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/forfun_test.f
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/forfun_test.f: No such file or directory
end
diff -ibw hycom/geopar.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/geopar.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
14d2
<       use mod_cb_arrays  ! HYCOM saved arrays
25a14,15
>       include 'common_blocks.h'
> c
28,29c18
<       real*8    sum_ip,sum_is,sum_isa
<       integer   i,ios,j,k,ktr,l,nishlf
---
>       integer   i,ios,j,k,ktr,l
155,163d143
< #elif defined(ENABLE_ATM)
< c         pang
<           i = index(cline,'=')
<           read (cline(i+1:),*) hminb,hmaxb
<           if     (mnproc.eq.1) then
<           write (lp,'(a)') trim(cline)
<           endif
<           call xcsync(flush_lp)
<           call zaiord(pang, ip,.false., hmina,hmaxa, 9)
297,299d276
< #if defined(ENABLE_ATM)
<       call xctilr(pang,  1,1, nbdy,nbdy, halo_ps)
< #endif
350,423c327
< c --- read ice shelf depth array
< c
<       if     (ishelf.eq.0) then
<         ishlf(:,:) = ip(:,:)  !no ice shelf
<       else
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           write (lp,'(3a)') ' reading ice shelf file from ',
<      &                           trim(flnmshlf),'.[ab]'
<           open (unit=uoff+9,file=trim(flnmshlf)//'.b',
<      &          status='old')
<           read (     uoff+9,'(a79)')  preambl
<         endif
<         call xcsync(flush_lp)
<         call zagetc(cline,ios, uoff+9)
<         if     (ios.ne.0) then
<           if     (mnproc.eq.1) then
<             write(lp,'(/ a,i4,i9 /)')
<      &        'geopar: I/O error from zagetc, iunit,ios = ',uoff+9,ios
<           endif !1st tile
<           call xcstop('(geopar)')
<                  stop '(geopar)'
<         endif
<         i = index(cline,'=')
<         read (cline(i+1:),*)   hminb,hmaxb
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           close(unit=uoff+9)
<           write (lp,'(/(1x,a))') preambl,cline
<         endif
< c
<         call zaiopf(trim(flnmshlf)//'.a','old', 9)
<         call zaiord(util3,ip,.false., hmina,hmaxa, 9)
<         call zaiocl(9)
< c
<         if     (abs(hmina-hminb).gt.abs(hminb)*1.e-4 .or.
<      &          abs(hmaxa-hmaxb).gt.abs(hmaxb)*1.e-4     ) then
<           if     (mnproc.eq.1) then
<           write(lp,'(/ a / a,1p3e14.6 / a,1p3e14.6 /)')
<      &      'error - .a and .b files not consistent:',
<      &      '.a,.b min = ',hmina,hminb,hmina-hminb,
<      &      '.a,.b max = ',hmaxa,hmaxb,hmaxa-hmaxb
<           endif
<           call xcstop('(geopar)')
<                  stop '(geopar)'
<         endif
< c
< !$OMP   PARALLEL DO PRIVATE(j,i)
< !$OMP&           SCHEDULE(STATIC,jblk)
<         do j= 1,jj
<           do i= 1,ii
<             if     (ip(i,j).eq.0) then
<               util3(i,j) = 0.0  !land
<             elseif (util3(i,j).gt.0.5*hugel) then
<               util3(i,j) = 0.0  !ice shelf over ocean
<             elseif (util3(i,j).le.0.0) then
<               util3(i,j) = 0.0  !ice shelf over ocean
<             else
<               util3(i,j) = 1.0  !open ocean
<             endif
<           enddo
<         enddo
<         call xctilr(util3,1,1, nbdy,nbdy, halo_ps)
<         ishlf(:,:) = 0  !for jj:jdm and ii:idm
< !$OMP   PARALLEL DO PRIVATE(j,i)
< !$OMP&           SCHEDULE(STATIC,jblk)
<         do j= 1-nbdy,jj+nbdy
<           do i= 1-nbdy,ii+nbdy
<             ishlf(i,j) = util3(i,j)
<             util2(i,j) = ip(i,j)
<           enddo
<         enddo
< c
<         call xcsum(sum_is,  util3,ip)
<         call xcsum(sum_ip,  util2,ip)
<         call xcsum(sum_isa, scp2, ishlf)
---
>       call xcsum(avgbot, util1,ip)
425,448d328
<         nishlf = nint(sum_ip) - nint(sum_is)
<         if     (mnproc.eq.1) then
<         write (lp,'(/a,i9,f10.2)')
<      &         ' number of ice shelf points and area (10^6 km^2):',
<      &         nishlf,(area-sum_isa)*1.d-12
<         endif
<         call xcsync(flush_lp)
<       endif !ishelf
< c
< c --- In arctic (tripole) domain, top row of mass points is redundent,
< c ---  so always use ipa, based on ishlf, for mass sums
< #if defined(ARCTIC)
<       ipa(:,:) = ishlf(:,:)
<       if     (jj+j0.eq.jtdm) then
< c ---   mask top row of mass points
<         ipa(:,jj:jj+nbdy) = 0
<       endif
< #else
< c --- Not a tripole domain, so ipa=ishlf
<       ipa(:,:) = ishlf(:,:)
< #endif
< c
<       call xcsum(avgbot, util1,ipa)
<       call xcsum(area,   scp2, ipa)
759,760d638
<             dpo(i,j,k,1)=0.0
<             dpo(i,j,k,2)=0.0
791c669
<         do l=1,isp(j) !ok
---
>         do l=1,isp(j)
825c703
<         do l=1,jsp(i) !ok
---
>         do l=1,jsp(i)
875,877d752
< c> Apr. 2014 - added ishlf
< c> Apr. 2014 - added ipa
< c> Feb. 2015 - added pang for coupled cases
end
diff -ibw hycom/hybgen.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/hybgen.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/hybgen.F: No such file or directory
end
diff -ibw hycom/hycom_cice.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/hycom_cice.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
diff -ibw hycom/hycom.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/hycom.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
diff -ibw hycom/icloan.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/icloan.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/icloan.F: No such file or directory
end
diff -ibw hycom/inicon.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/inicon.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/inicon.F: No such file or directory
end
diff -ibw hycom/inigiss.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/inigiss.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
14d2
<       use mod_cb_arrays  ! HYCOM saved arrays
18a7,8
>       include 'common_blocks.h'
> c
639a630
> c
641d631
<       use mod_cb_arrays  ! HYCOM saved arrays
649c639
< c --- and passed back hrough the common block /bb/
---
> c --- and passed back hrough the common block bb0/
690a681,682
>       include 'common_blocks.h'
> c
692c684
<       real eeps,c_yst,c_yst0,c_y,val,c_n,c_c
---
>       real eeps,c_yst,c_yst0,rit,ric,c_y,val,c_n,c_c
695d686
<       real       rit,ric
698d688
<       save   /bb/
834a825
> c
836d826
<       use mod_cb_arrays  ! HYCOM saved arrays
841c831,833
<       real fct_sal,c_n,c_c,c_y,sm,sh,sc
---
>       real fct_sal,c_n,c_c,c_y,sm,sh,sc,bb,rit,ric
> c
>       include 'common_blocks.h'
843d834
<       real       rit,ric
845d835
<       save   /bb/
858a849
> c
860d850
<       use mod_cb_arrays  ! HYCOM saved arrays
864a855,856
>       include 'common_blocks.h'
> c
1083a1076
> c
1085d1077
<       use mod_cb_arrays  ! HYCOM saved arrays
1089a1082,1083
>       include 'common_blocks.h'
> c
1091c1085
<       real tol,a,b,d
---
>       real tol,a,b,d,bb,rit,ric
1094d1087
<       real       rit,ric
1096d1088
<       save   /bb/
1150a1143
> c
1152d1144
<       use mod_cb_arrays  ! HYCOM saved arrays
1155a1148,1149
> c
>       include 'common_blocks.h'
end
diff -ibw hycom/inikpp.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/inikpp.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
14d2
<       use mod_cb_arrays  ! HYCOM saved arrays
17a6,7
> c
>       include 'common_blocks.h'
end
diff -ibw hycom/inimy.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/inimy.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
14d2
<       use mod_cb_arrays  ! HYCOM saved arrays
17a6,7
> c
>       include 'common_blocks.h'
end
diff -ibw hycom/isnan.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/isnan.F
1,29d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(NAN2003)
<       logical function hycom_isnaninf(a)
<       use ieee_arithmetic, only : ieee_is_finite
<       implicit none
< c
<       real a
< c
< c**********
< c*
< c 1)  return .true. if a is NaN or +Inf or -Inf.
< c
< c 2)  version with ieee_arithmetic intrinsic module
< c*
< c**********
< c
<       hycom_isnaninf = .not. ieee_is_finite(a)
<       end function hycom_isnaninf
< #else
43,47d13
< #endif
< c
< c> Revision history:
< c>
< c> Jan. 2014 - ieee_arithmetic intrinsic module version via /* NAN2003 */ macro
end
diff -ibw hycom/latbdy.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/latbdy.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/latbdy.F: No such file or directory
end
diff -ibw hycom/machine.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/machine.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
diff -ibw hycom/matinv.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/matinv.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
19d7
<       use mod_cb_arrays  ! HYCOM saved arrays
21a10,11
>       include 'common_blocks.h'
> c
60d49
<       use mod_cb_arrays  ! HYCOM saved arrays
62a52,53
>       include 'common_blocks.h'
> c
110,111d100
<       use mod_cb_arrays  ! HYCOM saved arrays
<       implicit none
118a108,109
> c
>       include 'common_blocks.h'
end
diff -ibw hycom/mod_archiv.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_archiv.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
14d2
<       use mod_cb_arrays  ! HYCOM saved arrays
30,31d17
<       logical,       save, private ::
<      &   fpnts         ! initialize profile location files
42a29,30
>       include 'common_blocks.h'
> c
101,103c89,90
< #if defined(STOKES)
<       use mod_stokes  ! Stokes Drift Velocity Module
< #endif
---
> c
>       include 'common_blocks.h'
113c100
<       integer      i,j,k,ktr,ldot,nop,nopa
---
>       integer      i,j,k,ktr,l,ldot,nop,nopa
407,422d393
< #if defined(STOKES)
<         if     (stdarc) then
<           call zaiowr(usdp(1-nbdy,1-nbdy,k),ip,.true.,
<      &                xmin,xmax, nopa, .false.)
<           if     (mnproc.eq.1) then
<           write (nop,117) 'tracer  ',nstep,time,k,coord,xmin,xmax
<           call flush(nop)
<           endif !1st tile
<           call zaiowr(vsdp(1-nbdy,1-nbdy,k),ip,.true.,
<      &                xmin,xmax, nopa, .false.)
<           if     (mnproc.eq.1) then
<           write (nop,117) 'tracer  ',nstep,time,k,coord,xmin,xmax
<           call flush(nop)
<           endif !1st tile
<         endif !stdarc
< #endif
490c461
< ccc!$OMP PARALLEL DO PRIVATE(j,i)
---
> ccc!$OMP PARALLEL DO PRIVATE(j,l,i)
493,494c464,465
< ccc        do i=1-margin,ii+margin
< ccc          if (iu(i,j).ne.0) then
---
> ccc        do l=1,isu(j)
> ccc          do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
496,497c467,470
< ccc          endif !iu
< ccc          if (iv(i,j).ne.0) then
---
> ccc          enddo
> ccc        enddo
> ccc        do l=1,isv(j)
> ccc          do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
499,501c472,474
< ccc          endif !iv
< ccc        enddo !i
< ccc      enddo !j
---
> ccc          enddo
> ccc        enddo
> ccc      enddo
515a489,490
>       include 'common_blocks.h'
> c
522d496
< c --- not all compilers detect directories, so look for a dummy file.
524c498
<       inquire(file='ARCHP/archv.dummy.txt',exist=lexist)
---
>       inquire(file='ARCHP',exist=lexist)
527c501
<         write (lp,*) 'file ARCHP/archv.dummy.txt must exist'
---
>         write (lp,*) 'directory ARCHP must exist'
561,562d534
< c
<       fpnts = .true.  !initialize profile location files
567a540,541
>       include 'common_blocks.h'
> c
574,576c548,549
<       character*81, save :: flnmarcp  !1 extra character for trailing "_"
<       integer,      save :: ldot
<       integer ::            ipnt,jpnt,kpnt,nop
---
>       character*81 flnmarcp  !1 extra character for trailing "_"
>       integer      ipnt,jpnt,kpnt,ldot,nop
582d554
<       if     (fpnts) then  ! initialize profile location files
605d576
<       endif !fpnts
614d584
<           if     (fpnts) then  ! initialize profile location files
616d585
<      &       action='write',form='formatted',
618,622d586
<           else  !write at the end of existing profile files
<             open (unit=nop,status='old',position='append',
<      &       action='write',form='formatted',
<      &       file='ARCHP/'//flnmarcp(1:ldot)//trim(cpnts(kpnt))//'.txt')
<           endif !fpnts
629,630d592
<       fpnts = .false.  ! use existing profile location files
< c
639a602,603
>       include 'common_blocks.h'
> c
677,678c641
<         if     (sstflg.le.1) then
<           if     (relaxf) then
---
>         if     (relaxf .and. sstflg.le.1) then
683,685d645
<           else
<             sstc = 99.9999
<           endif !relaxf
687,690d646
<           if     (natm.eq.2) then
<             sstc = seatmp(ipnt,jpnt,l0)*w0+
<      &             seatmp(ipnt,jpnt,l1)*w1
<           else
695,697c651
<           endif !natm
<         endif !sstflg
<         if     (relaxf) then
---
>         endif
702,704d655
<         else
<           sssc = 99.9999
<         endif !relaxf
858,859c809,810
<           ustk = 0.5*(usd(ipnt,jpnt,k)+usd(ipnt1,jpnt, k))
<           vstk = 0.5*(vsd(ipnt,jpnt,k)+vsd(ipnt, jpnt1,k))
---
>           ustk = 0.5*(usd(ipnt,jpnt,k)+usd(ipnt1,jpnt, k)) + ubstk
>           vstk = 0.5*(vsd(ipnt,jpnt,k)+vsd(ipnt, jpnt1,k)) + vbstk
891,893c842,843
< #if defined(STOKES)
<       use mod_stokes  ! Stokes Drift Velocity Module
< #endif
---
> c
>       include 'common_blocks.h'
909d858
< c --- not all compilers detect directories, so look for a dummy file.
912c861
<       inquire(file=cdir//'archt.dummy.txt',exist=lexist)
---
>       inquire(file=cdir(1:11),exist=lexist)
1045,1060d993
< #if defined(STOKES)
<       if     (stdarc) then
<         call zaiowr(usdp(1-nbdy,1-nbdy,k),ip,.true.,
<      &              xmin,xmax, nopa, .false.)
<         if     (mnproc.eq.1) then
<         write (nop,117) 'tracer  ',nstep,time,k,coord,xmin,xmax
<         call flush(nop)
<         endif !1st tile
<         call zaiowr(vsdp(1-nbdy,1-nbdy,k),ip,.true.,
<      &              xmin,xmax, nopa, .false.)
<         if     (mnproc.eq.1) then
<         write (nop,117) 'tracer  ',nstep,time,k,coord,xmin,xmax
<         call flush(nop)
<         endif !1st tile
<       endif !stdarc
< #endif
1074c1007
<       endif !difout
---
>       endif
1106,1109d1038
< c> Aug. 2015 - optionally added Stokes Drift to archive files (as tracers)
< c> Aug. 2015 - defined sstc and sssc when .not.relaxf
< c> Sep. 2015 - replace directory checks with dummy file existance checks
< c> Feb. 2016 - hycom_prof writes one (multiple snapshot) file per location
end
diff -ibw hycom/mod_cb_arrays.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_cb_arrays.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_cb_arrays.F: No such file or directory
end
diff -ibw hycom/mod_dimensions.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_dimensions.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
13,16d1
<       implicit none
<       public ! everything is public
< #if defined(RELO)
<       include 'dimensions_relo.h'
18,19c3
< c --- halo size
<       integer, parameter :: nbdy=6
---
> c     module needed for CCSM3 integration
21,71d4
< c --- ms-1  = max. number of interruptions of any tile row or column by land
<       integer, parameter :: ms=99  ! should be enough for any region
< c
< c --- ijqr  = maximum total number of active tiles (= ipr*jpr)
<       integer, parameter :: ijqr=iqr*jqr
< c
< c --- itdm  = total grid dimension in i direction
< c --- jtdm  = total grid dimension in j direction
< c --- kdm   =       grid dimension in k direction
< c --- kk    =       grid dimension in k direction
<       integer, save :: itdm,jtdm,kdm,kk
< c
< c --- idm   = maximum single tile grid dimension in i direction
< c --- jdm   = maximum single tile grid dimension in j direction
<       integer, save :: idm,jdm
< c
< c --- kkwall= grid dimension in k direction for wall relax arrays
< c --- kknest= grid dimension in k direction for nest relax arrays
<       integer, save :: kkwall,kknest
< c
< c --- kkmy25= grid dimension in k direction for M-Y 2.5 arrays
<       integer, save :: kkmy25
< c
< c --- natm  = number of saved atmospheric fields
<       integer, save :: natm
< c
< c --- OpenMP will allocate jblk rows to each thread in turn
<       integer, save :: jblk
< c
< c --- for CCSM array dimensions
<       integer, save :: imt1,imt2,jmt1,jmt2
< c
< c --- actual extent of this tile is (i0+1:i0+ii,j0+1:j0+jj,1:kk)
<       integer, save :: i0,j0,ii,jj
< c
< c --- information (gindex) that keeps do loops from running into land
<       integer, save, allocatable, dimension (:,:) ::
<      &         ip,iu,iv,iq, iuopn,ivopn, ipa, ishlf,
<      &         ipim1, ipip1, ipjm1, ipjp1,
<      &         ipim1x,ipip1x,ipjm1x,ipjp1x
<       integer, save, allocatable, dimension (:,:) ::
<      &         ifp,ilp,ifq,ilq,ifu,ilu,ifv,ilv
<       integer, save, allocatable, dimension (:,:) ::
<      &         jfp,jlp,jfq,jlq,jfu,jlu,jfv,jlv
<       integer, save, allocatable, dimension (:) ::
<      &         isp,isq,isu,isv
<       integer, save, allocatable, dimension (:) ::
<      &         jsp,jsq,jsu,jsv
<       logical, save, allocatable, dimension (:) ::
<      &         allip,alliq,alliu,alliv
< #else
73,276d5
< c
< c --- halo size
<       integer, parameter :: nbdy=6
< c
< c --- OpenMP will allocate jblk rows to each thread in turn
<       integer, parameter :: jblk=(jdm+2*nbdy+mxthrd-1)/mxthrd
< c
< c --- ms-1  = max. number of interruptions of any tile row or column by land
<       integer, parameter :: ms=99  ! should be enough for any region
< c
< c --- ijqr  = maximum total number of active tiles (= ipr*jpr)
<       integer, parameter :: ijqr=iqr*jqr
< c
< c --- for CCSM array dimensions
<       integer, parameter :: imt1=1-nbdy,imt2=idm+nbdy,
<      &                      jmt1=1-nbdy,jmt2=jdm+nbdy
< c
< c --- actual extent of this tile is (i0+1:i0+ii,j0+1:j0+jj,1:kk)
<       integer, parameter :: kk=kdm
<       integer, save      :: i0,j0,ii,jj
< c
< c --- information to keep do loops from running into land
<       integer, save, dimension (1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) ::
<      &         ip,iu,iv,iq, iuopn,ivopn, ipa, ishlf,
<      &         ipim1, ipip1, ipjm1, ipjp1,
<      &         ipim1x,ipip1x,ipjm1x,ipjp1x
<       integer, save, dimension (1-nbdy:jdm+nbdy,ms) :: 
<      &         ifp,ilp,ifq,ilq,ifu,ilu,ifv,ilv
<       integer, save, dimension (1-nbdy:idm+nbdy,ms) :: 
<      &         jfp,jlp,jfq,jlq,jfu,jlu,jfv,jlv
<       integer, save, dimension (1-nbdy:jdm+nbdy) :: 
<      &         isp,isq,isu,isv
<       integer, save, dimension (1-nbdy:idm+nbdy) :: 
<      &         jsp,jsq,jsu,jsv
<       logical, save, dimension (1-nbdy:jdm+nbdy) ::
<      &         allip,alliq,alliu,alliv
< #endif
< c
< c --- line printer unit (stdout)
<       integer, save :: lp
< c
<       real, save :: r_init  !value that allocated arrays should be set to
<                             !initialize with set_r_init (to NaN or huge)
< c
<       integer*8, save, private ::
<      &  mem_alloc_now  = 0   !memory in words explicitly allocated by HYCOM
<      &, mem_alloc_high = 0   !high water mark of memory  allocated by HYCOM
< 
<       contains
< 
< #if defined(RELO)
<       subroutine gindex_allocate
<       implicit none
< c
< c --- allocate information (gindex) that keeps do loops from running into land
< c
<       jblk = (jdm+2*nbdy+mxthrd-1)/mxthrd
< c
<       imt1 =   1-nbdy
<       imt2 = idm+nbdy
<       jmt1 =   1-nbdy
<       jmt2 = jdm+nbdy
< c
<       allocate(
<      &           ip(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           iu(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           iv(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           iq(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        iuopn(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        ivopn(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        ishlf(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          ipa(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &       ipim1x(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &       ipip1x(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &       ipjm1x(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &       ipjp1x(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        ipim1(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        ipip1(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        ipjm1(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        ipjp1(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) )
<       call mem_stat_add( 8*(idm+2*nbdy)*(jdm+2*nbdy) )  !real=2*int
< c
<       allocate(
<      &              ifp(1-nbdy:jdm+nbdy,ms),
<      &              ilp(1-nbdy:jdm+nbdy,ms),
<      &              ifq(1-nbdy:jdm+nbdy,ms),
<      &              ilq(1-nbdy:jdm+nbdy,ms),
<      &              ifu(1-nbdy:jdm+nbdy,ms),
<      &              ilu(1-nbdy:jdm+nbdy,ms),
<      &              ifv(1-nbdy:jdm+nbdy,ms),
<      &              ilv(1-nbdy:jdm+nbdy,ms) )
<       call mem_stat_add( 4*(jdm+2*nbdy)*ms )  !real=2*int
< c
<       allocate(
<      &              jfp(1-nbdy:idm+nbdy,ms),
<      &              jlp(1-nbdy:idm+nbdy,ms),
<      &              jfq(1-nbdy:idm+nbdy,ms),
<      &              jlq(1-nbdy:idm+nbdy,ms),
<      &              jfu(1-nbdy:idm+nbdy,ms),
<      &              jlu(1-nbdy:idm+nbdy,ms),
<      &              jfv(1-nbdy:idm+nbdy,ms),
<      &              jlv(1-nbdy:idm+nbdy,ms) )
<       call mem_stat_add( 4*(idm+2*nbdy)*ms )  !real=2*int
< c
<       allocate(
<      &             isp(1-nbdy:jdm+nbdy),
<      &             isq(1-nbdy:jdm+nbdy),
<      &             isu(1-nbdy:jdm+nbdy),
<      &             isv(1-nbdy:jdm+nbdy) )
<       call mem_stat_add( 2*(jdm+2*nbdy) )  !real=2*int
< c
<       allocate(
<      &             jsp(1-nbdy:idm+nbdy),
<      &             jsq(1-nbdy:idm+nbdy),
<      &             jsu(1-nbdy:idm+nbdy),
<      &             jsv(1-nbdy:idm+nbdy) )
<       call mem_stat_add( 2*(idm+2*nbdy) )  !real=2*int
< c
<       allocate(
<      &           allip(1-nbdy:jdm+nbdy),
<      &           alliq(1-nbdy:jdm+nbdy),
<      &           alliu(1-nbdy:jdm+nbdy),
<      &           alliv(1-nbdy:jdm+nbdy) )
<       call mem_stat_add( 2*(jdm+2*nbdy) )  !real=2*logical
< c
<       end subroutine gindex_allocate
< #endif /* RELO */
< 
<       subroutine mem_stat_add(mem_words)
<       implicit none
< c
<       integer mem_words
< c
< c --- add mem_words to mem_alloc_ statistics
< c ---   note that mem_words can be negative
< c --- call after every allocate and deallocate statement
< c
<       mem_alloc_now  = mem_alloc_now + mem_words
<       mem_alloc_high = max( mem_alloc_high, mem_alloc_now )
< c
<       end subroutine mem_stat_add
< 
<       subroutine mem_stat_print(ctitle)
<       implicit none
< c
<       character*(*) ctitle
< c
< c --- print memory statistics
< c --- only call mem_stat_print on the processors that you want to print
< c
<       real*8    a3_1,a3_now,a3_high,gb_now,gb_high
<       integer*8 mem_3d,mem_3df
< c
<       gb_now  = mem_alloc_now  / (1024.d0**3/8.d0)
<       gb_high = mem_alloc_high / (1024.d0**3/8.d0)
< c
<       a3_1    = (idm+2*nbdy)*(jdm+2*nbdy)*kdm
< c
<       mem_3d  = mem_alloc_now /((idm+2*nbdy)*(jdm+2*nbdy)*kdm)
<       mem_3df = mem_alloc_now  -
<      &                  mem_3d*((idm+2*nbdy)*(jdm+2*nbdy)*kdm)
<       a3_now  = mem_3d + mem_3df/a3_1
< c
<       mem_3d  = mem_alloc_high/((idm+2*nbdy)*(jdm+2*nbdy)*kdm)
<       mem_3df = mem_alloc_high -
<      &                  mem_3d*((idm+2*nbdy)*(jdm+2*nbdy)*kdm)
<       a3_high = mem_3d + mem_3df/a3_1
< c
<       write(lp,'(/a,a,2i16/a,a,4x,2f16.3/a,a,4x,2f16.3/)')
<      &  trim(ctitle),' memory (words) now,high =',
<      &  mem_alloc_now,mem_alloc_high,
<      &  trim(ctitle),' memory (GB)    now,high =',
<      &  gb_now,gb_high,
<      &  trim(ctitle),' eq. 3-D arrays now,high =',
<      &  a3_now,a3_high
< c
<       end subroutine mem_stat_print
< 
< #if defined(NAN2003)
<       subroutine set_r_init
<       use ieee_arithmetic, only : ieee_value,
<      &                            ieee_quiet_nan
<       implicit none
< c
< c --- inititialize r_init
< c --- the value that allocated arrays should be set to
< c --- version with ieee_arithmetic intrinsic module
< c
<       r_init = ieee_value(r_init, ieee_quiet_nan)
< c
<       end subroutine set_r_init
< #else
<       subroutine set_r_init
<       implicit none
< c
< c --- inititialize r_init
< c --- the value that allocated arrays should be set to
< c --- version without ieee_arithmetic intrinsic module
< c
<       r_init = huge(r_init)
< c
<       end subroutine set_r_init
< #endif
< 
278,288d6
< c
< c> Revision history:
< c>
< c> Jan. 2014 - inline some of dimensions.h
< c> Jan. 2014 - add r_init and set_r_init; r_init is NaN via /* NAN2003 */ macro
< c> Jan. 2014 - dimensions_relo.h for relocatable (region independent) case
< c> Feb. 2014 - removed margin, no longer a global variable
< c> Apr. 2014 - added ishlf
< c> May  2014 - added ipim1,ipip1,ipjm1,ipjp1,ipim1x,ipip1x,ipjm1x,ipjp1x
< c> May  2014 - added allip,alliq,alliu,alliv
< c> Feb. 2015 - added gb_now,gb_high
end
diff -ibw hycom/mod_floats.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_floats.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
76d51
<       use mod_cb_arrays  ! HYCOM saved arrays
80a56,57
>       include 'common_blocks.h'
> c
84c61
<       integer i,j,k,l,margin
---
>       integer i,j,k,l
299,301d275
<       call mem_stat_add( 11*(idm+2*nbdy)*(jdm+2*nbdy)*kdm )
<       call mem_stat_add(  9*(idm+2*nbdy)*(jdm+2*nbdy) )
< c
333,334c307,309
<         do i=1-margin,ii+margin
<           if (SEA_U) then
---
> c
>         do l=1,isu(j)
>           do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
335a311,314
> #if defined(STOKES)                
>       uold2(i,j,k   )=u(i,j,k,n)+usd(i,j,k)+ubavg(i,j,n)
>       uold2(i,j,k+kk)=u(i,j,k,n)+usd(i,j,k)+ubavg(i,j,n)
> #else                
338,340d316
< #if defined(STOKES)                
<               uold2(i,j,k   )=uold2(i,j,k   )+usd(i,j,k)
<               uold2(i,j,k+kk)=uold2(i,j,k+kk)+usd(i,j,k)
342c318
<             enddo !k
---
>             enddo
350,351c326,330
<           endif !iu
<           if (SEA_V) then
---
>           enddo
>         enddo
> c
>         do l=1,isv(j)
>           do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
352a332,335
> #if defined(STOKES)                
>       vold2(i,j,k   )=v(i,j,k,n)+vsd(i,j,k)+vbavg(i,j,n)+vsdbavg(i,j)
>       vold2(i,j,k+kk)=v(i,j,k,n)+vsd(i,j,k)+vbavg(i,j,n)+vsdbavg(i,j)
> #else                 
355,357d337
< #if defined(STOKES)                
<               vold2(i,j,k   )=vold2(i,j,k   )+vsd(i,j,k)
<               vold2(i,j,k+kk)=vold2(i,j,k+kk)+vsd(i,j,k)
359c339
<             enddo !k
---
>             enddo
367,368c347,351
<           endif !iv
<           if (SEA_P) then
---
>           enddo
>         enddo
> c
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
375c358
<             enddo !k
---
>             enddo
377,378c360,362
<           endif !ip
<         enddo !i
---
>           enddo
>         enddo
> c
447d430
<       use mod_cb_arrays  ! HYCOM saved arrays
452a436,437
>       include 'common_blocks.h'
> c
457c442
<       integer i,j,k,l,margin
---
>       integer i,j,k,l
603,604c588,589
<         do i=1-margin,ii+margin
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
608,611c593,596
<             enddo !k
<           endif !ip
<         enddo !i
<       enddo !j
---
>             enddo
>           enddo
>         enddo
>       enddo
622,623c607,609
<           do i=1-margin,ii+margin
<             if (SEA_U) then
---
> c
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
633,634c619,623
<             endif !iu
<             if (SEA_V) then
---
>             enddo
>           enddo
> c
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
644,645c633,635
<             endif !iv
<           enddo !i
---
>             enddo
>           enddo
> c
653,654c643,644
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
697,698c687,688
<             endif !ip
<           enddo !i
---
>             enddo
>           enddo
826,827c816,817
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
918d907
<             endif !ip
919a909
>           enddo !l
2186,2187c2176,2178
<           do i=1-margin,ii+margin
<             if (SEA_U) then
---
> c
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
2190,2192c2181,2186
<               enddo !k
<             endif !iu
<             if (SEA_V) then
---
>               enddo
>             enddo
>           enddo
> c
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
2195,2197c2189,2194
<               enddo !k
<             endif !iv
<             if (SEA_P) then
---
>               enddo
>             enddo
>           enddo
> c          
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
2201,2203c2198,2201
<               enddo !k
<             endif !ip
<           enddo !i
---
>               enddo
>             enddo
>           enddo
> c
2790d2787
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
end
diff -ibw hycom/mod_hycom.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_hycom.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
30d5
<       use mod_cb_arrays  ! HYCOM saved arrays
38,39d12
<       use mod_momtum     ! HYCOM momentum
<       use mod_tsadvc     ! HYCOM scalar advection
41c14
<       use mod_stokes     ! HYCOM Stokes drift
---
>       use mod_stokes  ! HYCOM Stokes Drift Velocity Module
60a34,37
> #if ! defined(USE_CCSM3)
>       include 'common_blocks.h'
> #endif
> c
90,92d66
< #if defined(STOKES) 
<      &        dskes,dskesa,
< #endif
97c71
<      &        smr,sms,smt,smx,sum,smin,smax, tsur,
---
>      &        smr,sms,smt,sum,smin,smax, tsur,
183c157
<       real, save, allocatable, dimension (:,:) ::
---
>       real, save, dimension (1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) ::
483c457
<           mask_ptr(i+i0,j+j0) = ishlf(i,j)
---
>           mask_ptr(i+i0,j+j0) = ip(i,j)
523,535d496
<       allocate(  sic_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          sitx_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          sity_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          siqs_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          sifh_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          sifs_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &          sifw_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           sit_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           sih_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           siu_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &           siv_import(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) )
<       call mem_stat_add( 11*(idm+2*nbdy)*(jdm+2*nbdy) )
< c
575a537,538
>       margin = 0
> c
579,581d541
<         allocate( ocn_mask(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy) )
<         call mem_stat_add( (idm+2*nbdy)*(jdm+2*nbdy) )
< c
596c556
<             call psmooth(ocn_mask,0,0, ip, util1)  !not efficient, but only done once
---
>             call psmooth(ocn_mask,0)  !not efficient, but only done once
614c574
<           if     (ishlf(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
635a596,599
> #if defined(STOKES)
>       usur1=usur1+dp1*(u(i,j,k,1)+u(i+1,j,k,1)+usd(i,j,k)+usd(i+1,j,k))
>       vsur1=vsur1+dp1*(v(i,j,k,1)+v(i,j+1,k,1)+vsd(i,j,k)+vsd(i,j+1,k))
> #else
638,640d601
< #if defined(STOKES)
<               usur1 = usur1 + dp1*(usd(i,j,k)+usd(i+1,j,k))
<               vsur1 = vsur1 + dp1*(vsd(i,j,k)+vsd(i,j+1,k))
643a605,608
> #if defined(STOKES)
>       usur2=usur2+dp2*(u(i,j,k,1)+u(i+1,j,k,2)+usd(i,j,k)+usd(i+1,j,k))
>       vsur2=vsur2+dp2*(v(i,j,k,1)+v(i,j+1,k,2)+vsd(i,j,k)+vsd(i,j+1,k))
> #else
646,648d610
< #if defined(STOKES)
<               usur2 = usur2 + dp2*(usd(i,j,k)+usd(i+1,j,k))
<               vsur2 = vsur2 + dp2*(vsd(i,j,k)+vsd(i,j+1,k))
654a617,626
> #if defined(STOKES)
>        umxl  = 0.25*( usur1/psur1+ubavg(i,j,1) + usdbavg(i,j) +
>      &                         ubavg(i+1,j,1)  + usdbavg(i+1,j) +
>      &       usur2/psur2 + ubavg(i,  j,2) + usdbavg(i,j) +
>      &                     ubavg(i+1,j,2) + usdbavg(i+1,j) )
>        vmxl  = 0.25*( vsur1/psur1+vbavg(i,j,1) + vsdbavg(i,j) +
>      &                         vbavg(i,j+1,1) +  vsdbavg(i,j+1) +
>      &       vsur2/psur2 + vbavg(i,j,  2) + vsdbavg(i,j) +
>      &                     vbavg(i,j+1,2) + vadbavg(i,j+1) )
> #else
662a635
> #endif
670,673c643
<           else
<             util2(i,j)              = 0.0
<             util3(i,j)              = 0.0
<           endif !ishlf:else
---
>           endif !ip
682,683c652,653
<       call psmooth(util2,0,0, ishlf, util1)
<       call psmooth(util3,0,0, ishlf, util1)
---
>       call psmooth(util2,0)
>       call psmooth(util3,0)
686c656
<           if     (ishlf(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
689c659
<           endif !ishlf
---
>           endif !ip
712a683,684
>       margin = 0
> c
721c693
<           if     (ishlf(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
782c754
<           endif !ishlf
---
>           endif !ip
825,826c797,798
<       call psmooth(si_u,0,0, ishlf, util1)
<       call psmooth(si_v,0,0, ishlf, util1)
---
>       call psmooth(si_u,0)
>       call psmooth(si_v,0)
860c832
<       integer      i,j,k,nop,nopa,rc
---
>       integer      i,j,k,nop,nopa
863,867d834
< c --- Report
<       call ESMF_LogWrite("HYCOM Archive routine called",
<      &     ESMF_LOG_INFO, rc=rc)
<       call ESMF_LogFlush(rc=rc)
< c
877,882d843
< c
< c ---   Report
<         call ESMF_LogWrite("HYCOM Archive routine returned early",
<      &       ESMF_LOG_INFO, rc=rc)
<         call ESMF_LogFlush(rc=rc)
< c
917c878
<             if     (ishlf(i,j).eq.1) then
---
>             if     (ip(i,j).eq.1) then
919c880
<             endif !ishlf
---
>             endif !ip
926c887
<         call zaiowr(util1,ishlf,.true.,
---
>         call zaiowr(util1,ip,.true.,
935c896
<           if     (ishlf(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
939c900
<           endif !ishlf
---
>           endif !ip
946c907
<       call zaiowr(util2,ishlf,.true.,
---
>       call zaiowr(util2,ip,.true.,
966c927
<         call zaiowr(util1,ishlf,.true.,
---
>         call zaiowr(util1,ip,.true.,
990c951
<         call zaiowr(util1,ishlf,.false.,  !mask on ice
---
>         call zaiowr(util1,ip,.false.,  !mask on ice
1013c974
<         call zaiowr(util1,ishlf,.false.,  !mask on ice
---
>         call zaiowr(util1,ip,.false.,  !mask on ice
1034c995
<       call zaiowr(surtx,ishlf,.true.,
---
>       call zaiowr(surtx,ip,.true.,
1041c1002
<       call zaiowr(surty,ishlf,.true.,
---
>       call zaiowr(surty,ip,.true.,
1048c1009
<       call zaiowr(util1,ishlf,.false.,  !mask on ice
---
>       call zaiowr(util1,ip,.false.,  !mask on ice
1068c1029
<           if     (ishlf(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
1071c1032
<           endif !ishlf
---
>           endif !ip
1086,1090d1046
< c ---   Report
<         call ESMF_LogWrite("HYCOM Archive routine returned",
<      &       ESMF_LOG_INFO, rc=rc)
<         call ESMF_LogFlush(rc=rc)
< c
1108c1064
<       integer      i,j,k,nm,margin
---
>       integer      i,j,k,l,nm
1184,1186d1139
<       call xctmrs(78,huge(i),1)  !time all instances
<       call xctmrs(79,huge(i),1)  !time all instances
<       call xctmrs(80,huge(i),1)  !time all instances
1192,1194d1144
< c --- initialize scalars
<       call blkdat  !must call before zaiost
< c
1197,1204d1146
<       if (mnproc.eq.1) then
<         call mem_stat_print('  zaiost  1st:')
<       endif !1st tile
<       call xcsync(flush_lp)
<       if (mnproc.eq.ijpr) then
<         call mem_stat_print('  zaiost last:')
<       endif !last tile
<       call xcsync(flush_lp)
1208,1211c1150
<       call cb_allocate
<       if (mnproc.eq.1) then
<         call mem_stat_print('  cb_allocate:')
<       endif !1st tile
---
>       call blkdat
1222d1160
< *       write(6,'("Case 1 ddsurf =",G25.17)')ddsurf
1226d1163
< *       write(6,'("Case 1 ddsurf =",G25.17)')ddsurf
1228c1165
<         ddsurf = (baclin/86400.0d0)*0.99d0*huge(i)
---
>         ddsurf = (baclin/86400.0d0)*0.99*huge(i)
1236c1173
<         ddiagf = (baclin/86400.0d0)*0.99d0*huge(i)
---
>         ddiagf = (baclin/86400.0d0)*0.99*huge(i)
1244c1181
<         dproff = (baclin/86400.0d0)*0.99d0*huge(i)
---
>         dproff = (baclin/86400.0d0)*0.99*huge(i)
1252c1189
<         dtilef = (baclin/86400.0d0)*0.99d0*huge(i)
---
>         dtilef = (baclin/86400.0d0)*0.99*huge(i)
1265c1202
<         dmeanf = (baclin/86400.0d0)*0.99d0*huge(i)
---
>         dmeanf = (baclin/86400.0d0)*0.99*huge(i)
1460c1397
<       dtime=(nstep1/nts_day)+mod(nstep1,nts_day)*(baclin/86400.0d0)
---
>       dtime=nstep1/(86400.0d0/baclin)
1465c1402
<       dtime=(nstep2/nts_day)+mod(nstep2,nts_day)*(baclin/86400.0d0)
---
>       dtime=nstep2/(86400.0d0/baclin)
1574c1511
<         dtime0=(nstep0/nts_day)+mod(nstep0,nts_day)*(baclin/86400.0d0)
---
>         dtime0=nstep0/(86400.0d0/baclin)
1601c1538
< !$OMP   PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,k,l,i)
1604,1605c1541,1542
<           do i=1,ii
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
1609,1614d1545
<               surflx(i,j) = 0.0
<               mixflx(i,j) = 0.0
<               buoflx(i,j) = 0.0
<               bhtflx(i,j) = 0.0
<               salflx(i,j) = 0.0
<             endif !ip
1616,1618c1547,1553
<           if (isopyc .or. mxlkrt .or. mxl_no) then
<             do i=1,ii
<               if (SEA_U) then
---
>           enddo !l
>           if (isopyc .or. mxlkrt) then
>             do l=1,isu(j)
>               do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
> #if defined(STOKES) 
>                 umix(i,j)=u(i,j,1,n) + usd(i,j,1)
> #else
1620,1621c1555,1562
<               endif !iu
<               if (SEA_V) then
---
> #endif
>               enddo !i
>             enddo !l
>             do l=1,isv(j)
>               do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
> #if defined(STOKES)
>                 vmix(i,j)=v(i,j,1,n) + vsd(i,j,1)
> #else
1623c1564
<               endif !iv
---
> #endif
1624a1566
>             enddo !l
1643,1644d1584
<         surflx(:,:) = 0.0
<         salflx(:,:) = 0.0
1646c1586
<         dtime0=(nstep0/nts_day)+mod(nstep0,nts_day)*(baclin/86400.0d0)
---
>         dtime0=nstep0/(86400.0d0/baclin)
1700,1706d1639
<           surflx(:,:) = 0.0
<           salflx(:,:) = 0.0
<           if     (difout) then
<             vcty(:,:,:) = 0.0
<             dift(:,:,:) = 0.0
<             difs(:,:,:) = 0.0
<           endif
1724d1656
<       nstep = nstep0+1  !for pipe_compare
1727c1659
< !$OMP   PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,k,l,i)
1729a1662
>           do l=1,isp(j)
1731,1732c1664
<             do i=1-margin,ii+margin
<               if (SEA_P) then
---
>               do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1734,1739c1666,1668
<                 dpbbl(i,j)=thkbot*onem
<               endif !ip
<             enddo !i
<           endif !nm
<           do i=1-margin,ii+margin
<             if (SEA_P) then
---
>               enddo
>             endif
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1743,1746c1672,1675
<               enddo !k
<             endif !ip
<           enddo !i
<         enddo !j
---
>               enddo
>             enddo
>           enddo
>         enddo
1751c1680
<      &              p,depthu,depthv, margin,max(0,margin-1))
---
>      &              p,depthu,depthv, max(0,margin-1))
1763c1692
< !$OMP     PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,k,l,i)
1765a1695
>             do l=1,isp(j)
1767,1768c1697
<             do i=1-margin,ii+margin
<               if (SEA_P) then
---
>               do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
1772,1775c1701,1704
<                 enddo !k
<               endif !ip
<             enddo !i
<           enddo !j
---
>                 enddo
>               enddo
>             enddo
>           enddo
1779,1780c1708
<      &                p,depthu,depthv, margin,max(0,margin-1))
<              dpo = dp !for initial pipe_comparall
---
>      &                p,depthu,depthv, max(0,margin-1))
1785d1712
<       nstep = nstep-1  !restore
1796a1724,1747
> c --- mean archive initialization.
> c
>       if     (meanfq.ne.0.0) then
>         call mean_allocate
> #if defined(USE_CCSM3)
>         nstep0=nstep
> #endif
>         m=mod(nstep0  ,2)+1
>         n=mod(nstep0+1,2)+1
>         nstep=nstep0
>         time =dtime0
>         l0=1
>         l1=2
>         l2=3
>         l3=4
>         w0=0.0
>         w1=0.0
>         w2=0.0
>         w3=0.0
>         call mean_zero(DBLE(time))
>         call momtum_hs(n,m)  !calculate srfhgt
>         call mean_add(n, 0.5)
>       endif
> c
1804c1755
<       open (unit=nod,file=trim(flnminp)//'summary_out',status='unknown')
---
>       open (unit=nod,file='summary_out',status='unknown')
1815d1765
<            dpo = dp !for initial pipe_comparall
1953,1959d1902
<         elseif (mslprf) then
<           w0=-99.9
<           w1=-99.0
<           w2=0.0
<           w3=0.0
<           call forfunhz
<           call forfunhp(dtime0)
1965d1907
<           call forfunhz
2072d2013
< c
2081,2085d2021
< c
< c --- Report
<       call ESMF_LogWrite("HYCOM initialize routine returned",
<      &     ESMF_LOG_INFO, rc=rc)
<       call ESMF_LogFlush(rc=rc)
2095,2109d2030
< c --- mean archive initialization.
< c
<       if     (meanfq.ne.0.0) then
<         call mean_allocate
<         if (mnproc.eq.1) then
<           call mem_stat_print('mean_allocate:')
<         endif !1st tile
< c        call mean_zero(DBLE(time))
<         nstep=nstep0
<         time =dtime0
<         call mean_zero(time)
<         call momtum_hs(n,m)  !calculate srfhgt
<         call mean_add(n, 0.5)
<       endif
< c
2134c2055
<       integer      i,j,k,ktr,nm,margin
---
>       integer      i,j,k,ktr,l,nm
2136,2137d2056
< c      real*8       u3max,u3min
< c      integer      iumax3,jumax3,iumin3,jumin3
2238c2157
<       dtime=(nstep/nts_day)+mod(nstep,nts_day)*(baclin/86400.0d0)
---
>       dtime=dtime0+(nstep-nstep0)/(86400.0d0/baclin)
2306,2309d2224
<       elseif (mslprf) then
< c ---   pressure can be the only atmospheric forcing,
< c ---   set weights and fields for high frequency pressure forcing.
<         call forfunhp(dtime)
2310a2226,2232
> #if defined(STOKES)
> c
> c --- set weights and input fields for Stokes Drift
>       if     (nsdzi.gt.0) then
>         call stokes_forfun(dtime,n)
>       endif !nsdzi
> #endif
2418d2339
<           call momtum_hs(n,m)
2435,2436c2356
<          call pipe_comparall(n,m, 'ENTERm, step')
<          call pipe_comparall(m,n, 'ENTERn, step')
---
>          call pipe_comparall(m,n, 'ENTER , step')
2489c2409
<             call pipe_comparall(m,n, 'thermi, step') !thermf_oi
---
>             call pipe_comparall(m,n, 'thermf, step') !thermf_oi
2616a2537,2552
> #if defined(ARCTIC)
> c ---   Arctic (tripole) domain, top row is replicated (ignore it)
>         jja = min( jj, jtdm-1-j0 )
>         if     (jja.ne.jj) then
>           do i=1,ii
>             util1(i,jj)=0.0
>             util2(i,jj)=0.0
>             util3(i,jj)=0.0
>             util4(i,jj)=0.0
>             util5(i,jj)=0.0
>           enddo
>         endif
> #else
>         jja = jj
> #endif
> c
2629c2565
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i)
2631c2567
<         do j=1,jj
---
>         do j=1,jja
2634,2635c2570,2571
<           do i=1,ii
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
2643,2645c2579,2581
<             endif !ip
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
2647,2648c2583,2584
<         smin=minval(sminy(1:jj))
<         smax=maxval(smaxy(1:jj))
---
>         smin=minval(sminy(1:jja))
>         smax=maxval(smaxy(1:jja))
2651,2653c2587,2588
<         call xcsum( dsum, util3,ipa)
<         call xcsum( dsmt, util4,ipa)
< 
---
>         call xcsum( dsum, util3,ip)
>         call xcsum( dsmt, util4,ip)
2656,2660d2590
< c        write(6,'("sum,dsum=",G25.17,G25.17)')sum,dsum
< c        print *,'srfhgt(1,1)=',srfhgt(1,1)
< c        print *,'scp2(1,1)  =',scp2(1,1)
< c       write(6,'(I3,I3,G25.17)')iumax3,jumax3,u3max
< c       write(6,'(I3,I3,G25.17)')iumin3,jumin3,u3min
2667,2670c2597,2600
<         write (lp,'(i9,a,
<      .              '' mean MontgPot (mm):'',f8.2)')
<      .  nstep,c_ydh,
<      .  smt/(area*thref*onemm)
---
> *       write (lp,'(i9,a,
> *    .              '' mean MontgPot (mm):'',f8.2)')
> *    .  nstep,c_ydh,
> *    .  smt/(area*thref*onemm)
2677,2680c2607,2610
<         write(nod,'(i9,a,
<      .              '' mean MontgPot (mm):'',f8.2)')
<      .  nstep,c_ydh,
<      .  smt/(area*thref*onemm)
---
> *       write(nod,'(i9,a,
> *    .              '' mean MontgPot (mm):'',f8.2)')
> *    .  nstep,c_ydh,
> *    .  smt/(area*thref*onemm)
2698c2628
<           call xcsum( dsms, util2,ipa)
---
>           call xcsum( dsms, util2,ip)
2706,2708d2635
< #if defined(STOKES) 
<           dskesa=0.0d0
< #endif
2711c2638
< !$OMP       PARALLEL DO PRIVATE(j,i,utotp,vtotp)
---
> !$OMP       PARALLEL DO PRIVATE(j,l,i,utotp,vtotp)
2713,2715c2640,2652
<             do j=1,jj
<               do i=1,ii
<                 if (SEA_P) then
---
>             do j=1,jja
>               do l=1,isp(j)
>                 do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
> #if defined(STOKES)
>                   utotp=0.5*( u(i,  j,k,n)+ubavg(i,  j,n) +
>      &                        usd(i,  j,k)+usdbavg(i,  j) +
>      &                        u(i+1,j,k,n)+ubavg(i+1,j,n) +
>      &                        usd(i+1,j,k)+usdbavg(i+1,j))
>                   vtotp=0.5*( v(i,j,  k,n)+vbavg(i,j,  n) +
>      &                        vsd(i,j,  k)+vsdbavg(i,j) +
>      &                        v(i,j+1,k,n)+vbavg(i,j+1,n) +
>      &                        vsd(i,j+1,k)+vsdbavg(i,j+1))
> #else
2719a2657
> #endif
2721,2730c2659
<      &                      0.5*(qthref+th3d(i,j,k,n)+thbase)*
<      &                          (utotp**2+vtotp**2)
< #if defined(STOKES)
<                   utotp=utotp+0.5*( usd(i,  j,k) +
<      &                              usd(i+1,j,k)  )
<                   vtotp=vtotp+0.5*( vsd(i,j,  k) +
<      &                              vsd(i,j+1,k)  )
< c
<                   util6(i,j)=dp(i,j,k,n)*scp2(i,j)*
<      &                      0.5*(qthref+th3d(i,j,k,n)+thbase)*
---
>      &                      0.5*(1000.0+th3d(i,j,k,n)+thbase)*
2732,2735c2661,2663
< #endif
<                 endif !ip
<               enddo !i
<             enddo !j
---
>                 enddo
>               enddo
>             enddo
2737,2741c2665
< #if defined(STOKES)
<             call xcsum(dskes, util6,ipa)
<             dskesa=dskesa+dskes
< #endif
<             call xcsum(dske, util4,ipa)
---
>             call xcsum(dske, util4,ip)
2744,2746d2667
< #if defined(STOKES)
<           smx=(dskesa-dskea)/(area*onem)
< #endif
2749,2754d2669
< #if defined(STOKES)
<           write (lp,'(i9,a,
<      &                  '' region-wide mean SKE:'',f20.10)')
<      &        nstep,c_ydh,
<      &          smx
< #endif
2762c2677
<      &          sms*0.5*g*(qthref+thbase)
---
>      &          sms*0.5*g*(1000.0+thbase)
2778a2694,2709
> #if defined(ARCTIC)
> c ---   Arctic (tripole) domain, top row is replicated (ignore it)
>         jja = min( jj, jtdm-1-j0 )
>         if     (jja.ne.jj) then
>           do i=1,ii
>             util1(i,jj)=0.0
>             util2(i,jj)=0.0
>             util3(i,jj)=0.0
>             util4(i,jj)=0.0
>             util5(i,jj)=0.0
>           enddo
>         endif
> #else
>         jja = jj
> #endif
> c
2788c2719
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
2790,2792c2721,2723
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
2795,2797c2726,2728
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
2799,2800c2730,2731
<           call xcsum(dsum, util1,ipa)
<           call xcsum(dsmt, util2,ipa)
---
>           call xcsum(dsum, util1,ip)
>           call xcsum(dsmt, util2,ip)
2818c2749
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
2820,2822c2751,2753
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
2826,2828c2757,2759
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
2830,2832c2761,2763
<           call xcsum(dsum, util1,ipa)
<           call xcsum(dsmt, util2,ipa)
<           call xcsum(d3,   util3,ipa)
---
>           call xcsum(dsum, util1,ip)
>           call xcsum(dsmt, util2,ip)
>           call xcsum(d3,   util3,ip)
2853c2784
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
2855,2857c2786,2788
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
2860,2862c2791,2793
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
2864,2865c2795,2796
<           call xcsum(dsms, util1,ipa)
<           call xcsum(dsum, util2,ipa)
---
>           call xcsum(dsms, util1,ip)
>           call xcsum(dsum, util2,ip)
2891c2822
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
2893,2895c2824,2826
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
2905,2907c2836,2838
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
2909,2911c2840,2842
<           call xcsum(d2, util2,ipa)
<           call xcsum(d3, util3,ipa)
<           call xcsum(d4, util4,ipa)
---
>           call xcsum(d2, util2,ip)
>           call xcsum(d3, util3,ip)
>           call xcsum(d4, util4,ip)
2943c2874
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
2945,2947c2876,2878
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
2958,2960c2889,2891
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
2962,2964c2893,2895
<           call xcsum(d2, util2,ipa)
<           call xcsum(d3, util3,ipa)
<           call xcsum(d4, util4,ipa)
---
>           call xcsum(d2, util2,ip)
>           call xcsum(d3, util3,ip)
>           call xcsum(d4, util4,ip)
3025c2956
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
3027,3029c2958,2960
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
3036,3038c2967,2969
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
3040,3041c2971,2972
<           call xcsum(dsmt, util1,ipa)
<           call xcsum(dsms, util2,ipa)
---
>           call xcsum(dsmt, util1,ip)
>           call xcsum(dsms, util2,ip)
3062c2993
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i)
3064,3066c2995,2997
<         do j=1,jj
<           do i=1,ii
<             if (SEA_P) then
---
>         do j=1,jja
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
3072,3074c3003,3005
<             endif !ip
<           enddo !i
<         enddo !j
---
>             enddo
>           enddo
>         enddo
3076,3078c3007,3009
<         call xcsum(dsum, util1,ipa)
<         call xcsum(dsmt, util2,ipa)
<         call xcsum(dsms, util3,ipa)
---
>         call xcsum(dsum, util1,ip)
>         call xcsum(dsmt, util2,ip)
>         call xcsum(dsms, util3,ip)
3105,3106c3036,3037
<         call xcsum(dsmt, util4,ipa)
<         call xcsum(dsms, util5,ipa)
---
>         call xcsum(dsmt, util4,ip)
>         call xcsum(dsms, util5,ip)
3125,3135d3055
< c ---   NaN detection.
<         if     (hycom_isnaninf(sms) .or.
<      &          hycom_isnaninf(smt)      ) then
<           if (mnproc.eq.1) then
<           write(lp,*)
<           write(lp,*) 'error - NaN or Inf detected'
<           write(lp,*)
<           call flush(lp)
<           endif !1st tile
<           lfatal = .true.  !delay exit to allow archive output
<         endif !NaN
3141c3061
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
3143,3145c3063,3065
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
3150,3153c3070
<                 elseif (natm.eq.2) then !hf synoptic observed sst
<                   util1(i,j)=scp2(i,j)*
<      &                (seatmp(i,j,l0)*w0+seatmp(i,j,l1)*w1)
<                 else !monthly synoptic observed sst
---
>                 else !synoptic observed sst
3162,3165c3079
<                 elseif (natm.eq.2) then !hf synoptic observed surface temp
<                   util1(i,j)=scp2(i,j)*
<      &                (surtmp(i,j,l0)*w0+surtmp(i,j,l1)*w1)
<                 else !monthly synoptic observed surface temperature
---
>                 else !synoptic observed surface temperature
3170,3172c3084,3086
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
3174,3175c3088,3089
<           call xcsum(dsmt, util1,ipa)
<           call xcsum(dsms, util2,ipa)
---
>           call xcsum(dsmt, util1,ip)
>           call xcsum(dsms, util2,ip)
3223,3225d3136
< #if defined(STOKES)
<         dskesa=0.0d0
< #endif
3227c3138
< !$OMP     PARALLEL DO PRIVATE(j,i,utotp,vtotp)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i,utotp,vtotp)
3229,3231c3140,3152
<           do j=1,jj
<             do i=1,ii
<               if (SEA_P) then
---
>           do j=1,jja
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
> #if defined(STOKES)
>                   utotp=0.5*( u(i,  j,k,n)+ubavg(i,  j,n) +
>      &                        usd(i,  j,k)+usdbavg(i,  j) +
>      &                        u(i+1,j,k,n)+ubavg(i+1,j,n) +
>      &                        usd(i+1,j,k)+usdbavg(i+1,j))
>                   vtotp=0.5*( v(i,j,  k,n)+vbavg(i,j,  n) +
>      &                        vsd(i,j,  k)+vsdbavg(i,j) +
>      &                        v(i,j+1,k,n)+vbavg(i,j+1,n) +
>      &                        vsd(i,j+1,k)+vsdbavg(i,j+1))
> #else
3236,3246d3156
<                 util4(i,j)=dp(i,j,k,n)*scp2(i,j)*
<      &                    0.5*(qthref+th3d(i,j,k,n)+thbase)*
<      &                        (utotp**2+vtotp**2)
< #if defined(STOKES)
<                   utotp=utotp+0.5*( usd(i,  j,k) +
<      &                              usd(i+1,j,k)  )
<                   vtotp=vtotp+0.5*( vsd(i,j,  k) +
<      &                              vsd(i,j+1,k)  )
<                   util6(i,j)=dp(i,j,k,n)*scp2(i,j)*
<      &                      0.5*(qthref+th3d(i,j,k,n)+thbase)*
<      &                          (utotp**2+vtotp**2)
3248d3157
< c
3253,3255c3162,3167
<               endif !ip
<             enddo !i
<           enddo !j
---
>                 util4(i,j)=dp(i,j,k,n)*scp2(i,j)*
>      &                    0.5*(1000.0+th3d(i,j,k,n)+thbase)*
>      &                        (utotp**2+vtotp**2)
>               enddo
>             enddo
>           enddo
3257,3265c3169,3173
< #if defined(STOKES)
<           call xcsum(dskes, util6,ipa)
<           dskesa=dskesa+dskes
< #endif
<           call xcsum(dsum, util1,ipa)
<           call xcsum(dsmt, util2,ipa)
<           call xcsum(dsms, util3,ipa)
<           call xcsum(dsmr, util5,ipa)
<           call xcsum(dske, util4,ipa)
---
>           call xcsum(dsum, util1,ip)
>           call xcsum(dsmt, util2,ip)
>           call xcsum(dsms, util3,ip)
>           call xcsum(dsmr, util5,ip)
>           call xcsum(dske, util4,ip)
3297,3299d3204
< #if defined(STOKES)
<         smx=(dskesa-dskea)/(area*onem)
< #endif
3305,3310d3209
< #if defined(STOKES)
<         write (lp,'(i9,a,
<      &                '' region-wide mean Stokes K.E.:'',f20.10)')
<      &      nstep,c_ydh,
<      &        smx
< #endif
3328,3333d3226
< #if defined(STOKES)
<         write (nod,'(i9,a,
<      &                '' region-wide mean Stokes K.E.:'',f20.10)')
<      &      nstep,c_ydh,
<      &        smx
< #endif
3356c3249
< !$OMP       PARALLEL DO PRIVATE(j,i)
---
> !$OMP       PARALLEL DO PRIVATE(j,l,i)
3358,3360c3251,3253
<             do j=1,jj
<               do i=1,ii
<                 if (SEA_P) then
---
>             do j=1,jja
>               do l=1,isp(j)
>                 do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
3362d3254
<                 endif !ip
3363a3256
>               enddo !l
3366c3259
<             call xcsum(dsmt, util2,ipa)
---
>             call xcsum(dsmt, util2,ip)
3477c3370
< !$OMP   PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,k,l,i)
3481,3501c3374,3375
<             do i=1,ii
<               if (SEA_U) then
<                 umix(i,j)=u(i,j,1,n)
<               endif !iu
<               if (SEA_V) then
<                 vmix(i,j)=v(i,j,1,n)
<               endif !iv
<             enddo !i
<           endif !isopyc .or. mxlkrt
< c
<           if (mxl_no) then
<             do i=1,ii
<               if (SEA_P) then
<                   tmix(i,j) = temp(i,j,1,n)
<                   smix(i,j) = saln(i,j,1,n)
<                  thmix(i,j) = th3d(i,j,1,n)
<                 mixflx(i,j) = 0.0
<                 buoflx(i,j) = 0.0
<                 bhtflx(i,j) = 0.0
<               endif !ip
<               if (SEA_U) then
---
>             do l=1,isu(j)
>               do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
3503,3504c3377,3380
<               endif !iu
<               if (SEA_V) then
---
>               enddo
>             enddo
>             do l=1,isv(j)
>               do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
3506,3509c3382,3384
<               endif !iv
<             enddo !i
<           endif !mxl_no
< c
---
>               enddo
>             enddo
>           endif
3512,3513c3387,3388
<               do i=1,ii
<                 if (SEA_P) then
---
>               do l=1,isp(j)
>                 do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
3522,3523c3397,3398
<                 endif !ip
<               enddo !i
---
>                 enddo
>               enddo
3525c3400
<           endif !histry
---
>           endif
3555c3430
< !$OMP     PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,k,l,i)
3559,3560c3434,3435
<               do i=1,ii
<                 if (SEA_P) then
---
>               do l=1,isp(j)
>                 do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
3562,3565c3437,3440
<                 endif !ip
<               enddo !i
<             enddo !k
<           enddo !j
---
>                 enddo
>               enddo
>             enddo
>           enddo
3590c3465
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
3593,3594c3468,3469
<             do i=1,ii
<               if (SEA_P) then
---
>             do l=1,isp(j)
>               do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
3596,3598c3471,3473
<               endif !ip
<             enddo !i
<           enddo !j
---
>               enddo
>             enddo
>           enddo
3644,3645d3518
<         call dpthuv
< c
3651d3523
<         nstep = nstep+1  !for pipe_compare
3653c3525
< !$OMP     PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,k,l,i)
3655a3528
>             do l=1,isp(j)
3657,3658c3530
<               do i=1-margin,ii+margin
<                 if (SEA_P) then
---
>                 do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
3660,3664c3532,3534
<                 endif !ip
<               enddo !i
<             endif !nm
<             do i=1-margin,ii+margin
<               if (SEA_P) then
---
>                 enddo
>               endif
>               do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
3668,3671c3538,3541
<                 enddo !k
<               endif !ip
<             enddo !i
<           enddo !j
---
>                 enddo
>               enddo
>             enddo
>           enddo
3676c3546
<      &                p,depthu,depthv, margin,max(0,margin-1))
---
>      &                p,depthu,depthv, max(0,margin-1))
3679,3694d3548
<         nstep = nstep-1  !restore
< c
< c ---   update montg to preserve bit for bit reproducability on restart
<         m=mod(nstep  ,2)+1
<         n=mod(nstep+1,2)+1
<         if     (meanfq.ne.0.0) then
< c ---     assume meanfq not changed to zero when rerun from restart
<           call momtum_hs(n,m)
<           surflx(:,:) = 0.0
<           salflx(:,:) = 0.0
<           if     (histmn) then
<             call mean_zero(dtime)
<             call mean_add(n, 0.5)
<           endif  ! histmn
<         endif !meanfq
<         call momtum_hs(n,m)
3701c3555
<         write (lp,'(a,i9,a,f13.5,a)')
---
>         write (lp,'(a,i9,a,f9.2,a)')
3712,3718d3565
< #if defined(STOKES)
< c
< c --- calculate Stokes Drift for the next time step
<       if     (nsdzi.gt.0) then
<         call stokes_forfun(dtime,n)
<       endif !nsdzi
< #endif
3832,3839d3678
< c> Jan. 2014 - added mslprf and forfunhp
< c> Apr. 2014 - added ice shelf logic (ishlf)
< c> Apr. 2014 - replace ip with ipa for mass sums, reduces need for jja
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
< c> Feb. 2015 - removed dtime0 from calculation of dtime
< c> Feb. 2015 - fixed issues with bit for bit reproducability on restart
< c> Sep. 2015 - NaN test on mean surf thk (SST and SSS)
< c> Dec. 2015 - time all instances of HY_Ini, HY_Out, HY_Run
end
diff -ibw hycom/mod_incupd.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_incupd.F
1,13d0
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
22,23c9
<      & incflg,   ! incremental update flag (0=no,-/+1=yes,-/+2=full-velocity)
<                  !   -ve to read in difference archive for increment
---
>      & incflg,   ! incremental update flag (0=no,1=yes,2=full-velocity)
38,40c24
<      &  vbinc,   !  vbaro increment
<      & covinc,   ! covice increment for direct insertion
<      & thkinc    ! thkice increment for direct insertion
---
>      & vbinc     ! vbaro increment
60c44
<       integer i,j,k
---
>       integer i,j,l,k
71,75c55
<      &          vbinc(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &         covinc(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &         thkinc(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)     )
<       call mem_stat_add( 5*(idm+2*nbdy)*(jdm+2*nbdy)*kdm )
<       call mem_stat_add( 4*(idm+2*nbdy)*(jdm+2*nbdy) )
---
>      &          vbinc(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)     )
85,89c65
<       if     (incflg.gt.0) then
<         call incupd_read_full(dtime0)
<       else  !(incflg.le.0)
<         call incupd_read_diff(dtime0)
<       endif
---
>       call incupd_read(dtime0)
101c77
<       integer i,j,k
---
>       integer i,j,l,k
106c82
< c         should never get here, see ncountd=incupf+99 in incupd_read_*
---
> c         should never get here
119,123c95
<       if     (incflg.gt.0) then
<         call incupd_read_full(dtime0)
<       else  !(incflg.le.0)
<         call incupd_read_diff(dtime0)
<       endif
---
>       call incupd_read(dtime0)
129d100
<       use mod_cb_arrays  ! HYCOM saved arrays
131a103,104
>       include 'common_blocks.h'
> C
150,151c123,124
<       integer   i,j,k
<       real      q,utotij,vtotij
---
>       integer   i,j,k,l
>       real      utotij,vtotij
169,175d141
<         if     (ncount.eq.1 .or. ncount.eq.incstp+1) then
<           q = 0.5  !half increment on 1st and incstp+1th step
<         else
<           q = 1.0
<         endif !ncount
<       else
<         q = 1.0
178,179c144,145
<       if     (ncount.gt.incstp+1) then
<         if     (ncount.eq.incstp+2) then
---
>       if     (ncount.gt.incstp) then
>         if     (ncount.eq.incstp+1) then
186c152
<         endif !ncount==incstp+2
---
>         endif !ncount==incstp+1
188c154
<       endif !ncount>incstp+1
---
>       endif !ncount>incstp
192c158
<       if     (abs(incflg).eq.1) then
---
>       if     (incflg.eq.1) then
195c161
<       else   !abs(incflg).eq.2
---
>       else   !incflg.eq.2
199c165
<       write(lp,*) '..........ncount,q= ',ncount,q
---
>       write(lp,*) '..........ncount= ',ncount
205c171,173
< !$OMP PARALLEL DO PRIVATE(j,k,i)
---
>       margin=0
> c
> !$OMP PARALLEL DO PRIVATE(j,k,l,i)
207,209c175,177
<       do j=1,jj
<         do i=1,ii
<           if (SEA_P) then
---
>       do j=1-margin,jj+margin
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
212c180
<               dp(i,j,k,n) = max( dp(i,j,k,n) + q*dpinc(i,j,k), 0.0 )
---
>               dp(i,j,k,n) = max( dp(i,j,k,n) + dpinc(i,j,k), 0.0 )
220d187
<           endif !ip
221a189
>         enddo !l 
227c195
<      &            p,depthu,depthv, 0,0)
---
>      &            p,depthu,depthv, 0)
242c210
< !$OMP PARALLEL DO PRIVATE(j,i,k,utotij,vtotij)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,k,utotij,vtotij)
244,246c212,214
<       do j=1,jj
<         do i=1,ii
<           if (SEA_P) then
---
>       do j=1-margin,jj+margin
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
250,251c218,219
<                 temp(i,j,k,n) = temp(i,j,k,n) + q*tinc(i,j,k)
<                 saln(i,j,k,n) = saln(i,j,k,n) + q*sinc(i,j,k)
---
>                 temp(i,j,k,n) = temp(i,j,k,n) + tinc(i,j,k)
>                 saln(i,j,k,n) = saln(i,j,k,n) + sinc(i,j,k)
255,256c223,226
<           endif !ip
<           if (SEA_U) then
---
>           enddo !i
>         enddo !l
>         do l=1,isu(j)
>           do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
259c229
<               u(i,j,k,n) = u(i,j,k,n) + q*uinc(i,j,k)
---
>               u(i,j,k,n) = u(i,j,k,n) + uinc(i,j,k)
266,268c236,238
<             if     (abs(incflg).eq.2) then !update ubavg
<               ubavg(i,j,n) = ubavg(i,j,n) + q*ubinc(i,j)
< *             ubavg(i,j,n) = ubavg(i,j,n) + q*ubinc(i,j) + utotij
---
>             if     (incflg.eq.2) then !update ubavg
>               ubavg(i,j,n) = ubavg(i,j,n) + ubinc(i,j)
> *             ubavg(i,j,n) = ubavg(i,j,n) + ubinc(i,j) + utotij
270,271c240,243
<           endif !iu
<           if (SEA_V) then
---
>           enddo !i
>         enddo !l
>         do l=1,isv(j)
>           do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
274c246
<               v(i,j,k,n) = v(i,j,k,n) + q*vinc(i,j,k)
---
>               v(i,j,k,n) = v(i,j,k,n) + vinc(i,j,k)
281,283c253,255
<             if     (abs(incflg).eq.2) then !update vbavg
<               vbavg(i,j,n) = vbavg(i,j,n) + q*vbinc(i,j)
< *             vbavg(i,j,n) = vbavg(i,j,n) + q*vbinc(i,j) + vtotij
---
>             if     (incflg.eq.2) then !update vbavg
>               vbavg(i,j,n) = vbavg(i,j,n) + vbinc(i,j)
> *             vbavg(i,j,n) = vbavg(i,j,n) + vbinc(i,j) + vtotij
285d256
<           endif !iv
286a258
>         enddo !l
290,308d261
<       if     (iniflg.lt.0 .and. incice.eq.1 .and. ncount.eq.incstp) then
<         if (mnproc.eq.1) then
<         write(lp,*) '... direct insertion of covice and thkice'
<         write(lp,*)
<         endif !1st tile
<         call xcsync(flush_lp)
< !$OMP   PARALLEL DO PRIVATE(j,k,i)
< !$OMP&           SCHEDULE(STATIC,jblk)
<         do j=1,jj
<           do i=1,ii
<             if (SEA_P) then
<               covice(i,j)=max(0.0,min(1.0,covice(i,j)+covinc(i,j)))
<               thkice(i,j)=max(0.0,        thkice(i,j)+thkinc(i,j) )
<             endif !ip
<           enddo !li
<         enddo !j
< !$OMP   END PARALLEL DO
<       endif !covice and thkice
< c
318,319c271
<       subroutine incupd_read_full(dtime)
<       use mod_cb_arrays  ! HYCOM saved arrays
---
>       subroutine incupd_read(dtime)
324a277,278
>       include 'common_blocks.h'
> c
371c325
<       write(lp,*) 'read (full) incremental updating ...'
---
>       write(lp,*) 'read incremental updating ...'
389,391c343,345
<         read(uoff+925,'(a)') cline  !'iversn'
<         read(uoff+925,'(a)') cline  !'iexpt '
<         read(uoff+925,'(a)') cline  !'yrflag'
---
>         read(uoff+925,'(a)') cline
>         read(uoff+925,'(a)') cline
>         read(uoff+925,'(a)') cline
402c356
<         write(lp,*) 'error in incupd_read_full - input ',cvarin,
---
>         write(lp,*) 'error in incupd_read - input ',cvarin,
406,407c360,361
<         call xcstop('(incupd_read_full)')
<                stop '(incupd_read_full)'
---
>         call xcstop('(incupd_read)')
>                stop '(incupd_read)'
417c371
<         write(lp,*) 'error in incupd_read_full - input ',cvarin,
---
>         write(lp,*) 'error in incupd_read - input ',cvarin,
421,422c375,376
<         call xcstop('(incupd_read_full)')
<                stop '(incupd_read_full)'
---
>         call xcstop('(incupd_read)')
>                stop '(incupd_read)'
428c382
<         write(lp,*) 'error in incupd_read_full - input idm,jdm',
---
>         write(lp,*) 'error in incupd_read - input idm,jdm',
434,435c388,389
<         call xcstop('(incupd_read_full)')
<                stop '(incupd_read_full)'
---
>         call xcstop('(incupd_read)')
>                stop '(incupd_read)'
454c408
<         write(lp,*) 'error in incupd_read_full - input ',dtime0,
---
>         write(lp,*) 'error in incupd_read - input ',dtime0,
458,459c412,413
<         call xcstop('(incupd_read_full)')
<                stop '(incupd_read_full)'
---
>         call xcstop('(incupd_read)')
>                stop '(incupd_read)'
465c419
<         write(lp,*) 'error in incupd_read_full - input ',layer,
---
>         write(lp,*) 'error in incupd_read - input ',layer,
469,470c423,424
<         call xcstop('(incupd_read_full)')
<                stop '(incupd_read_full)'
---
>         call xcstop('(incupd_read)')
>                stop '(incupd_read)'
502,503c456,457
<       call rd_archive(ubinc, cfield,layer, 925)  !u_btrop or covice or mix_dpth or kemix
<       if     (cfield.eq.'mix_dpth' .or. cfield.eq.'kemix') then
---
>       call rd_archive(ubinc, cfield,layer, 925)  !u_btrop or covice or mix_dpth
>       if     (cfield.eq.'mix_dpth') then
520c474
< !$OMP   PARALLEL DO PRIVATE(j,k,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,k,l,i)
522,524c476,478
<         do j=1,jj
<           do i=1,ii
<             if (SEA_P) then
---
>         do j=1-margin,jj+margin
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
527,528c481,482
<             endif !ip
<           enddo !li
---
>             enddo !i
>           enddo !l 
563c517
<      &           'error in incupd_read_full - expected ','u-vel.  '
---
>      &           'error in incupd_read - expected ','u-vel.  '
565,566c519,520
<           call xcstop('(incupd_read_full)')
<                  stop '(incupd_read_full)'
---
>           call xcstop('(incupd_read)')
>                  stop '(incupd_read)'
590c544
<      &           'error in incupd_read_full - expected ','v-vel.  '
---
>      &           'error in incupd_read - expected ','v-vel.  '
592,593c546,547
<           call xcstop('(incupd_read_full)')
<                  stop '(incupd_read_full)'
---
>           call xcstop('(incupd_read)')
>                  stop '(incupd_read)'
602c556
<      &             'error in incupd_read_full - expected ','thknss  '
---
>      &             'error in incupd_read - expected ','thknss  '
604,605c558,559
<           call xcstop('(incupd_read_full)')
<                  stop '(incupd_read_full)'
---
>           call xcstop('(incupd_read)')
>                  stop '(incupd_read)'
614c568
<      &           'error in incupd_read_full - expected ','temp    '
---
>      &           'error in incupd_read - expected ','temp    '
616,617c570,571
<           call xcstop('(incupd_read_full)')
<                  stop '(incupd_read_full)'
---
>           call xcstop('(incupd_read)')
>                  stop '(incupd_read)'
623c577
<      &           'error in incupd_read_full - expected ','salin   '
---
>      &           'error in incupd_read - expected ','salin   '
625,626c579,580
<           call xcstop('(incupd_read_full)')
<                  stop '(incupd_read_full)'
---
>           call xcstop('(incupd_read)')
>                  stop '(incupd_read)'
663,667c617
< c ---   allow for LeapFrog and Asselin filter
<         if     (mod(incstp,2).eq.1) then
<           incstp = incstp-1  !must be even
<         endif
<         tincstp=(2.0/sqrt(1.0-ra2fac))/real(incstp)
---
>         tincstp=2.0/real(incstp)
670,672c620
<         write(lp,'(a,f6.4,a,f12.7,i5)')
<      &    'tincstp=',2.0/sqrt(1.0-ra2fac),'/incstp ',
<      &     tincstp,incstp
---
>         write(lp,*) 'tincstp=2.0/incstp ',tincstp,incstp
675a624
> c
701c650,652
< !$OMP PARALLEL DO PRIVATE(j,k,i)
---
>       margin=0
> c
> !$OMP PARALLEL DO PRIVATE(j,k,l,i)
703,705c654,656
<       do j=1,jj
<           do i=1,ii
<             if (SEA_U) then
---
>       do j=1-margin,jj+margin
>         do l=1,isu(j)
>           do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
715,716c666,669
<           endif !iu
<           if (SEA_V) then
---
>           enddo !i
>         enddo !l 
>         do l=1,isv(j)
>           do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
726,727c679,682
<           endif !iv
<           if (SEA_P) then
---
>           enddo !i
>         enddo !l 
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
738,1130c693
<           endif !ip
<         enddo !li
<       enddo !j
< !$OMP END PARALLEL DO
< c
<       call xctilr(dpinc,1,kk, 1,1, halo_ps)
< c
<       if     (ldebug_incupd_read) then
<          call pipe_compare_sym2(ubinc,iu,'incupd:ubinc',
<      &                          vbinc,iv,'incupd:vbinc')
<          do k= 1,kk
<            write (utxt,'(a9,i3)') '  uinc k=',k
<            write (vtxt,'(a9,i3)') '  vinc k=',k
<            call pipe_compare_sym2(uinc(1-nbdy,1-nbdy,k),iu,utxt,
<      &                            vinc(1-nbdy,1-nbdy,k),iv,vtxt)
<            write (ptxt,'(a9,i3)') ' dpinc k=',k
<            call pipe_compare_sym1(dpinc(1-nbdy,1-nbdy,k),ip,ptxt)
<            write (ptxt,'(a9,i3)') '  tinc k=',k
<            call pipe_compare_sym1( tinc(1-nbdy,1-nbdy,k),ip,ptxt)
<            write (ptxt,'(a9,i3)') '  sinc k=',k
<            call pipe_compare_sym1( sinc(1-nbdy,1-nbdy,k),ip,ptxt)
<          enddo !k
<        endif !ldebug_incupd_read
< *
< *     if     (iutest.gt.0 .and. jutest.gt.0) then
< *       write(lp,*) '*',' iutest= ',iutest+i0,' jutest= ',jutest+j0,' *'
< *       write(lp,*) '*********** dpinc out ************'
< *             write(lp,'(a)')
< *    &                'k,dp1,dp2,dpinc='
< *               sumdpi=0.0
< *               do k= 1,kk
< *                sumdpi=sumdpi+dpinc(iutest,jutest,k)
< *                   write(lp,'(a,i3,3f20.5)')
< *    &                'k= ',
< *    &                 k,dp(iutest,jutest,k,1)*qonem,
< *    &                 dp(iutest,jutest,k,2)*qonem,
< *    &                 dpinc(iutest,jutest,k)*qonem
< *                   call flush(lp)
< *               enddo !k
< *            write(lp,*) 'inc sumdpi= ', sumdpi*qonem
< *            call flush(lp)
< *     endif
< c
<       if (mnproc.eq.1) then
<        write(lp,*) '... finished reading incupd',dtime,dtime0
<       endif !1st tile
<       call xcsync(flush_lp)
< c
<       endif ! dtime
< c
<       return
<       end subroutine incupd_read_full
< 
<       subroutine incupd_read_diff(dtime)
<       use mod_cb_arrays  ! HYCOM saved arrays
<       use mod_za         ! HYCOM I/O interface
<       use mod_pipe       ! HYCOM debugging interface
< c
<       real*8    dtime
< c
< c --- input 3-d HYCOM increment fields (from a difference archive file)
< c --- on model day dtime or dtime + insertion period.
< c --- read in covice and thkice increments, for later direct insertion.
< c
< c --- filenames incup/incupd.iyear_iday_ihour.[ab].
< c --- I/O and array I/O unit 925 used here, but not reserved.
< c
<       logical, parameter :: ldebug_incupd_read=.false. !usually .false.
< c
<       character flnm*24, cline*80, cvarin*6, cfield*8
<       character ptxt*12,utxt*12,vtxt*12
<       integer   i,idmtst,ios,j,jdmtst,k,l,layer,nskip
<       integer   iyear,iday,ihour
<       real      tincstp
< *     real      sumdpi
< c
<       logical   lexist
<       integer   nstep0
<       real*8    dtimei,dtime0
< c
<       include 'stmt_fns.h'
< c
<       dtimei = dtime
< c
<       call forday(dtimei, yrflag, iyear,iday,ihour)
< c
<       write(flnm,'("incup/incupd.",i4.4,"_",i3.3,"_",i2.2)')
<      &                           iyear,iday,ihour
< c
<       inquire(file=flnm//'.a',exist=lexist)
< c
< c --- is input at end of insertion period
< c
<       if     (.not. lexist) then
<         dtimei = dtime + incstp*(baclin/86400.d0)
< c
<         call forday(dtimei, yrflag, iyear,iday,ihour)
< c
<         write(flnm,'("incup/incupd.",i4.4,"_",i3.3,"_",i2.2)')
<      &                             iyear,iday,ihour
<       endif
< c
<       if(dtime.ge.dtimeu) then
< c
<       ncountd=ncountd+1
<       ncount=0
< c
<       if     (ncountd.gt.incupf) then
<         if     (ncountd.eq.incupf+1) then
<           if (mnproc.eq.1) then
<           write(lp,*) '... ended updating fields with increments ...'
<           write(lp,*) 'ncountd= ',ncountd
<           write(lp,*)
<           endif !1st tile
<           call xcsync(flush_lp)
<           ncountd=incupf+99 !turn off "ended" printout
<         endif
<         return
<       endif !ncountd>incupf
< c
<       if (mnproc.eq.1) then
<       write(lp,*) 'read (diff) incremental updating ...'
<       write(lp,*) 'ncountd ...',ncountd
<       write (lp,*) 'incupd_read: ',flnm
<       if     (dtime.eq.dtimei) then
<         write (lp,*) '       time: ',dtime
<       else
<         write (lp,*) '       time: ',dtime
<         write (lp,*) '    time_in: ',dtimei
<       endif
<       write (lp,*) 'iyear,iday,ihour: ',iyear,iday,ihour
<       endif !1st tile
<       call xcsync(flush_lp)
< c
<       call zaiopf(flnm//'.a','old', 925)
<       if     (mnproc.eq.1) then  ! .b file from 1st tile only
<         open (unit=uoff+925,file=flnm//'.b',form='formatted',
<      &        status='old',action='read')
< c
<         read(uoff+925,'(a)') cline
<         read(uoff+925,'(a)') cline
<         read(uoff+925,'(a)') cline
<         read(uoff+925,'(a)') cline
< c
<         read(uoff+925,'(a)') cline  !'iversn'
<         read(uoff+925,'(a)') cline  !'jexpt '
<         read(uoff+925,'(a)') cline  !'iexpt '
<         read(uoff+925,'(a)') cline  !'yrflag'
<       endif !1st tile
< c
<       call zagetc(cline,ios, uoff+925)
<       read(cline,*) idmtst,cvarin
< *     if     (mnproc.eq.1) then
< *     write(lp,*) cvarin,' = ',idmtst
< *     endif !1st tile
<       if (cvarin.ne.'idm   ') then
<         if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,*) 'error in incupd_read_diff - input ',cvarin,
<      &                        ' but should be idm   '
<         write(lp,*)
<         endif !1st tile
<         call xcstop('(incupd_read_diff)')
<                stop '(incupd_read_diff)'
<       endif
<       call zagetc(cline,ios, uoff+925)
<       read(cline,*) jdmtst,cvarin
< *     if     (mnproc.eq.1) then
< *     write(lp,*) cvarin,' = ',jdmtst
< *     endif !1st tile
<       if (cvarin.ne.'jdm   ') then
<         if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,*) 'error in incupd_read_diff - input ',cvarin,
<      &                        ' but should be jdm   '
<         write(lp,*)
<         endif !1st tile
<         call xcstop('(incupd_read_diff)')
<                stop '(incupd_read_diff)'
<       endif
< c
<       if (idmtst.ne.itdm .or. jdmtst.ne.jtdm) then
<         if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,*) 'error in incupd_read_diff - input idm,jdm',
<      &                        ' not consistent with parameters'
<         write(lp,*) 'idm,jdm = ',itdm,  jtdm,  '  (dimensions.h)'
<         write(lp,*) 'idm,jdm = ',idmtst,jdmtst,'  (input)'
<         write(lp,*)
<         endif !1st tile
<         call xcstop('(incupd_read_diff)')
<                stop '(incupd_read_diff)'
<       endif
< c
< c --- check for a difference archive
< c
<       call zagetc(cline,ios, uoff+925)
<       i = index(cline,'diff day')
<       if     (i.eq.0) then
<         if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,*) 'error in incupd_read_diff - ',
<      &                        'not a difference archive'
<         write(lp,*) 'header = '
<         write(lp,*)  trim(cline)
<         write(lp,*)
<         endif !1st tile
<         call xcstop('(incupd_read_diff)')
<                stop '(incupd_read_diff)'
<       endif
< c
< c --- skip (most) surface fields.
< c
<       call zaiosk(925)
<       call zagetc(cline,ios, uoff+925)
<       i = index(cline,'=')
<       read(cline(i+1:),*) nstep0,dtime0,layer
<       if     (mnproc.eq.1) then
<         write(lp,*) 'dtime0= ',dtime0
<       endif
<       if (dtime0.ne.dtimei) then
<         if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,*) 'error in incupd_read_diff - input ',dtime0,
<      &                          ' but dtimei should be ',dtimei
<         write(lp,*)
<         endif !1st tile
<         call xcstop('(incupd_read_diff)')
<                stop '(incupd_read_diff)'
<       endif
< c
< c assumes that there is a new incremental updating file once a day
< c for "incupf" days, see blkdat.input
< c
<       dtimeu=dtime0+1.d0
< c
<       if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,*) 'dtime, dtime0, dtimeu = ',dtime,
<      &               dtime0, dtimeu
<         write(lp,*)
<       endif !1st tile
<       call xcsync(flush_lp)
< c
<       do i= 2,12
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           read (uoff+925,*)
<         endif
<         call zaiosk(925)
<       enddo
< c
<       call rd_archive(ubinc, cfield,layer, 925)  !u_btrop or covice or kemix
<       if     (cfield.eq.'kemix') then
< c ---   archive contains 'steric  '
<         call rd_archive(ubinc, cfield,layer, 925)  !u_btrop or covice
<       endif
<       if     (mnproc.eq.1) then
<       write(lp,'(2a)') "surface: ",cfield
<       endif
<       call xcsync(flush_lp)
<       if     (cfield.eq.'covice  ') then
<         covinc(:,:) = ubinc(:,:)
<         call rd_archive(thkinc, cfield,layer, 925)  !thkice
<         if     (mnproc.eq.1) then
<         write(lp,'(2a)') "surface: ",cfield
<         endif
<         call xcsync(flush_lp)
<         call zaiosk(925)  !temice
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           read (uoff+925,*)
<         endif
<         call rd_archive(ubinc, cfield,layer, 925)
<         if     (mnproc.eq.1) then
<         write(lp,'(2a)') "surface: ",cfield
<         endif
<         call xcsync(flush_lp)
<         incice =  1  !have     input covice, don't direct insert si_c
<       else
<         incice = -1  !have not input covice, might direct insert si_c
<       endif
<       call rd_archive(vbinc, cfield,layer, 925)
<       if     (mnproc.eq.1) then
<       write(lp,'(2a)') "surface: ",cfield
<       endif
<       call xcsync(flush_lp)
< c --- kebtrop
<       if     (mnproc.eq.1) then  ! .b file from 1st tile only
<         read (uoff+925,*)
<       endif
<       call zaiosk(925)
< c
<            if     (mnproc.eq.1) then
<            write (lp,*) 'start 3-D archive file read'
<            endif
<            call xcsync(flush_lp)
< c
< c --- 3-d fields.
< c
<       nskip = 0
<       do k=1,kk
<         call rd_archive(uinc(1-nbdy,1-nbdy,k), cfield,layer, 925)
<         if     (cfield.ne.'u-vel.  ' .and. k.ne.2) then
<           if     (mnproc.eq.1) then
<           write(lp,'(/ a / a,a /)') cfield,
<      &           'error in incupd_read_diff - expected ','u-vel.  '
<           endif !1st tile
<           call xcstop('(incupd_read_diff)')
<                  stop '(incupd_read_diff)'
<         elseif (cfield.ne.'u-vel.  ') then !k==2
< c
< c ---     count "tracer" fields (to be skipped)
< c
<           if     (mnproc.eq.1) then
<           write(lp,'(2a)') "counting tracers: ",cfield
<           endif
<           do nskip= 2,99
<             call rd_archive(uinc(1-nbdy,1-nbdy,k), cfield,layer, 925)
<             if     (mnproc.eq.1) then
<             write(lp,'(2a)') "counting tracers: ",cfield
<             endif
<             if     (cfield.eq.'u-vel.  ') then
<               exit
<             endif
<           enddo !nskip
<           nskip = nskip - 1
<           write(lp,'(a,i3)') "nskip =",nskip
<         endif
<         call rd_archive(vinc(1-nbdy,1-nbdy,k), cfield,layer, 925)
<         if     (cfield.ne.'v-vel.  ') then
<           if     (mnproc.eq.1) then
<           write(lp,'(/ a / a,a /)') cfield,
<      &           'error in incupd_read_diff - expected ','v-vel.  '
<           endif !1st tile
<           call xcstop('(incupd_read_diff)')
<                  stop '(incupd_read_diff)'
<         endif
< c          if     (mnproc.eq.1) then
< c            write (lp,*) 'read v-vel archive file'
< c          endif
< c ---   skip k.e.
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           read (uoff+925,*)
<         endif
<         call zaiosk(925)
< c ---   skip mnthknss
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           read (uoff+925,*)
<         endif
<         call zaiosk(925)
< c
<         call rd_archive(dpinc(1-nbdy,1-nbdy,k), cfield,layer, 925)
<         if     (cfield.ne.'thknss  ') then
<           if     (mnproc.eq.1) then
<           write(lp,'(/ a / a,a /)') cfield,
<      &             'error in incupd_read_diff - expected ','thknss  '
<           endif !1st tile
<           call xcstop('(incupd_read_diff)')
<                  stop '(incupd_read_diff)'
<         endif
< c          if     (mnproc.eq.1) then
< c            write (lp,*) 'read dpinc archive file'
< c          endif
<         call rd_archive(tinc(1-nbdy,1-nbdy,k), cfield,layer, 925)
<         if     (cfield.ne.'temp    ') then
<           if     (mnproc.eq.1) then
<           write(lp,'(/ a / a,a /)') cfield,
<      &           'error in incupd_read_diff - expected ','temp    '
<           endif !1st tile
<           call xcstop('(incupd_read_diff)')
<                  stop '(incupd_read_diff)'
<         endif
<         call rd_archive(sinc(1-nbdy,1-nbdy,k), cfield,layer, 925)
<         if     (cfield.ne.'salin   ') then
<           if     (mnproc.eq.1) then
<           write(lp,'(/ a / a,a /)') cfield,
<      &           'error in incupd_read_diff - expected ','salin   '
<           endif !1st tile
<           call xcstop('(incupd_read_diff)')
<                  stop '(incupd_read_diff)'
<         endif
< c ---   skip density
<         if     (mnproc.eq.1) then  ! .b file from 1st tile only
<           read (uoff+925,*)
<         endif
<         call zaiosk(925)
< c
< c ---   skip (nskip) tracers
< c
<         do l= 1,nskip
<           if     (mnproc.eq.1) then  ! .b file from 1st tile only
<             read (uoff+925,*)
<           endif
<           call zaiosk(925)
---
>           enddo !i
1132,1227d694
<       enddo !k
< c
<       call xctilr(dpinc,1,kk, 1,1, halo_ps)
< c
<       if     (mnproc.eq.1) then  ! .b file from 1st tile only
<       close( unit=uoff+925)
<       endif
<       call zaiocl(925)
< c
< c --- calculate increments
< c --- the "inc" reads, above, are HYCOM diff fields.
< c
<       if(incstp.eq.1) then
<         tincstp=1.0
<         if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,*) 'tincstp=1.0        ',tincstp,incstp
<         endif
<       else
< c ---   allow for LeapFrog and Asselin filter
<         if     (mod(incstp,2).eq.1) then
<           incstp = incstp-1  !must be even
<         endif
<         tincstp=(2.0/sqrt(1.0-ra2fac))/real(incstp)
<         if     (mnproc.eq.1) then
<         write(lp,*)
<         write(lp,'(a,f6.4,a,f12.7,i5)')
<      &    'tincstp=',2.0/sqrt(1.0-ra2fac),'/incstp ',
<      &     tincstp,incstp
<         endif
<       endif !incstp
< c
<       if (mnproc.eq.1) then
<       write(lp,*)
<       write(lp,*) 'calculate t,s,u,v and dp increments'
<       endif !1st tile
<       call xcsync(flush_lp)
< c
< *     if     (iutest.gt.0 .and. jutest.gt.0) then
< *       write(lp,*) '*',' iutest= ',iutest+i0,' jutest= ',jutest+j0,' *'
< *       write(lp,*) '*********** dpinc input ************'
< *               sumdpi=0.0
< *             write(lp,'(a)')
< *    &                'k,dp1,dp2,dpinc='
< *               do k= 1,kk
< *                sumdpi=sumdpi+dpinc(iutest,jutest,k)
< *                   write(lp,'(a,i3,3f20.5)')
< *    &                'k= ',
< *    &                 k,dp(iutest,jutest,k,1)*qonem,
< *    &                 dp(iutest,jutest,k,2)*qonem,
< *    &                 dpinc(iutest,jutest,k)*qonem
< *                   call flush(lp)
< *               enddo !k
< *            write(lp,*) 'sumdpi= ', sumdpi*qonem
< *            call flush(lp)
< *     endif
< c
< c --- use background thickness fields for thinness detection
< c
< !$OMP PARALLEL DO PRIVATE(j,k,i)
< !$OMP&         SCHEDULE(STATIC,jblk)
<       do j=1,jj
<           do i=1,ii
<             if (SEA_U) then
<             ubinc(i,j)=ubinc(i,j)*tincstp
<             do k=1,kk
<               if     (dpu(i,j,k,1).gt.onemm) then
<                 uinc(i,j,k)=uinc(i,j,k)*tincstp
<               else
<                 uinc(i,j,k)=0.0  !thin target layer
<               endif
<             enddo !k
<           endif !iu
<           if (SEA_V) then
<             vbinc(i,j)=vbinc(i,j)*tincstp
<             do k=1,kk
<               if     (dpv(i,j,k,1).gt.onemm) then
<                 vinc(i,j,k)=vinc(i,j,k)*tincstp
<               else  
<                 vinc(i,j,k)=0.0  !thin target layer
<               endif
<             enddo !k
<           endif !iv
<           if (SEA_P) then
<             do k=1,kk
<               if     (dp(i,j,k,1).gt.onemm) then
<                 sinc(i,j,k)=sinc(i,j,k)*tincstp
<                 tinc(i,j,k)=tinc(i,j,k)*tincstp
<               else
<                 tinc(i,j,k)=0.0  !thin target layer
<                 sinc(i,j,k)=0.0  !thin target layer
<               endif
<               dpinc(i,j,k)=dpinc(i,j,k)*tincstp
<             enddo !k
<           endif !ip
<         enddo !li
1277c744
<       end subroutine incupd_read_diff
---
>       end subroutine incupd_read
1280d746
<       use mod_cb_arrays  ! HYCOM saved arrays
1285a752,753
>       include 'common_blocks.h'
> c
1295c763
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,k,l,i)
1298,1299c766,767
<           do i=1,ii
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1-nbdy,ifp(j,l)),min(ii+nbdy,ilp(j,l))
1302d769
<             endif !ip
1303a771
>           enddo !l 
1328,1333d795
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
< c> Nov  2015 - added iniflg<0 for reading a difference archive
< c> Dec  2015 - allow for Asselin filter when calculating tincstp
< c> Dec  2015 - half increment for 1st and incstp+1th time step
< c> Dec  2015 - difference archive can be at end of insertion period
< c> Jul  2017 - bugfix for steric in archive
end
diff -ibw hycom/mod_mean.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_mean.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
27d2
<       use mod_cb_arrays  ! HYCOM saved arrays
29c4
<       use mod_stokes     ! HYCOM Stokes drift
---
>       use mod_stokes
53,55d27
< #if defined(STOKES)
<      &  ,usdp_m,vsdp_m
< #endif
66a39,40
>       include 'common_blocks.h'
> c
71d44
<         call mem_stat_add(       (idm+2*nbdy)*(jdm+2*nbdy)*kdm*ntracr )
81,88d53
<       call mem_stat_add(     7*(idm+2*nbdy)*(jdm+2*nbdy)*kdm )
< #if defined(STOKES)
<       if     (stdarc) then
<         allocate(   usdp_m(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,kdm) )
<         allocate(   vsdp_m(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,kdm) )
<         call mem_stat_add(     2*(idm+2*nbdy)*(jdm+2*nbdy)*kdm )
<       endif !stdarc
< #endif
103d67
<       call mem_stat_add(     13*(idm+2*nbdy)*(jdm+2*nbdy) )
111a76,77
>       include 'common_blocks.h'
> c
114c80
<       integer i,j,k,ktr
---
>       integer i,j,k,ktr,l
120c86
< !$OMP PARALLEL DO PRIVATE(j,i,k,ktr)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,k,ktr)
149,154d114
< #if defined(STOKES)
<             if     (stdarc) then
<               usdp_m(i,j,k) = 0.0
<               vsdp_m(i,j,k) = 0.0
<             endif !stdarc
< #endif
163a124,125
>       include 'common_blocks.h'
> c
170c132
<       integer i,j,k,ktr
---
>       integer i,j,k,ktr,l
184c146
< !$OMP PARALLEL DO PRIVATE(j,i,k,ktr,q,ke)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,k,ktr,q,ke)
186,187c148,155
<         do i=1,ii
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
> #if defined(STOKES)
>        ke = 0.5*((0.5*(ubavg(i,  j,n) + usdbavg(i,j) +
>      &                 ubavg(i+1,j,n) + usdbavg(i+1,j)  ))**2 +
>      &           (0.5*(vbavg(i,j,  n) + vsdbavg(i,j) +
>      &                 vbavg(i,j+1,n) + vsdbavg(i,j+1) ))**2  )
> #else
191a160
> #endif
203,204c172,178
<           endif !ip
<           if (SEA_U) then
---
>           enddo !i
>         enddo !l
>         do l=1,isu(j)
>           do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
> #if defined(STOKES)
>         ubaro_m(i,j)=ubaro_m(i,j)+s*(ubavg(i,j,n)+usdbavg(i,j))
> #else
206,207c180,187
<           endif !iu
<           if (SEA_V) then
---
> #endif
>           enddo !i
>         enddo !l
>         do l=1,isv(j)
>           do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
> #if defined(STOKES)
>         vbaro_m(i,j)=vbaro_m(i,j)+s*(vbavg(i,j,n)+vsdbavg(i,j))
> #else
209c189
<           endif !ip
---
> #endif
210a191
>         enddo !l
212,213c193,204
<           do i=1,ii
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
> #if defined(STOKES)
>         ke = 0.5*((0.5*(u(i,  j,k,n) + usd(i,j,k) +
>      &             ubavg(i,  j,n) + usdbavg(i,j) +
>      &    u(i+1,j,k,n) + usd(i+1,j,k) +
>      &             ubavg(i+1,j,n) + usdbavg(i+1,j) ))**2 +
>      &            (0.5*(v(i,j  ,k,n) + vsd(i,j,k) + 
>      &             vbavg(i,j,  n) + vsdbavg(i,j) +
>      &    v(i,j+1,k,n) + vsd(i,j+1,k) + 
>      &             vbavg(i,j+1,n) + vsdbavg(i,j+1) ))**2  )
> #else
217a209
> #endif
229,236c221,224
< #if defined(STOKES)
<               if     (stdarc) then
<                 usdp_m(i,j,k) = usdp_m(i,j,k) +   usdp(i,j,k) * q
<                 vsdp_m(i,j,k) = vsdp_m(i,j,k) +   vsdp(i,j,k) * q
<               endif !stdarc
< #endif
<             endif !ip
<             if (SEA_U) then
---
>             enddo !i
>           enddo !l
>           do l=1,isu(j)
>             do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
237a226,230
> #if defined(STOKES)
>          u_m(i,j,k) = u_m(i,j,k) + q*(u(i,j,k,n) + usd(i,j,k) + 
>      &               ubavg(i,j,n) + usdbavg(i,j))
> 
> #else
239,240c232,236
<             endif !iu
<             if (SEA_V) then
---
> #endif
>             enddo !i
>           enddo !l
>           do l=1,isv(j)
>             do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
241a238,241
> #if defined(STOKES)
>               v_m(i,j,k) = v_m(i,j,k) + q*(v(i,j,k,n) + vsd(i,j,k) + 
>      &               vbavg(i,j,n) + vsdbavg(i,j))
> #else
243c243
<             endif !iv
---
> #endif
244a245
>           enddo !l
254a256,257
>       include 'common_blocks.h'
> c
257c260
<       integer i,j,k,ktr
---
>       integer i,j,k,ktr,l
274c277
< !$OMP PARALLEL DO PRIVATE(j,i,k,qdp)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,k,qdp)
276,277c279,280
<         do i=1,ii
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
282d284
<           endif !ip
283a286
>         enddo !l
288c291
< !$OMP PARALLEL DO PRIVATE(j,i,k,qdp)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,k,qdp)
290,291c293,294
<         do i=1,ii
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
303,304c306,309
<           endif !ip
<           if (SEA_U) then
---
>           enddo !i
>         enddo !l
>         do l=1,isu(j)
>           do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
306,307c311,314
<           endif !iu
<           if (SEA_V) then
---
>           enddo !i
>         enddo !l
>         do l=1,isv(j)
>           do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
309d315
<           endif !iv
310a317
>         enddo !l
312,313c319,320
<           do i=1,ii
<             if (SEA_P) then
---
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
324,329d330
< #if defined(STOKES)
<                 if     (stdarc) then
<                   usdp_m(i,j,k) = usdp_m(i,j,k) * qdp
<                   vsdp_m(i,j,k) = vsdp_m(i,j,k) * qdp
<                 endif !stdarc
< #endif
338,346c339,343
< #if defined(STOKES)
<                 if     (stdarc) then
<                   usdp_m(i,j,k) = usdp_m(i,j,k-1)
<                   vsdp_m(i,j,k) = vsdp_m(i,j,k-1)
<                 endif !stdarc
< #endif
<               endif !dpthin:else
<             endif !ip
<             if (SEA_U) then
---
>               endif
>             enddo !i
>           enddo !l
>           do l=1,isu(j)
>             do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
355,356c352,355
<             endif !iu
<             if (SEA_V) then
---
>             enddo !i
>           enddo !l
>           do l=1,isv(j)
>             do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
365d363
<             endif !iv
366a365
>           enddo !l
385a385,386
>       include 'common_blocks.h'
> c
389c390
<       integer      i,j,k,ktr,ldot,nop,nopa
---
>       integer      i,j,k,ktr,l,ldot,nop,nopa
392,394d392
< #if defined(STOKES)
<       real         ustk,vstk
< #endif
617,632d614
< #if defined(STOKES)
<       if     (stdarc) then
<         call zaiowr(usdp_m(1-nbdy,1-nbdy,k),ip,.true.,
<      &              xmin,xmax, nopa, .false.)
<         if     (mnproc.eq.1) then
<         write (nop,117) 'tracer  ',nmean,time_ave,k,coord,xmin,xmax
<         call flush(nop)
<         endif !1st tile
<         call zaiowr(vsdp_m(1-nbdy,1-nbdy,k),ip,.true.,
<      &              xmin,xmax, nopa, .false.)
<         if     (mnproc.eq.1) then
<         write (nop,117) 'tracer  ',nmean,time_ave,k,coord,xmin,xmax
<         call flush(nop)
<         endif !1st tile
<       endif !stdarc
< #endif
669,672d650
<           if     (natm.eq.2) then
<             sstc = seatmp(itest,jtest,l0)*w0+
<      &             seatmp(itest,jtest,l1)*w1
<           else
677d654
<           endif !natm
736,755d712
< #if defined(STOKES)
<         if     (ntracr.eq.0) then
<           write(cformat,'(a)')      '(4a)'
<         else
<           write(cformat,'(a,i2,a)') '(4a,', ntracr, 'a)'
<         endif
<         write (nop,cformat)
<      &      '#  k',
<      &      '    utot    vtot  p.temp    saln  p.dens',
<      &      '    thkns      dpth  viscty  t-diff  s-diff',
<      &      '  usdtot  vsdtot',
<      &      ('  tracer',ktr=1,ntracr)
<         if     (ntracr.eq.0) then
<           write(cformat,'(a)')
<      &      '(i4,2f8.2,3f8.4,f9.3,f10.3,3f8.2,2f8.2)'
<         else
<           write(cformat,'(a,i2,a)')
<      &      '(i4,2f8.2,3f8.4,f9.3,f10.3,3f8.2,2f8.2,', ntracr, 'f8.3)'
<         endif
< #else
773d729
< #endif
777,785d732
< #if defined(STOKES)
<           if     (stdarc) then
<             ustk = usdp_m(itest,jtest,k)
<             vstk = vsdp_m(itest,jtest,k)
<           else
<             ustk = 0.0
<             vstk = 0.0
<           endif
< #endif
798,801d744
< #if defined(STOKES)
<      &       max(-999.99,min(999.99,ustk*100.0)),                    !cm/s
<      &       max(-999.99,min(999.99,vstk*100.0)),                    !cm/s
< #endif
818d760
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
end
diff -ibw hycom/mod_momtum.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_momtum.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_momtum.F: No such file or directory
end
diff -ibw hycom/mod_OICPL.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_OICPL.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
diff -ibw hycom/mod_pipe.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_pipe.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
19,20c8
<       integer, save, private :: ipunit,lpunit,ishift,jshift,nsym,
<      &                          nstep_start
---
>       integer, save, private :: ipunit,lpunit,ishift,jshift,nsym
24,27c12
<      &                          ltracer,ltracernan,ltracermax,
<      &                          lpipe_fatal,lpipe_anyfailed,
<      &                          lnan_anyfailed
< 
---
>      &                          ltracer,ltracernan,ltracermax
41,43d25
< c --- call 'pipe_fatal_on'  to exit     on differences (this is the default)
< c --- call 'pipe_fatal_off' to continue on differences
< c
110,121d91
<       subroutine pipe_fatal_on
<       implicit none
<       lpipe_fatal = .true.
<       return
<       end subroutine pipe_fatal_on
< c
<       subroutine pipe_fatal_off
<       implicit none
<       lpipe_fatal = .false.
<       return
<       end subroutine pipe_fatal_off
< c
123d92
<       use mod_cb_arrays  ! HYCOM saved arrays
130c99,100
<       logical       ltstep
---
> c
>       include 'common_blocks.h'  !for flnminp
174c144
<       lpipe   = lmaster .or. lslave .or. lsym .or. lnan .or. ldebug
---
>       lpipe   = lmaster .or. lslave .or. lsym .or. lnan
181,184d150
<       lpipe_fatal     = .true.   !by default, exit on detecting differences
<       lpipe_anyfailed = .false.  !no differences detected yet
<       lnan_anyfailed  = .false.  !no NaN's detected yet
< c
194,204d159
<       if     (lpipeio) then
<         inquire(file=trim(flnminp)//'PIPE_START',   exist=ltstep)
<         if     (ltstep) then
<           open(unit=uoff+99,file=trim(flnminp)//'PIPE_START')  !on all nodes
<           read(uoff+99,*) nstep_start
<           close(unit=uoff+99) !file='PIPE_START'
<         else
<           nstep_start = 0
<         endif
<       endif
< c
211d165
<         call mem_stat_add( 2*itdm*jtdm )
214d167
<           call mem_stat_add( itdm*jtdm )
216d168
<           call mem_stat_add( (idm+2*nbdy)*(jdm+2*nbdy) )
220d171
<           call mem_stat_add( itdm*jtdm )
343d293
<       use mod_cb_arrays  ! HYCOM saved arrays, for nstep
360d309
<       real         fnan  !target for huge
362c311
<       if (lpipeio .and. nstep.ge.nstep_start) then
---
>       if (lpipeio) then
394,402d342
< c-----------------if     (hycom_isnaninf(field2(i,j))) then
<                   if     (.not.
<      &                    (field2(i,j).ge.-huge(fnan) .and.
<      &                     field2(i,j).le. huge(fnan)      )) then
<                     write (lpunit,'(a,2i5,1p,2(a,e12.5),4x,a)')
<      &                'i,j=',i,j,
<      &                '  master:',field2(i,j),
<      &                '  slave:', field1(i,j),what
<                   else
407d346
<                   endif
412,413c351
<             lpipe_anyfailed = lpipe_anyfailed .or. fail
<             if (lpipe_fatal .and. fail) then  ! exit
---
>             if (fail) then  ! optional
425d362
<       use mod_cb_arrays  ! HYCOM saved arrays
442d378
<       real         fnan  !target for huge
444c380
<       if (lpipeio .and. nstep.ge.nstep_start) then
---
>       if (lpipeio) then
495,503d430
< c-----------------if     (hycom_isnaninf(field2(i,j))) then
<                   if     (.not.
<      &                    (field2(i,j).ge.-huge(fnan) .and.
<      &                     field2(i,j).le. huge(fnan)      )) then
<                     write (lpunit,'(a,2i5,1p,2(a,e12.5),4x,a)')
<      &                'i,j=',i,j,
<      &                '  master:',field2(i,j),
<      &                '  slave:', field1(i,j),what
<                   else
508d434
<                   endif
513,514c439
<             lpipe_anyfailed = lpipe_anyfailed .or. fail
<             if (lpipe_fatal .and. fail) then  ! exit
---
>             if (fail) then  ! optional
522,530d446
< *     if     (ldebug .and. ittest.ne.-1 .and. jttest.ne.-1) then
< *       if     (i0.lt.ittest .and. i0+ii.ge.ittest .and.
< *    &          j0.lt.jttest .and. j0+jj.ge.jttest      ) then
< *         write (lp,'(a,2i5,2x,a,a,1pg24.10)')
< *    &      'i,j=',itest+i0,jtest+j0,
< *    &      what,': ',
< *    &      field(itest,jtest)
< *       endif
< *     endif
555c471
<       if     (lpipeio .or. ldebug) then
---
>       if     (lpipeio) then
586d501
<               if (tmask(i,j).gt.0.0) then
612,613c527
<               endif !nsym
<               endif !mask
---
>               endif
617,618c531
<           lpipe_anyfailed = lpipe_anyfailed .or. fail
<           if (lpipe_fatal .and. fail) then  ! exit
---
>           if (fail) then  ! optional
641d553
<                 lnan_anyfailed = .true.  !local fail
671c583
<       if     (lpipeio .or. ldebug) then
---
>       if     (lpipeio) then
771,772c683
<           lpipe_anyfailed = lpipe_anyfailed .or. fail
<           if (lpipe_fatal .and. fail) then  ! exit
---
>           if (fail) then  ! optional
827,828c738
<           lpipe_anyfailed = lpipe_anyfailed .or. fail
<           if (lpipe_fatal .and. fail) then  ! exit
---
>           if (fail) then  ! optional
883,884c793
<         lpipe_anyfailed = lpipe_anyfailed .or. fail
<         if (lpipe_fatal .and. fail) then  ! exit
---
>         if (fail) then  ! optional
930,931c839
<           lpipe_anyfailed = lpipe_anyfailed .or. fail
<           if (lpipe_fatal .and. fail) then  ! exit
---
>           if (fail) then  ! optional
942,945d849
<       use mod_cb_arrays  ! HYCOM saved arrays
< #if defined(STOKES)
<       use mod_stokes     ! HYCOM Stokes drift
< #endif
947a852,853
>       include 'common_blocks.h'
> c
958c864
<       integer      i,imax,imin,j,jmax,jmin,k,ktr,l,mnp
---
>       integer      i,imax,imin,j,jja,jmax,jmin,k,ktr,l,mnp
987c893
<           write (lp,"(i9,i5,i5,1x,a,a,3f15.8)")
---
>           write (lp,"(i8,i5,i5,1x,a,a,3f15.8)")
999,1000c905,906
<           do i=1,ii
<             if (ip(i,j).ne.0) then
---
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
1005c911
<                 write (lp,"(i9,i5,i5,1x,a,a,3f15.8)")
---
>                 write (lp,"(i8,i5,i5,1x,a,a,3f15.8)")
1007,1010c913,916
<               endif !hycom_isnaninf
<             endif !ip
<           enddo !i
<         enddo !j
---
>               endif
>             enddo
>           enddo
>         enddo
1026,1027c932,933
<      &      '(i9,i5,i5,1x,a,a/',
<      &      '(i9,5x,i5,1x,a,a,1p4e12.4))'
---
>      &      '(i8,i5,i5,1x,a,a/',
>      &      '(i8,5x,i5,1x,a,a,1p4e12.4))'
1039,1040c945,946
<      &      '(i9,i5,i5,1x,a,a/',
<      &      '(i9,5x,i5,1x,a,a,2f7.3,2f7.3,f8.4,f9.3,f10.3))'
---
>      &      '(i8,i5,i5,1x,a,a/',
>      &      '(i8,5x,i5,1x,a,a,2f7.3,2f7.3,f8.4,f9.3,f10.3))'
1043,1044c949,950
<      &      '(i9,i5,i5,1x,a,a,',ntracr,'a / ',
<      &      '(i9,5x,i5,1x,a,a,2f7.3,2f7.3,f8.4,f9.3,f10.3,',
---
>      &      '(i8,i5,i5,1x,a,a,',ntracr,'a / ',
>      &      '(i8,5x,i5,1x,a,a,2f7.3,2f7.3,f8.4,f9.3,f10.3,',
1051c957
<      &       ':  ubaro  vbaro ub.i+1 vb.i+1  ub.j+1   vb.j+1      dpth',
---
>      &       ':  ubaro  vbaro  u.i+1  v.i+1   u.j+1    v.j+1      dpth',
1071,1097d976
< #if defined(STOKES)
<           if     (allocated(usdbavg)) then
<           write (lp,cformat) 
<      &       nstep,itest+i0,jtest+j0,cinfo(1:6),
<      &       ':UsdbaroVsdbaro ub.i+1 vb.i+1  ub.j+1   vb.j+1      dpth',
<      &       nstep,0,          cinfo(1:6),'#',
<      &       usdbavg(itest,  jtest),
<      &       vsdbavg(itest,  jtest),
<      &       usdbavg(itest+1,jtest),
<      &       vsdbavg(itest+1,jtest),
<      &       usdbavg(itest,  jtest+1),
<      &       vsdbavg(itest,  jtest+1),
<      &             p(itest,  jtest,kk+1)/onem
<           write (lp,cformat) 
<      &       nstep,itest+i0,jtest+j0,cinfo(1:6),
<      &       ': usdtot vsdtot   temp   saln    dens    thkns      dpth',
<      &      (nstep,k,          cinfo(1:6),'#',
<      &        usd(itest,jtest,k),
<      &        vsd(itest,jtest,k),
<      &       temp(itest,jtest,k,m),
<      &       saln(itest,jtest,k,m),
<      &       th3d(itest,jtest,k,m)+thbase,
<      &         dp(itest,jtest,k,m)/onem,  !RA       time t
<      &        dpo(itest,jtest,k,m)/onem,  !original time t
<      &       k=1,2)
<           endif !allocated
< #endif
1149,1150c1028,1029
<      &      '(i9,i5,i5,1x,a,a/',
<      &      '(i9,5x,i5,1x,a,a,g15.5,g15.5,f9.3,f9.2))'
---
>      &      '(i8,i5,i5,1x,a,a/',
>      &      '(i8,5x,i5,1x,a,a,g15.5,g15.5,f9.3,f9.2))'
1163,1164c1042,1043
<      &      '(i9,i5,i5,1x,a,a/',
<      &      '(i9,5x,i5,1x,a,a,f7.3,f8.2,f7.3,f8.2,f9.3,f9.2))'
---
>      &      '(i8,i5,i5,1x,a,a/',
>      &      '(i8,5x,i5,1x,a,a,f7.3,f8.2,f7.3,f8.2,f9.3,f9.2))'
1185,1186c1064,1065
<  104    format (i9,a3,1x,a,a)
<  105    format (i9,i3,1x,a,a,2i5,f9.5,f7.3,f9.5,2i5,i7)
---
>  104    format (i8,a3,1x,a,a)
>  105    format (i8,i3,1x,a,a,2i5,f9.5,f7.3,f9.5,2i5,i7)
1236a1116,1129
> #if defined(ARCTIC)
> c ---   Arctic (tripole) domain, top row is replicated (ignore it)
>         jja = min( jj, jtdm-1-j0 )
>         if     (jja.ne.jj) then
>           do i=1,ii
>             util5(i,jj)=0.0
>             util6(i,jj)=0.0
>             util3(i,jj)=0.0
>             util4(i,jj)=0.0
>           enddo
>         endif
> #else
>         jja = jj
> #endif
1239,1241c1132,1134
<         do j=1,jj
<           do i=1,ii
<             if (ip(i,j).ne.0) then
---
>         do j=1,jja
>           do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
1255,1258c1148,1151
<               enddo !k
<             endif !ip
<           enddo !i
<         enddo !j
---
>               enddo
>             enddo
>           enddo
>         enddo
1260,1263c1153,1156
<         call xcsum(d1, util5,ipa)
<         call xcsum(d2, util6,ipa)
<         call xcsum(d3, util3,ipa)
<         call xcsum(d4, util4,ipa)
---
>         call xcsum(d1, util5,ip)
>         call xcsum(d2, util6,ip)
>         call xcsum(d3, util3,ip)
>         call xcsum(d4, util4,ip)
1269c1162
<  106    format (i9,3x,1x,a,a,3f8.4,1p3e10.2)
---
>  106    format (i8,3x,1x,a,a,3f8.4,1p3e10.2)
1393,1395d1285
< c ---   exit at the end on differences
< c
<         call pipe_fatal_off
1408c1298
<         call pipe_compare_sym1(montg1(1-nbdy,1-nbdy),ip,txt1)
---
>         call pipe_compare_sym1(montg(1-nbdy,1-nbdy,1,1),ip,txt1)
1434,1435c1324,1325
<           txt1(1:9) = '...u(kn) '
<           txt2(1:9) = '...v(kn) '
---
>           txt1(1:9) = 'u(kn)  k='
>           txt2(1:9) = 'v(kn)  k='
1438,1442c1328
<           txt1(1:9) = '.dpu(kn) '
<           txt2(1:9) = '.dpv(kn) '
<           call pipe_compare_sym2( dpu(1-nbdy,1-nbdy,k,n),iu,txt1,
<      &                            dpv(1-nbdy,1-nbdy,k,n),iv,txt2)
<           txt1(1:9) = '..dp(kn) '
---
>           txt1(1:9) = 'dp(kn) k='
1452,1456d1337
< c
<         if     (lpipe_anyfailed .or. lnan_anyfailed) then  !exit on failure
<           call xchalt('(pipe_compare_all)')
<                  stop '(pipe_compare_all)'
<         else
1460d1340
<         endif
1462,1463d1341
< c
<         call pipe_fatal_on
1483,1487d1360
< c> Feb  2014 - added lpipe_fatal and lpipe_anyfailed
< c> Apr  2014 - replace ip with ipa for mass sums
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
< c> Jul  2015 - added lnan_anyfailed
< c> Sep  2015 - i8 replaced with i9 for time step count
end
diff -ibw hycom/mod_stokes.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_stokes.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
27d2
<       use mod_cb_arrays  ! HYCOM saved arrays
36,39d10
< c     The modification of the turbulent viscosity near the surface 
< c     has been implemented  following:
< c          - Craig & Banner + Ardhuin-Filipot-Perenne
< c          - Uchiyama-McWilliams-Shchepetkin
43,45c14,16
<      & stdsur,   ! Stokes Drift Surface Stresses:     TRUE/FALSE (dissipation due to breaking and rolling)
<      & stdbot,   ! Stokes Drift Bottom Stress:        TRUE/FALSE (dissipation due to bottom friction)
<      & stdarc    ! Stokes Drift Velocities in Archive TRUE/FALSE
---
>      & stdsur,   ! Stokes Drift Surface Stresses:   TRUE/FALSE
>      & stdbot,   ! Stokes Drift Bottom Stress:      TRUE/FALSE
>      & langmr    ! Langmuir turb enhancement (KPP): TRUE/FALSE
47d17
< c    Constant values
51,52c21
<      &  nsdzi,   ! Number of fixed interface depths for Stokes input 
<      & langmr    ! Langmuir turb enhancement (KPP) 0: None 1:McWilliams-Sulliva 2:Smyth 3:McWilliams-Harcourt 4:Takaya
---
>      &  nsdzi        ! Number of fixed interface depths for Stokes input
78c47
<      &         save, public  ::
---
>      &         save, private  ::
94,138d62
< c     Array holding the wave-induced mean pressure
< 
<       real,    allocatable, dimension(:,:,:),
<      &         save, public  ::
<      & sj     ! wave-induced mean pressure on pressure grid
< c     Arrays holding the horizontal derivatives of the vertical position of the middle of the layer
< c
< c      real,    allocatable, dimension(:,:,:),
< c     &         save, public  ::
< c     & dzdx,    ! derivative of z with respect to x
< c     & dzdy     ! derivative of z with respect to y
< 
< c     Arrays used to calculate the dissipations
< 
<       real,    allocatable, dimension(:,:,:),
<      &         save, public  ::
<      & sdka,        ! frequency as a function ot time and space (=sdk)
<      & wave_dir,    ! main wave propagation direction
<      & h_sig,       ! significant wave height
<      & eps_brk      ! wave breaking dissipation rate
< 
< c     Dissipations (bottom and breakin)
< 
<       real,    allocatable, dimension(:,:,:),
<      &         save, public  ::
<      & wave_bdx(:,:,:),     ! Bottom dissipation  
<      & wave_bdy(:,:,:),     ! Bottom dissipation  
<      & wave_brkx(:,:,:),     ! Dissipation  by breaking
<      & wave_brky(:,:,:)      ! Dissipation  by breaking
< 
< c     Arrays used for the parameterization of the vertical mixing
< 
<       real,    allocatable, dimension(:,:,:),
<      &         save, public  ::
<      & phi_ocw,  ! Turbulent kinetic energy flux (notation from WW3)
<      & z0topw,   ! wind sea significant height(if stz0tp=1) or surface roughness
<      & ustarw3w, ! Velocity scale from WW3
<      & difx_wave ! Vertical diffusion enhancement due to wave breaking (Uchiyama et al.)
<       real,    allocatable, dimension(:,:),
<      &         save, public  ::
<      & phi_oc,   ! Turbulent kinetic energy flux (notation from WW3)
<      & alpha,    ! Wave energy factor from WW3
<      & z0top,    ! Surface roughness from WW3
<      & ustarw3   ! Velocity scale from WW3
< c
142c66
<       real,    save, public ::
---
>       real,    save, private ::
147,151d70
< c    Stokes indexes
<       integer,    save, public ::
<      &  ls0,
<      &  ls1
< 
157a77
>       include 'common_blocks.h'
163d82
<       if     (mnproc.eq.1) then
168d86
<       endif !1st tile
170,172c88,90
< c
< c --- Allocate Stokes Drift Velocity arrays used in rest of HYCOM
< c
---
> *
> *      Allocate Stokes Drift Velocity arrays used in rest of HYCOM
> *
175d92
<       call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy)*kdm )
181d97
<       call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy)*kdm )
187d102
<       call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy) )
193d107
<       call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy) )
197,203d110
< c      allocate( dzdx(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,kdm),
< c     &          dzdy(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,kdm))
< c      call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy)*kdm )
< c      dzdx(:,:,:) = 0.0
< c      dzdy(:,:,:) = 0.0
< 
< c
208,212c115,117
<         ls0 = 1
<         ls1 = 2
< c
< c ---   Read in Stokes Drift profile arrays for current model start time
< c
---
> *
> *        Read in Stokes Drift profile arrays for current model start time
> *
217c122
<         call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy)*2*nsdzi )
---
> 
224,225c129,130
<           write (lp,*) '...finished initializing Stokes Drift ',
<      &                 'velocity Fields'
---
>        write (lp,*) '...finished initializing Stokes Drift velocity ',
>      +              'Fields'
231,232c136,137
<           write (lp,*)'Stokes drift version of HYCOM called with ',
<      &                'stdflg == 0'
---
>        write (lp,*)'Stokes drift version of HYCOM called with stkflg ',
>      +             '== 0'
234,235c139
<           write (lp,*)'No attempt is made to read WW3 Stokes Drift ',
<      &                'Data'
---
>        write (lp,*)'No attempt is made to read WW3 Stokes Drift Data'
238c142,143
<       endif     !stdflg:else
---
>         endif     !stdflg 
> 
245a151
>       include 'common_blocks.h'
267c173
<       integer   i,ios,iunit,j,lgth,nrec,k,f,fmax
---
>       integer   i,ios,iunit,j,lgth,nrec,k,l,f,fmax
269c175
<       real      dpthin,sum_u,sum_v,pzb,pzt
---
>       real      dpthin,sum_u,sum_v
499,502c405,408
< cdiag           if     (mnproc.eq.1) then
< cdiag           write(lp,*) 'enter rdpall - ',time,dtime0,dtime1
< cdiag           endif !1st tile
< cdiag           call xcsync(flush_lp)
---
> *           if     (mnproc.eq.1) then
> *           write(lp,*) 'enter rdpall - ',time,dtime0,dtime1
> *           endif !1st tile
> *           call xcsync(flush_lp)
517,520c423,426
< cdiag           if     (mnproc.eq.1) then
< cdiag           write(lp,*) ' exit rdpall1 - ',time,dtime0,dtime1
< cdiag           endif !1st tile
< cdiag           call xcsync(flush_lp)
---
> *           if     (mnproc.eq.1) then
> *           write(lp,*) ' exit rdpall1 - ',time,dtime0,dtime1
> *           endif !1st tile
> *           call xcsync(flush_lp)
526,533c432,436
<       if     (debug_stokes) then
<         if     (mnproc.eq.1) then
<         write(lp,'(a,i2,f20.10,2f10.7)')
<      &            'stokes_forfun - n,dtime,ws0,ws1 = ',
<      &            n,dtime,ws0,ws1
<         endif !1st tile
<         call xcsync(flush_lp)
<       endif !debug
---
> *           if     (mnproc.eq.1) then
> *           write(lp,*) 'stokes_forfun - dtime,ws0,ws1 = ',
> *    &                  dtime,ws0,ws1
> *           endif !1st tile
> *           call xcsync(flush_lp)
569c472
< !$OMP PARALLEL DO PRIVATE(j,i,k,sum_u,sum_v)
---
> !$OMP PARALLEL DO PRIVATE(j,l,i,k,sum_u,sum_v)
572,573c475,476
<         do i= 1,ii
<           if (SEA_U) then
---
>         do l=1,isu(j)
>           do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
580d482
<           endif !iu
582,583c484,486
<         do i= 1,ii
<           if (SEA_V) then
---
>         enddo !l
>         do l=1,isv(j)
>           do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
590d492
<           endif !iv
591a494
>         enddo !l
594,650c497,506
< c
<       if     (debug_stokes) then
<  103    format (i9,2i5,a)
<  104    format (30x,i3,2f8.4,f9.3,f9.2)
<         if (itest.gt.0 .and. jtest.gt.0) then
<           write (lp,103) nstep,itest+i0,jtest+j0,
<      .    '  stokes_forfun:  usdz    vsdz    thkns     dpth'
<           pzb = 0.0
<           do k= 1,nsdzi
<             pzt = pzb
<             pzb = min(sdzi(k),p(itest,jtest,kk+1))*qonem
<             write (lp,104)
<      .      k,
<      .      ws0*usdz(itest,jtest,1,k)+ws1*usdz(itest,jtest,2,k),
<      .      ws0*vsdz(itest,jtest,1,k)+ws1*vsdz(itest,jtest,2,k),
<      .      pzb-pzt,pzb
<             if     (pzt.eq.p(itest,jtest,kk+1)*qonem) then
<               exit
<             endif
<           enddo !k
< c
<           write (lp,103) nstep,itest+i0,jtest+j0,
<      .    '  stokes_forfun:  usdp    vsdp     thkns     dpth'
<           pzb = 0.0
<           do k= 1,kk
<             pzt = pzb
<             pzb = min(pzt+dp(itest,jtest,k,n)*qonem,
<      &                    p(itest,jtest,kk+1)*qonem)
<             write (lp,104)
<      .      k,
<      .      usdp(itest,jtest,k),vsdp(itest,jtest,k),
<      .      pzb-pzt,pzb
<             if     (pzt.eq.p(itest,jtest,kk+1)*qonem) then
<               exit
<             endif
<           enddo !k
< c
<           write (lp,103) nstep,itest+i0,jtest+j0,
<      .    '  stokes_forfun:   usd     vsd     thkns     dpth'
<           write (lp,104)
<      .    0,usdbavg(itest,jtest),vsdbavg(itest,jtest),
<      .    0.0,p(itest,jtest,kk+1)*qonem 
<           pzb = 0.0
<           do k= 1,kk
<             pzt = pzb
<             pzb = min(pzt+dp(itest,jtest,k,n)*qonem,
<      &                    p(itest,jtest,kk+1)*qonem)
<             write (lp,104)
<      .      k,
<      .      usd(itest,jtest,k),vsd(itest,jtest,k),
<      .      pzb-pzt,pzb
<             if     (pzt.eq.p(itest,jtest,kk+1)*qonem) then
<               exit
<             endif
<           enddo !k
<         endif !test
<       endif !debug
---
> 
> *      if((i.eq.1).and.(j.eq.1))then
> *         write(6,*)'U and V grid Stokes Drift velocities at point (1,1)'
> *         write(6,*)'u/v sdbavg = ',usdbavg(1,1),vsdbavg(1,1)
> *         write(6,*)'        k     usd(1,1,k)       vsd(1,1,k)'
> *         do k=1,kk
> *            write(6,*)k,usd(1,1,k),vsd(1,1,k)
> *         enddo
> *      endif
> 
653a510
> 
657a515
> 
664a523
>       include 'common_blocks.h'
672c531
<       integer i,k
---
>       integer i,k,l
677c536
<      &        c1d(nsdzi,2),   !interpolation coefficients
---
>      &        c1d(nsdzi,2,3), !interpolation coefficients
686,687c545,546
<       do i= 1,ii
<         if (SEA_P) then
---
>       do l=1,isp(j)
>         do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
701c560
<             prsf(k+1) = min(prsf(k)+dp(i,j,k,n),p(i,j,kk+1))
---
>             prsf(k+1) = p(i,j,k+1)
704c563
<           call hybgen_plm_coefs(s1d,     dpi, lcm,c1d,
---
>           call hybgen_weno_coefs(s1d,     dpi, lcm,c1d,
706c565
<           call hybgen_plm_remap(s1d,pres,dprs,    c1d,
---
>           call hybgen_weno_remap(s1d,pres,dprs,    c1d,
713d571
<         endif !ip
714a573,574
>       enddo !l
> c
719,720d578
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
< c> Aug  2015 - added stdarc
end
diff -ibw hycom/mod_tides.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_tides.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
85d60
<       use mod_cb_arrays  ! HYCOM saved arrays
86a62
>       include 'common_blocks.h'
181d156
<              call mem_stat_add( 3*(idm+2*nbdy)*(jdm+2*nbdy) )
191,192d165
<              call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy)*ncon )
<              call mem_stat_add(   (idm+2*nbdy)*(jdm+2*nbdy) )
264d236
<            call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy)*50 )
282d253
<       use mod_cb_arrays  ! HYCOM saved arrays
283a255
>       include 'common_blocks.h'
290c262
<       integer i,ihr,j,k
---
>       integer i,ihr,j,k,l
321c293
< !$OMP     PARALLEL DO PRIVATE(j,i,k,
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i,k,
329,330c301,302
<             do i=1,ii
<             if (SEA_U) then
---
>             do l=1,isu(j)
>             do i=max(1,ifu(j,l)),min(ii,ilu(j,l))
342d313
<             endif !ip
344,345c315,317
<             do i=1,ii
<             if (SEA_V) then
---
>             enddo !l
>             do l=1,isv(j)
>             do i=max(1,ifv(j,l)),min(ii,ilv(j,l))
357d328
<             endif !ip
358a330
>             enddo !l
364c336
< !$OMP     PARALLEL DO PRIVATE(j,i)
---
> !$OMP     PARALLEL DO PRIVATE(j,l,i)
371,372c343,344
<             do i=1,ii
<             if (SEA_P) then
---
>             do l=1,isp(j)
>             do i=max(1,ifp(j,l)),min(ii,ilp(j,l))
375d346
<             endif !ip
376a348
>             enddo !l
482d453
<       use mod_cb_arrays  ! HYCOM saved arrays
483a455
>       include 'common_blocks.h'
617d588
<       use mod_cb_arrays  ! HYCOM saved arrays
619a591
>       include 'common_blocks.h'
749d720
<       use mod_cb_arrays  ! HYCOM saved arrays
751a723
>       include 'common_blocks.h'
761c733
<       integer   i,j,k,lgth
---
>       integer   i,j,k,l,lgth
875d846
<       use mod_cb_arrays  ! HYCOM saved arrays
876a848
>       include 'common_blocks.h'
878,879c850
<       integer start,ijtdm,ndat
<       logical astroflag
---
>       integer ijtdm
880a852,854
>       real  zpred(ndat),z1r(ndat,ncon),z1i(ndat,ncon)
>       real Ai(ncon), Ar(ncon)
>       integer ind(ncon),start
885,889c859,860
<       logical interp_micon
<       integer n,m,i,j,k,ic
<       integer ind(ncon)
<       real    zpred(ndat),z1r(ndat,ncon),z1i(ndat,ncon)
<       real    Ai(ncon), Ar(ncon)
---
>       logical interp_micon, astroflag
>       integer n,m,ndat,i,j,k,ic
1344d1314
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
end
diff -ibw hycom/mod_tsadvc.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_tsadvc.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_tsadvc.F: No such file or directory
end
diff -ibw hycom/mod_xc.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_xc.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
87c76
<       integer,     private, dimension(97), save :: nc,nca,nci
---
>       integer,     private, dimension(97), save :: nc
93,98d81
< #if defined(RELO)
<       integer, private, save, allocatable, dimension(:,:) :: mpe_i
<       integer, private, save, allocatable, dimension(:)   :: npe_j
< #else
<       integer, private, save :: mpe_i(0:itdm+1,0:jqr),npe_j(0:jtdm+1)
< #endif
104c87,88
<      &                          mpe_e(jqr)
---
>      &                          mpe_e(jqr),
>      &                          mpe_i(0:itdm+1,0:jqr),npe_j(0:jtdm+1)
114,156d97
< #endif
< #if defined(MPI) || defined(SHMEM)
< c
< c --- private message passing buffers, used by more than one routine
< #if defined(RELO)
<       real,   save, private, allocatable, dimension(:,:) ::
<      &   al    ! xcaget and xcaput
<       real,   save, private, allocatable, dimension(:) ::
<      &   at    ! xcaget and xcaput
<       real*4, save, private, allocatable, dimension(:,:) ::
<      &   al4,  ! xcaget4 and xcaput4
<      &   alt4  ! xcaget4 and xcaput4
<       real*4, save, private, allocatable, dimension(:) ::
<      &   at4   ! xcaget4 and xcaput4
<       integer, save, private ::
<      &   mxsum
<       real*8, save, private, allocatable, dimension(:) ::
<      &  sum8t, ! xcsum and xcsumj
<      &  sum8j  ! xcsum and xcsumj
<       real*8, save, private ::
<      &  sum8s
< #else
<       real,   save, private, dimension(itdm,jdm) ::
<      &   al    ! xcaget and xcaput
<       real,   save, private, dimension(idm*jdm) ::
<      &   at    ! xcaget and xcaput
<       real*4, save, private, dimension(itdm,jdm) ::
<      &   al4   ! xcaget4 and xcaput4
<       real*4, save, private, dimension(idm*jdm,jpr) ::
<      &   alt4  ! xcaget4 and xcaput4
<       real*4, save, private, dimension(idm*jdm) ::
<      &   at4   ! xcaget4 and xcaput4
<       integer, private, parameter :: mxsum=(idm+4*nbdy)/(2*nbdy+1)
<       real*8, save, private, dimension(mxsum*jdm) ::
<      &  sum8t  ! xcsum and xcsumj
<       real*8, save, private, dimension(jdm) ::
<      &  sum8j  ! xcsum and xcsumj
<       real*8, save, private ::
<      &  sum8s  ! xcsum and xcsumj
< #endif
<       integer, private, parameter :: nmax=1024
<       real,   save, private, dimension(nmax) ::
<      &  b,c    ! xcastr, xcmaxr, xcminr
end
diff -ibw hycom/mod_xc_mp.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_xc_mp.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
130,131c119,127
<       integer mpierr
< #endif
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
> #endif
>       real            al,at
>       common/xcagetr/ al(itdm,jdm),at(idm*jdm)
>       save  /xcagetr/
> c
140,148d135
< #if defined(RELO)
< c
<       if     (.not.allocated(al)) then
<         allocate(       al(itdm,jdm) )
<         call mem_stat_add( itdm*jdm )
<         allocate(       at(idm*jdm) )
<         call mem_stat_add( idm*jdm )
<       endif
< #endif
168c155
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
235c222
<      &                    mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                    mpi_comm_hycom, mpistat, mpierr)
290c277
<       real*4,  intent(out)   :: aa(itdm,*)
---
>       real*4,  intent(out)   :: aa(itdm,jtdm)
302a290
> c        = 0; all nodes
305,309c293
< c  4) The size of aa depends on mnflg
< c      =-1; aa needed on 1st node in each row, dimension (itdm,jdm)
< c      = n; aa needed on nth node,             dimension (itdm,jtdm)
< c
< c  5) parameters:
---
> c  4) parameters:
320,321c304,314
<       integer mpierr
< #endif
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
> #endif
>       real            al8,at8
>       common/xcagetr/ al8(itdm,jdm),at8(idm*jdm)
>       save  /xcagetr/
> c
>       real*4          al4(itdm,jdm),       at4(idm*jdm)
>       equivalence    (al4(1,1),al8(1,1)), (at4(1),at8(1))
331,343d323
< #if defined(RELO)
< c
<       if     (.not.allocated(at4)) then
<         if     (mproc.eq.mpe_1(nproc)) then
<           allocate(       al4(itdm,jdm) )
<           allocate(      alt4(idm*jdm,ipr) )
<           call mem_stat_add( (itdm*jdm)/2     ) !real*4, so /2
<           call mem_stat_add( (idm *jdm*jpr)/2 ) !real*4, so /2
<         endif !first tile in the row
<         allocate(       at4(idm*jdm) )
<         call mem_stat_add( (idm*jdm) /2 ) !real*4, so /2
<       endif
< #endif
363c343
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
413c393
<               aa(i,j) = al4(i,j)
---
>               aa(i,j+j0) = al4(i,j)
437c417
<      &                    mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                    mpi_comm_hycom, mpistat, mpierr)
449a430,434
> c
>       if     (mnflg.eq.0) then
>         call mpi_bcast(aa,itdm*jtdm,MTYPE4,
>      &                 idproc1(1),mpi_comm_hycom,mpierr)
>       endif
451c436
<       if     (mnproc.eq.mnflg) then
---
>       if     (mnflg.eq.0 .or. mnproc.eq.mnflg) then
513c498,501
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
516a505,507
>       real            al,at
>       common/xcagetr/ al(itdm,jdm),at(idm*jdm)
>       save  /xcagetr/
527,535d517
< #if defined(RELO)
< c
<       if     (.not.allocated(al)) then
<         allocate(       al(itdm,jdm) )
<         call mem_stat_add( itdm*jdm )
<         allocate(       at(idm*jdm) )
<         call mem_stat_add( idm*jdm )
<       endif
< #endif
564c546
<           call mpi_waitall( j, mpireqa, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( j, mpireqa, mpistat, mpierr)
568c550
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
579c561
<           call mpi_waitall( i, mpireqb, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( i, mpireqb, mpistat, mpierr)
583c565
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
615c597
<       real*4,  intent(in)    :: aa(itdm,*)
---
>       real*4,  intent(inout) :: aa(itdm,jtdm)
627a610
> c        = 0; all nodes
629,630c612,613
< c     the array aa is unchanged on exit, and need not exist
< c      on the nodes that do not reference it.
---
> c     if mnflg.ne.0 the array aa may be broadcast to all nodes,
> c      so aa must exist and be overwritable on all nodes.
643c626,629
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
646a633,638
>       real            al8,at8
>       common/xcagetr/ al8(itdm,jdm),at8(idm*jdm)
>       save  /xcagetr/                           
> c                                               
>       real*4          al4(itdm,jdm),       at4(idm*jdm)
>       equivalence    (al4(1,1),al8(1,1)), (at4(1),at8(1))
648c640
<       integer i,msg,j,mp,np,mnp
---
>       integer i,j,mp,np,mnp
657,669d648
< #if defined(RELO)
< c
<       if     (.not.allocated(at4)) then
<         if     (mproc.eq.mpe_1(nproc)) then
<           allocate(       al4(itdm,jdm) )
<           allocate(      alt4(idm *jdm,ipr) )
<           call mem_stat_add( (itdm*jdm)/2     ) !real*4, so /2
<           call mem_stat_add( (idm *jdm*jpr)/2 ) !real*4, so /2
<         endif !first tile in the row
<         allocate(       at4(idm*jdm) )
<         call mem_stat_add( (idm*jdm) /2 ) !real*4, so /2
<       endif
< #endif
674a654,656
> c     use xclput for now,
> c     this is slow for mnflg.ne.0, but easy to implement.
> c
675a658,661
> c       "broadcast" row sections of aa to all processors in the row.
>         if     (mnproc.ne.mnflg) then
>           aa(:,:) = vland4
>         endif
677d662
< c       "broadcast" row sections of aa to first processor in each row.
692c677
<           call mpi_waitall( j, mpireqa, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( j, mpireqa, mpistat, mpierr)
696c681
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
699d683
< c       "broadcast" partial row sections to the rest of the row's processors
701c685
<           msg = 0
---
>           i = 0
703,710c687,688
<             do j= 1,jj
<               do i= 1,ii_pe(mp,nproc)
<                 alt4(i+(j-1)*ii_pe(mp,nproc),mp) = 
<      &            al4(i0_pe(mp,nproc)+i,j)
<               enddo
<             enddo
<             msg = msg + 1
<             call MPI_ISEND(alt4(1,mp),ii_pe(mp,nproc)*jj,MTYPE4,
---
>             i = i + 1
>             call MPI_ISEND(al4,itdm*jj,MTYPE4,
712,718c690
<      &                    mpi_comm_hycom, mpireqb(msg), mpierr)
<           enddo !mp
< c
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = al4(i0+i,j)
<             enddo
---
>      &                    mpi_comm_hycom, mpireqb(i), mpierr)
720,721c692
< c
<           call mpi_waitall( msg, mpireqb, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( i, mpireqb, mpistat, mpierr)
723c694
<           call MPI_RECV(at4,ii*jj,MTYPE4,
---
>           call MPI_RECV(al4,itdm*jj,MTYPE4,
725,730c696
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
731a698,699
> c
>         aa(:,j0+1:j0+jj) = al4(:,1:jj)
735,737c703,704
< c       "broadcast" row sections of aa to first processor in each row.
<         if     (mproc.eq.mpe_1(nproc)) then
<           call SHMEM_GET4(al4(1,   1),
---
>         if     (mnproc.ne.mnflg) then
>           call SHMEM_GET4(aa(1,j0+1),
739,762d705
<           do mp= mpe_1(nproc)+1,mpe_e(nproc)
<             do j= 1,jj
<               do i= 1,ii
<                 alt4(i+(j-1)*ii,mp) = al4(i0+i,j)
<               enddo
<             enddo
<           enddo !mp
<         endif
<         BARRIER
< c       "broadcast" partial row sections to the rest of the row's processors
<         if     (mproc.eq.mpe_1(nproc)) then
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = al4(i0+i,j)
<             enddo
<           enddo
<         else
<           call SHMEM_GET4( at4(1,    1),
<      &                    alt4(1,mproc),ii*jj,idproc1(mpe_1(nproc)))
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
766a710
> c       "broadcast" row sections of aa to all processors in the row.
768d711
< c       "broadcast" partial row sections of aa to all processors in the row.
770c713
<           msg = 0
---
>           i = 0
772,787c715,718
<             do j= 1,jj
<               do i= 1,ii_pe(mp,nproc)
<                 alt4(i+(j-1)*ii_pe(mp,nproc),mp) = 
<      &            aa(i0_pe(mp,nproc)+i,j)
<               enddo
<             enddo
<             msg = msg + 1
<             call MPI_ISEND(alt4(1,mp),ii_pe(mp,nproc)*jj,MTYPE4,
<      &                    idproc(mp,nproc), 9953,
<      &                    mpi_comm_hycom, mpireqb(msg), mpierr)
<           enddo !mp
< c
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = aa(i0+i,j)
<             enddo
---
>             i = i + 1
>             call MPI_ISEND(aa(1,j0+1),itdm*jj,MTYPE4,
>      &                    idproc(mp,nproc), 9952,
>      &                    mpi_comm_hycom, mpireqb(i), mpierr)
789,790c720
< c
<           call mpi_waitall( msg, mpireqb, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( i, mpireqb, mpistat, mpierr)
792,799c722,724
<           call MPI_RECV(at4,ii*jj,MTYPE4,
<      &                  idproc(mpe_1(nproc),nproc), 9953,
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
---
>           call MPI_RECV(aa(1,j0+1),itdm*jj,MTYPE4,
>      &                  idproc(mpe_1(nproc),nproc), 9952,
>      &                  mpi_comm_hycom, mpistat, mpierr)
802,812c727
< c       "broadcast" partial row sections to the rest of the row's processors
<         if     (mproc.eq.mpe_1(nproc)) then
<           do mp= mpe_1(nproc)+1,mpe_e(nproc)
<             do j= 1,jj
<               do i= 1,ii_pe(mp,nproc)
<                 alt4(i+(j-1)*ii_pe(mp,nproc),mp) = 
<      &            aa(i0_pe(mp,nproc)+i,j)
<               enddo
<             enddo
<           enddo !mp
<         endif
---
> c       assume aa is in common.
814,827c729,732
<         if     (mproc.eq.mpe_1(nproc)) then
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = aa(i0+i,j)
<             enddo
<           enddo
<         else
<           call SHMEM_GET4( at4(1,    1),
<      &                    alt4(1,mproc),ii*jj,idproc1(mpe_1(nproc)))
<           do j= 1,jj
<             do i= 1,ii
<               a(i,j) = at4(i+(j-1)*ii)
<             enddo
<           enddo
---
>         if     (mproc.ne.mpe_1(nproc)) then
>           call SHMEM_GET4(aa(1,j0+1),
>      &                    aa(1,j0+1),itdm*jj,
>      &                    idproc(mpe_1(nproc),nproc))
831a737,740
> c     
>       do j= 1,jtdm
>         call xclput4(aa(1,j),itdm, a, 1,j,1,0)
>       enddo
862c771,774
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
864a777,783
>       integer    nmax
>       parameter (nmax=1024)
> c
>       real            b,c
>       common/xcmaxr4/ b(nmax),c(nmax)
>       save  /xcmaxr4/
> c
946c865,868
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
951c873,876
<       real,    save, dimension(0:1) :: elem
---
>       real            elem(0:1)
>       common/xcegetr/ elem
>       save  /xcegetr/
> c
1012c937
<      &                   mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                   mpi_comm_hycom, mpistat, mpierr)
1062c987,990
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
1118c1046,1049
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
1159c1090,1093
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
1265c1199,1202
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
1271,1278c1208,1214
< #if defined(RELO)
<       real,    save, allocatable, dimension(:,:) ::
<      &  als,alr
< #else
<       real,    save, dimension(-47:itdm+jtdm+48,0:1) ::
<      &  als,alr
< #endif
<       integer, save, dimension(0:ijqr-1,0:1) :: nlp,nxp
---
>       real            als,alr
>       common/xcigetr/ als(-47:itdm+jtdm+48,0:1),
>      &                alr(-47:itdm+jtdm+48,0:1)
>       save  /xcigetr/
>       integer         nlp,nxp
>       common/xcigeti/ nlp(0:ijqr-1,0:1),nxp(0:ijqr-1,0:1)
>       save  /xcigeti/
1282,1289d1217
< #if defined(RELO)
< c
<       if     (.not.allocated(als)) then
<         allocate(     als(-47:itdm+jtdm+48,0:1),
<      &                alr(-47:itdm+jtdm+48,0:1) )
<         call mem_stat_add( 2*(itdm+jtdm+96)*2 )
<       endif
< #endif
1475c1403,1406
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
1481,1485c1412,1414
< #if defined(RELO)
<       real, save, allocatable, dimension (:,:) :: al
< #else
<       real, save, dimension(-47:itdm+jtdm+48,0:1) :: al
< #endif
---
>       real            al
>       common/xclgetr/ al(-47:itdm+jtdm+48,0:1)
>       save  /xclgetr/
1498,1504d1426
< #if defined(RELO)
< c
<       if     (.not.allocated(al)) then
<         allocate(    al(-47:itdm+jtdm+48,0:1) )
<         call mem_stat_add( (itdm+jtdm+96)*2 )
<       endif
< #endif
1550c1472
<      &                      mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                      mpi_comm_hycom, mpistat, mpierr)
1642c1564
<      &                      mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                      mpi_comm_hycom, mpistat, mpierr)
1821a1744,1817
>       subroutine xclput4(aline,nl, a, i1,j1,iinc,jinc)
>       implicit none
> c
>       integer, intent(in)    ::  nl,i1,j1,iinc,jinc
>       real*4,  intent(in)    ::  aline(nl)
>       real*4,  intent(inout) ::  a(ii,jj)
> c
> c**********
> c*
> c  1) fill a line of elements in the non-tiled 2-D grid.
> c     Special version for xcaput4 only.
> c
> c  2) aline(i) == aa(i1+i1*(i-1),j1+j1*(i-1)), for i=1...nl.
> c     where aa is the non-tiled representation of a, and
> c     one of iinc and jinc must be 0, and the other must be 1.
> c     also updates the halo.
> c
> c  3) parameters:
> c       name            type         usage            description
> c    ----------      ----------     -------  ----------------------------
> c    aline           real           input     line of element values
> c    nl              integer        input     dimension of aline
> c    a               real           in/out    tiled target array
> c    i1              integer        input     1st non-tiled index into a
> c    j1              integer        input     2nd non-tiled index into a
> c    iinc            integer        input     1st index increment
> c    jinc            integer        input     2nd index increment
> c*
> c**********
> c
>       integer i,j
> #if defined(TIMER)
> c
>       if     (nxc.eq.0) then
>         call xctmr0( 5)
>         nxc = 5
>       endif
> #endif
> c
>       if     (jinc.eq.0) then
>         if     (j1-j0.ge.1 .and. j1-j0.le.jj) then
>           do i= max(1,i1-i0),min(i1-i0+nl-1,ii)
>             a(i,j1-j0) = aline(i+i0-i1+1)
>           enddo
>           if     (nreg.ne.0 .and.
>      &            i0.eq.0 .and. i1+nl-1.ge.itdm+1) then  ! periodic
>             do i= max(itdm+1,i1),i1+nl-1
>               a(i-itdm,j1-j0) = aline(i)
>             enddo
>           endif
>         endif
>       elseif (iinc.eq.0) then
>         if     (i1-i0.ge.1 .and. i1-i0.le.ii) then
>           do j= max(1,j1-j0),min(j1-j0+nl-1,jj)
>             a(i1-i0,j) = aline(j+j0-j1+1)
>           enddo
>         endif
>         if     (nreg.ne.0 .and.
>      &          i0.eq.0 .and. i1.ge.itdm+1) then       ! periodic
>           do j= max(1,j1-j0),min(j1-j0+nl-1,jj)
>             a(i1-itdm,j) = aline(j+j0-j1+1)
>           enddo
>         endif
>       endif
> #if defined(TIMER)
> c
>       if     (nxc.eq. 5) then
>         call xctmr1( 5)
>         nxc = 0
>       endif
> #endif
>       return
>       end subroutine xclput4
> 
1876c1872,1875
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
1878a1878,1884
>       integer    nmax
>       parameter (nmax=1024)
> c
>       real            b,c
>       common/xcmaxr4/ b(nmax),c(nmax)
>       save  /xcmaxr4/
> c
2051c2057,2060
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
2053a2063,2069
>       integer    nmax
>       parameter (nmax=1024)
> c
>       real            b,c
>       common/xcmaxr4/ b(nmax),c(nmax)
>       save  /xcmaxr4/
> c
2197c2213,2216
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
2212c2231
<      &                  mpi_comm_world, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_world, mpistat, mpierr)
2218c2237
<      &                  mpi_comm_world, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_world, mpistat, mpierr)
2266a2286
> c      margin  -     how much of the halo is currently valid
2301a2322,2324
>       integer    mxsum
>       parameter (mxsum=(idm+4*nbdy)/(2*nbdy+1))
> c
2309c2332,2335
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
2473a2500,2515
>       elseif (itdm_in.ne.itdm .or. jtdm_in.ne.jtdm) then
>         if     (mnproc.eq.1) then
>           write(lp,'(a,2i5)') 'input: itdm,jtdm =',itdm_in,jtdm_in
>           write(lp,'(a,2i5)') 'param: itdm,jtdm =',itdm,   jtdm
>           call flush(lp)
>         endif
>         call xcstop('xcspmd: patch.input for wrong itdm,jtdm')
>         stop '(xcspmd)'
>       elseif (idm_in.gt.idm .or. jdm_in.gt.jdm) then
>         if     (mnproc.eq.1) then
>           write(lp,'(a,2i5)') 'input: idm,jdm =',idm_in,jdm_in
>           write(lp,'(a,2i5)') 'param: idm,jdm =',idm,   jdm
>           call flush(lp)
>         endif
>         call xcstop('xcspmd: patch.input for wrong idm,jdm')
>         stop '(xcspmd)'
2494,2520d2535
< #if defined(RELO)
< c --- region's horizontal dimensions are from patch.input:
< c
<       itdm = itdm_in
<       jtdm = jtdm_in
<       idm  = idm_in
<       jdm  = jdm_in
< #else
<       if     (itdm_in.ne.itdm .or. jtdm_in.ne.jtdm) then
<         if     (mnproc.eq.1) then
<           write(lp,'(a,2i5)') 'input: itdm,jtdm =',itdm_in,jtdm_in
<           write(lp,'(a,2i5)') 'param: itdm,jtdm =',itdm,   jtdm
<           call flush(lp)
<         endif
<         call xcstop('xcspmd: patch.input for wrong itdm,jtdm')
<         stop '(xcspmd)'
<       elseif (idm_in.gt.idm .or. jdm_in.gt.jdm) then
<         if     (mnproc.eq.1) then
<           write(lp,'(a,2i5)') 'input: idm,jdm =',idm_in,jdm_in
<           write(lp,'(a,2i5)') 'param: idm,jdm =',idm,   jdm
<           call flush(lp)
<         endif
<         call xcstop('xcspmd: patch.input for wrong idm,jdm')
<         stop '(xcspmd)'
<       endif
< #endif
< c
2592,2596d2606
< #if defined(RELO)
<       allocate( mpe_i(0:itdm+1,0:jqr), npe_j(0:jtdm+1) )
<       call mem_stat_add( (itdm+2)*(jqr+1)+jtdm+2 )
< #endif
< c
2865a2876,2877
>       margin = 0
> c
3174,3177d3185
< #if defined(RELO)
<       mxsum = ((idm+4*nbdy)/(2*nbdy+1))*jdm
< c
< #endif
3227c3235,3238
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
3293c3304,3307
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
3295a3310,3316
>       integer    mxsum
>       parameter (mxsum=(idm+4*nbdy)/(2*nbdy+1))
> c
>       real*8         sum8t,sum8j,sum8s
>       common/xcsum8/ sum8t(mxsum*jdm),sum8j(jdm),sum8s
>       save  /xcsum8/
> c
3309,3315d3329
< #if defined(RELO)
< c
<       if     (.not.allocated(sum8t)) then
<         allocate(    sum8t(mxsum), sum8j(jdm) )
<         call mem_stat_add( mxsum +       jdm )
<       endif
< #endif
3365c3379
<      &                    mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                    mpi_comm_hycom, mpistat, mpierr)
3407c3421
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
3475c3489,3492
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
3477a3495,3501
>       integer    mxsum
>       parameter (mxsum=(idm+4*nbdy)/(2*nbdy+1))
> c
>       real*8         sum8t,sum8j,sum8s
>       common/xcsum8/ sum8t(mxsum*jdm),sum8j(jdm),sum8s
>       save  /xcsum8/
> c
3491,3497d3514
< #if defined(RELO)
< c
<       if     (.not.allocated(sum8t)) then
<         allocate(    sum8t(mxsum), sum8j(jdm) )
<         call mem_stat_add( mxsum +       jdm )
<       endif
< #endif
3547c3564
<      &                    mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                    mpi_comm_hycom, mpistat, mpierr)
3587c3604
<      &                  mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                  mpi_comm_hycom, mpistat, mpierr)
3631c3648,3651
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
3671c3691,3693
<       integer, save, dimension(cache_line,-1:ijqr-1) :: ibp
---
>       integer        ibp
>       common/halobp/ ibp(cache_line,-1:ijpr-1)
>       save  /halobp/
3736a3759,3761
>       integer    ilen
>       parameter (ilen=idm*kdm)
> c
3739,3744c3764,3767
< #if defined(RELO)
<       real,    save, allocatable, dimension(:,:) :: ai
< #else
<       integer, parameter :: ilen=idm*kdm
<       real,    save, dimension(ilen,2) :: ai
< #endif
---
>       real            ai
>       common/xctila4/ ai(ilen,2)
>       save  /xctila4/
> c
3750c3773,3776
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
3762,3768d3787
< #if defined(RELO)
<       if     (.not.allocated(ai)) then
<         allocate(       ai(idm*kdm,2) )
<         call mem_stat_add( idm*kdm*2 )
<       endif
< #endif
< c
3864,3865c3883
<             call mpi_waitall( nreqa, mpireqa, MPI_STATUSES_IGNORE,
<      &                                        mpierr)
---
>             call mpi_waitall( nreqa, mpireqa, mpistat, mpierr)
3939c3957,3959
< c     halo buffer
---
>       integer    ilen,jlen
>       parameter (ilen= idm        *kdm*nbdy+64,
>      &           jlen=(jdm+2*nbdy)*kdm*nbdy+64)
3941,3949c3961,3969
< #if defined(RELO)
<       real, save, allocatable, dimension(:,:) :: ai,aj,aia
< #else
<       integer, parameter :: ilen= idm        *kdm*nbdy+64,
<      &                      jlen=(jdm+2*nbdy)*kdm*nbdy+64
<       real, save, dimension (ilen,4) :: ai
<       real, save, dimension (jlen,4) :: aj
<       real, save, dimension (kdm*nbdy+64,2) :: aia
< #endif
---
> c     halo buffer (in common for enhanced MPI safety).
> c
>       real            ai,aj
>       common/xctilr4/ ai(ilen,4),aj(jlen,4)
>       save  /xctilr4/
> c
>       real            aia
>       common/xctilra/ aia(kdm*nbdy+64,2)
>       save  /xctilra/
3956c3976,3979
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
3967,3977d3989
< #if defined(RELO)
< c
<       if     (.not.allocated(ai)) then
<         allocate(        ai( idm        *kdm*nbdy+64 ,4) )
<         call mem_stat_add( ( idm        *kdm*nbdy+64)*4 )
<         allocate(        aj((jdm+2*nbdy)*kdm*nbdy+64 ,4) )
<         call mem_stat_add( ((jdm+2*nbdy)*kdm*nbdy+64)*4 )
<         allocate(      aia( kdm*nbdy+64, 2) )
<         call mem_stat_add( (kdm*nbdy+64)*2 )
<       endif
< #endif
4186a4199,4201
>             klnold = ld-l1+1
>             nhlold = nhl
>             ityold = itynew
4265,4266c4280
<             call mpi_waitall( nreqa, mpireqa, MPI_STATUSES_IGNORE,
<      &                                        mpierr)
---
>             call mpi_waitall( nreqa, mpireqa, mpistat, mpierr)
4376c4390
<      &          mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &          mpi_comm_hycom, mpistat, mpierr)
4380c4394
<      &          mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &          mpi_comm_hycom, mpistat, mpierr)
4382,4384c4396
<           if     (klmold.ne.(ld-l1+1) .or.
<      &            mhlold.ne.mhl       .or.
<      &            nhlold.ne.nhl           ) then  !new mpi init
---
>           if     (klmold.ne.(ld-l1+1) .or. mhlold.ne.mhl) then  !new mpi init
4397a4410,4411
>             klmold = ld-l1+1
>             mhlold = mhl
4412c4426
<           call mpi_waitall( 4, mpireqb, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( 4, mpireqb, mpistat, mpierr)
4437,4442d4450
< c
<       klnold = ld-l1+1
<       klmold = ld-l1+1
<       nhlold = nhl
<       mhlold = mhl
<       ityold = itynew
4489c4497,4499
< c     halo buffer.
---
>       integer    ilen,jlen
>       parameter (ilen= idm        *kdm*nbdy+64,
>      &           jlen=(jdm+2*nbdy)*kdm*nbdy+64)
4491,4498c4501,4505
< #if defined(RELO)
<       real, save, allocatable, dimension (:,:) :: ai,aj
< #else
<       integer, parameter :: ilen= idm        *kdm*nbdy+64,
<      &                      jlen=(jdm+2*nbdy)*kdm*nbdy+64
<       real, save, dimension(ilen,4) :: ai
<       real, save, dimension(jlen,4) :: aj
< #endif
---
> c     halo buffer (in common for enhanced MPI safety).
> c
>       real            ai,aj
>       common/xctilr4/ ai(ilen,4),aj(jlen,4)
>       save  /xctilr4/
4504c4511,4514
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
4508,4511c4518,4519
<       integer mpireqa(4*iqr),mpireqb(4),
<      &        ilold,jlold,nreqa
<       save    mpireqa,mpireqb,
<      &        ilold,jlold,nreqa
---
>       integer mpireqa(4*iqr),mpireqb(4),ilold,jlold,nreqa
>       save    mpireqa,mpireqb,ilold,jlold,nreqa
4515,4523d4522
< #if defined(RELO)
< c
<       if     (.not.allocated(ai)) then
<         allocate(        ai( idm        *kdm*nbdy+64 ,4) )
<         call mem_stat_add( ( idm        *kdm*nbdy+64)*4 )
<         allocate(        aj((jdm+2*nbdy)*kdm*nbdy+64 ,4) )
<         call mem_stat_add( ((jdm+2*nbdy)*kdm*nbdy+64)*4 )
<       endif
< #endif
4621,4622c4620
<             call mpi_waitall( nreqa, mpireqa, MPI_STATUSES_IGNORE,
<      &                                        mpierr)
---
>             call mpi_waitall( nreqa, mpireqa, mpistat, mpierr)
4704c4702
<      &          mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &          mpi_comm_hycom, mpistat, mpierr)
4708c4706
<      &          mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &          mpi_comm_hycom, mpistat, mpierr)
4732c4730
<           call mpi_waitall( 4, mpireqb, MPI_STATUSES_IGNORE, mpierr)
---
>           call mpi_waitall( 4, mpireqb, mpistat, mpierr)
4784d4781
< c     call xctnrs(n,ncan,ncin) to set nca(n) and nci(n),
4787c4784
< c  4) time every nci(n)-th event above nca(n), default 50 and 5,000.
---
> c  4) time every 50-th event above 5,000.
4800,4801d4796
<         nca(i) = 5000  !default
<         nci(i) = 50    !default
4824c4819
< c  3) time every nci(n)-th event above nca(n), default 50 and 5,000.
---
> c  3) time every 50-th event above 5,000.
4845c4840
<         if     (mod(nc(n),nci(n)).eq.0 .or. nc(n).le.nca(n)) then
---
>         if     (mod(nc(n),50).eq.0 .or. nc(n).le.5000) then
4866c4861
< c  3) time every nci(n)-th event above nca(n), default 50 and 5,000.
---
> c  3) time every 50-th event above 5,000.
4873,4875c4868,4870
<         if     (nc(n).gt.nca(n)) then
<           if     (mod(nc(n),nci(n)).eq.0) then
<             tc(n) = tc(n) + nci(n)*(wtime() - t0(n))
---
>         if     (nc(n).gt.5000) then
>           if     (mod(nc(n),50).eq.0) then
>             tc(n) = tc(n) + 50.0*(wtime() - t0(n))
4921,4954d4915
<       subroutine xctmrs(n,ncan,ncin)
<       implicit none
< c
<       integer,     intent(in) :: n,ncan,ncin
< c
< c**********
< c*
< c  1) set nca(n) and nci(n)
< c
< c  2) parameters:
< c       name            type         usage            description
< c    ----------      ----------     -------  ----------------------------
< c    n               integer        input     timer number
< c    ncan            integer        input     value for nca(n)
< c    ncin            integer        input     value for nci(n)
< c
< c  3) ncan must be a multiple of ncin
< c*
< c**********
< c
<       if     (mod(ncan,ncin).ne.0) then
<         if     (mnproc.eq.1) then
<         write(lp,'(a,i3,2i8)') 'n,ncan,ncin =',n,ncan,ncin
<         call flush(lp)
<         endif
<         call xcstop('Error in xctmrs - ncan not a multiple of ncin')
<         stop '(xcspmd)'
<       endif
< c
<       nca(n) = ncan
<       nci(n) = ncin
<       return
<       end subroutine xctmrs
< 
4969c4930,4933
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
4974d4937
<       character*16 cmnproc
4996c4959
<      &                    mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                    mpi_comm_hycom, mpistat, mpierr)
5005c4968
<               if     (nc(i).le.nca(i)) then
---
>               if     (nc(i).le.5000) then
5007,5008c4970,4971
<               else !correct for timing every nci(i)-th event
<                 tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),nci(i)))
---
>               else !correct for timing every 50th event
>                 tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),50))
5023c4986
<               if     (nc(i).le.nca(i)) then
---
>               if     (nc(i).le.5000) then
5025,5026c4988,4989
<               else !correct for timing every nci(i)-th event
<                 tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),nci(i)))
---
>               else !correct for timing every 50th event
>                 tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),50))
5036c4999
<         call mem_stat_print('processor     1:')
---
>         write(lp,6200)
5039,5049d5001
<       if     (nproc.eq.2 .and. mproc.eq.mpe_1(nproc)) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
<       endif
<       call xcsync(flush_lp)
<       if     (mnproc.eq.ijpr) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
<         write(lp,*)
<       endif
<       call xcsync(flush_lp)
5074a5027
>  6200 format(/ /)
5090c5043,5046
<       integer mpierr
---
>       integer        mpierr,mpireq,mpistat
>       common/xcmpii/ mpierr,mpireq(4),
>      &               mpistat(mpi_status_size,4*iqr)
>       save  /xcmpii/
5095d5050
<       character*16 cmnproc
5126c5081
<      &                    mpi_comm_hycom, MPI_STATUS_IGNORE, mpierr)
---
>      &                    mpi_comm_hycom, mpistat, mpierr)
5158c5113
<             if     (nc(i).le.nca(i)) then
---
>             if     (nc(i).le.5000) then
5160,5161c5115,5116
<             else !correct for timing every nci(i)-th event
<               tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),nci(i)))
---
>             else !correct for timing every 50th event
>               tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),50))
5176c5131
<             if     (nc(i).le.nca(i)) then
---
>             if     (nc(i).le.5000) then
5178,5179c5133,5134
<             else !correct for timing every nci(i)-th event
<               tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),nci(i)))
---
>             else !correct for timing every 50th event
>               tci = (tc(i)*nc(i))/(nc(i)-mod(nc(i),50))
5188c5143
<         call mem_stat_print('processor     1:')
---
>         write(lp,6200)
5191,5201d5145
<       if     (nproc.eq.2 .and. mproc.eq.mpe_1(nproc)) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
<       endif
<       call xcsync(flush_lp)
<       if     (mnproc.eq.ijpr) then
<         write(cmnproc,'(a,i6,a)') 'processor',mnproc,':'
<         call mem_stat_print(cmnproc)
<         write(lp,*)
<       endif
<       call xcsync(flush_lp)
5226a5171
>  6200 format(/ /)
5240,5243d5184
< c> Jan. 2014 - replaced mpistat with MPI_STATUS[ES]_IGNORE
< c> Jan. 2014 - ARCTIC xctilr bugfix for when called after xcsum
< c> Feb. 2015 - reduced buffering memory requirements
< c> Dec. 2016 - added nca and nci
end
diff -ibw hycom/mod_xc_sm.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_xc_sm.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
803a793
> c      margin  -     how much of the halo is currently valid
829,835d818
< #if defined(RELO)
< c --- region's horizontal dimensions are from blkdat.input.
< c
<       itdm = -1
<       jtdm = -1
< #endif
< c
839a823,824
> c
>       margin = 0
end
diff -ibw hycom/mod_za.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_za.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
31,44d19
< #if defined(RELO)
< c
< c --- initialized in zaiost.
<       integer, private, save :: n2drec
<       real*4,  private, save, allocatable, dimension(:) ::
<      &           wminy,wmaxy,htmp
< #else
< c
<       integer, parameter :: n2drec=((itdm*jtdm+4095)/4096)*4096
<       real*4,  private, save, dimension(jtdm)    :: wminy,wmaxy
<       real*4,  private, save, dimension(idm*jdm) :: htmp
< #endif
< c
<       real*4,  private, save, allocatable, dimension(:) :: w
end
diff -ibw hycom/mod_za_mp1.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_za_mp1.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
101a91,96
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
264a260,265
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
424a426,431
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
578,599d584
< c
< c --- w on 1st tile only
< c
< #if defined(RELO)
< c
< c --- n2drec = size of output 2-d array, multiple of 4096
<       n2drec = ((itdm*jtdm+4095)/4096)*4096
< c
<       if     (mnproc.eq.1) then
<         allocate( w(n2drec),wminy(jtdm),wmaxy(jtdm),htmp(idm*jdm) )
<         call mem_stat_add( (n2drec+2*jtdm+idm*jdm)/2) !real*4, so /2
<       else
<         allocate( w(1),     wminy(jtdm),wmaxy(jtdm),htmp(idm*jdm) )
<         call mem_stat_add( (     1+2*jtdm+idm*jdm)/2) !real*4, so /2
<       endif !1st tile:else
< #else
<       if     (mnproc.eq.1) then
<         allocate( w(n2drec) )
<       else
<         allocate( w(1) )
<       endif !1st tile:else
< #endif
899a885,897
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
> c
>       real*4         awtmp(itdm,jtdm)
>       equivalence   (w(1),awtmp(1,1))  !saves a data copy
> c
>       real*4         htmp
>       common/czioxr/ htmp(idm*jdm)
>       save  /czioxr/
978c976
<       call xcaput4(w,htmp, 1)  !w cast to a 2-d array
---
>       call xcaput4(awtmp,htmp, 1)
1239a1238,1250
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
> c
>       real*4         awtmp(itdm,jtdm)
>       equivalence   (w(1),awtmp(1,1))  !saves a data copy
> c
>       real*4         htmp
>       common/czioxr/ htmp(idm*jdm)
>       save  /czioxr/
1369c1380
<       call xcaget4(w,htmp, 1)  !htmp to w (as a 2-d array) on 1st processor
---
>       call xcaget4(awtmp,htmp, 1)  !htmp to w (awtmp) on 1st processor
1433,1437d1443
< c
< c
< c> Revision history:
< c>
< c> Feb  2015 - w on 1st tile only
end
diff -ibw hycom/mod_za_mp.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_za_mp.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
108a98
> c --- n2drec = size of output 2-d array, multiple of 4096
110a101,102
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
117a110,113
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
> c
255a252
> c --- n2drec = size of output 2-d array, multiple of 4096
257a255,256
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
264a264,267
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
> c
411a415
> c --- n2drec = size of output 2-d array, multiple of 4096
413a418,419
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
420a427,430
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
> c
642,671d651
< #if defined(RELO)
< c
< c --- n2drec = size of output 2-d array, multiple of 4096
<       n2drec = ((itdm*jtdm+4095)/4096)*4096
< c
<       allocate( wminy(jdm),wmaxy(jdm),htmp(idm*jdm) )
<       call mem_stat_add( (2*jdm+idm*jdm)/2 ) !real*4, so /2
< c
<       if     (mproc.eq.mp_1st) then
<         if     (nproc.ne.jpr) then
<           allocate( w(itdm*jj) )
<           call mem_stat_add( (itdm*jj)/2 ) !real*4, so /2
<         else
<           allocate( w(itdm*jj+n2drec-itdm*jtdm) )
<           call mem_stat_add( (itdm*jj+n2drec-itdm*jtdm)/2 ) !real*4, so /2
<         endif
<       else
<         allocate( w(1) )
<       endif
< #else
<       if     (mproc.eq.mp_1st) then
<         if     (nproc.ne.jpr) then
<           allocate( w(itdm*jj) )
<         else
<           allocate( w(itdm*jj+n2drec-itdm*jtdm) )
<         endif
<       else
<         allocate( w(1) )
<       endif
< #endif
974a955,956
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
981a964,974
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
> c
>       real*4         awtmp(itdm,jtdm)
>       equivalence   (w(1),awtmp(1,1))  !saves a data copy
> c
>       real*4         htmp
>       common/czioxr/ htmp(idm*jdm)
>       save  /czioxr/
> c
1017c1010
<      &                      w(1),
---
>      &                      w(1+j0*itdm),
1034c1027
<         do j= 1,jj
---
>         do j= j0+1,j0+jj
1047,1048c1040,1041
<         wmin = minval(wminy(1:jj))
<         wmax = maxval(wmaxy(1:jj))
---
>         wmin = minval(wminy(j0+1:j0+jj))
>         wmax = maxval(wmaxy(j0+1:j0+jj))
1054c1047
<       call xcaput4(w,htmp, -1)  !w cast to a 2-d array
---
>       call xcaput4(awtmp,htmp, -1)
1282a1276,1277
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
1289a1285,1295
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
> c
>       real*4         awtmp(itdm,jtdm)
>       equivalence   (w(1),awtmp(1,1))  !saves a data copy
> c
>       real*4         htmp
>       common/czioxr/ htmp(idm*jdm)
>       save  /czioxr/
> c
1416c1422
<       call xcaget4(w,htmp, -1)  !htmp to w (as a 2-d array) for each row.
---
>       call xcaget4(awtmp,htmp, -1)  !htmp to w (awtmp) for each row.
1422c1428
<             w(itdm*jj+i-itdm*jtdm) = data_void(1)
---
>             w(i) = data_void(1)
1434c1440
<      &                         w(1),
---
>      &                         w(1+itdm*j0),
1464d1469
< c> Feb  2015 - reduced size of w, allocated on 1st tile in each row only
end
diff -ibw hycom/mod_za_sm.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_za_sm.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
71a61
> c --- n2drec = size of output 2-d array, multiple of 4096
73a64,69
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
220a217
> c --- n2drec = size of output 2-d array, multiple of 4096
222a220,225
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
365a369
> c --- n2drec = size of output 2-d array, multiple of 4096
367a372,377
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
506,513d515
< #if defined(RELO)
< c
< c --- n2drec = size of output 2-d array, multiple of 4096
<       n2drec = ((itdm*jtdm+4095)/4096)*4096
< c
<       allocate( w(n2drec),wminy(jtdm),wmaxy(jtdm) )
<       call mem_stat_add( (n2drec+2*jtdm)/2) !real*4, so /2
< #endif
783a786
> c --- n2drec = size of output 2-d array, multiple of 4096
785a789,794
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
1045a1055
> c --- n2drec = size of output 2-d array, multiple of 4096
1047a1058,1063
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
end
diff -ibw hycom/mod_za_zt.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mod_za_zt.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
57a47,52
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
295a291,296
>       integer    n2drec
>       parameter (n2drec=((itdm*jtdm+4095)/4096)*4096)
> c
>       real*4         w,wminy,wmaxy
>       common/czioxw/ w(n2drec),wminy(jtdm),wmaxy(jtdm)
>       save  /czioxw/
end
diff -ibw hycom/mxkprf.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxkprf.F
1,24d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
< #if defined(ROW_LAND)
< #define SEA_P .true.
< #define SEA_U .true.
< #define SEA_V .true.
< #elif defined(ROW_ALLSEA)
< #define SEA_P allip(j).or.ip(i,j).ne.0
< #define SEA_U alliu(j).or.iu(i,j).ne.0
< #define SEA_V alliv(j).or.iv(i,j).ne.0
< #else
< #define SEA_P ip(i,j).ne.0
< #define SEA_U iu(i,j).ne.0
< #define SEA_V iv(i,j).ne.0
< #endif
27d2
<       use mod_cb_arrays  ! HYCOM saved arrays
32a8,9
>       include 'common_blocks.h'
> c
47c24
<       integer   i,j,k
---
>       integer   i,j,k,l
65a43,44
>       margin = 0  ! no horizontal derivatives
> c
69c48
< !$OMP   PARALLEL DO PRIVATE(j,i)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i)
71,73c50,52
<         do j=1,jj
<           do i=1,ii
<             if (SEA_P) then
---
>         do j=1-margin,jj+margin
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
77d55
<             endif !ip
78a57
>           enddo !l
87c66
<       do j=1,jj
---
>       do j=1-margin,jj+margin
101a81
>         margin = 2
103,105c83,85
<           call psmooth_dif(dift(1-nbdy,1-nbdy,k),util6,k,2,0,ip, util1)
<           call psmooth_dif(difs(1-nbdy,1-nbdy,k),util6,k,2,0,ip, util1)
<           call psmooth_dif(vcty(1-nbdy,1-nbdy,k),util6,k,2,1,ip, util1)
---
>           call psmooth_dif(dift(1-nbdy,1-nbdy,k),util6,k, 0)
>           call psmooth_dif(difs(1-nbdy,1-nbdy,k),util6,k, 0)
>           call psmooth_dif(vcty(1-nbdy,1-nbdy,k),util6,k, 1)
106a87
>         margin = 0
131a113,114
>           write (text,'(a9,i3)') 'vcty   k=',k
>           call pipe_compare_sym1(vcty(1-nbdy,1-nbdy,k),ip,text)
136,137d118
<           write (text,'(a9,i3)') 'vcty   k=',k
<           call pipe_compare_sym1(vcty(1-nbdy,1-nbdy,k),ip,text)
146c127
<       do j=1,jj
---
>       do j=1-margin,jj+margin
156c137
<       do j=1,jj
---
>       do j=1-margin,jj+margin
166c147
< !$OMP   PARALLEL DO PRIVATE(j,i,k,
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,k,
170,172c151,152
<         do j=1,jj
<           do i=1,ii
<             if (SEA_P) then
---
>         do j=1-margin,jj+margin
>           do l=1,isp(j)
176a157
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
322d302
<             endif !ip
323a304
>           enddo !l
329c310
<         call psmooth(dpmixl(1-nbdy,1-nbdy,n),0,0,ip, util1)
---
>         call psmooth(dpmixl(1-nbdy,1-nbdy,n), 0)
341c322
< !$OMP   PARALLEL DO PRIVATE(j,i,k,delp)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,k,delp)
343,345c324,326
<         do j=1,jj
<           do i=1,ii
<             if (SEA_P) then
---
>         do j=1-margin,jj+margin
>           do l=1,isp(j)
>             do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
369d349
<            endif !ip
370a351
>           enddo !l
377c358
< !$OMP   PARALLEL DO PRIVATE(j,i,k,delp,dpmx)
---
> !$OMP   PARALLEL DO PRIVATE(j,l,i,k,delp,dpmx)
379,380c360
<         do j=1,jj
<           do i=1,ii
---
>         do j=1-margin,jj+margin
384c364,365
<             if (SEA_U) then
---
>           do l=1,isu(j)
>             do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
394c375,376
<             endif !iu
---
>             enddo !i
>           enddo !l
398c380,381
<             if (SEA_V) then
---
>           do l=1,isv(j)
>             do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
408d390
<             endif !iv
409a392
>           enddo !l
418d400
<       use mod_cb_arrays  ! HYCOM saved arrays
420a403,404
>       include 'common_blocks.h'
> c
425c409
<       integer i
---
>       integer i,l
428,429c412,413
<         do i=1,ii
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
431,432c415,416
<           endif !ip
<         enddo !i
---
>           enddo
>         enddo
434,435c418,419
<         do i=1,ii
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
437,438c421,422
<           endif !ip
<         enddo !i
---
>           enddo
>         enddo
440,441c424,425
<         do i=1,ii
<           if (SEA_P) then
---
>         do l=1,isp(j)
>           do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
443,444c427,428
<           endif !ip
<         enddo !i
---
>           enddo
>         enddo
451d434
<       use mod_cb_arrays  ! HYCOM saved arrays
453a437,438
>       include 'common_blocks.h'
> c
458c443
<       integer i
---
>       integer i,l
460,461c445,446
<       do i=1,ii
<         if (SEA_P) then
---
>       do l=1,isp(j)
>         do i=max(1-margin,ifp(j,l)),min(ii+margin,ilp(j,l))
463c448
<         endif
---
>         enddo
470d454
<       use mod_cb_arrays  ! HYCOM saved arrays
472a457,458
>       include 'common_blocks.h'
> c
477c463
<       integer i
---
>       integer i,l
479,480c465,466
<       do i=1,ii
<         if (SEA_U) then
---
>       do l=1,isu(j)
>         do i=max(1-margin,ifu(j,l)),min(ii+margin,ilu(j,l))
482,483c468,472
<         endif !iu
<         if (SEA_V) then
---
>         enddo
>       enddo
> c
>       do l=1,isv(j)
>         do i=max(1-margin,ifv(j,l)),min(ii+margin,ilv(j,l))
485,486c474,475
<         endif !iv
<       enddo !i
---
>         enddo
>       enddo
490d478
< c
493d480
<       use mod_cb_arrays  ! HYCOM saved arrays
497a485,486
>       include 'common_blocks.h'
> c
681c670
<         call swfrac_ij(chl,pij,klist(i,j)+1,qonem,jerlov(i,j),swfrac)
---
>         call swfrac_ij(chl,pij,kdm+1,qonem,jerlov(i,j),swfrac)
1760d1748
< c
1763d1750
<       use mod_cb_arrays  ! HYCOM saved arrays
1767a1755,1756
>       include 'common_blocks.h'
> c
2155c2144
<         call swfrac_ij(chl,pij,klist(i,j)+1,qonem,jerlov(i,j),swfrac)
---
>         call swfrac_ij(chl,pij,kdm+1,qonem,jerlov(i,j),swfrac)
2216d2204
<       use mod_cb_arrays  ! HYCOM saved arrays
2220a2209,2210
>       include 'common_blocks.h'
> c
2374c2364
<         call swfrac_ij(chl,pij,klist(i,j)+1,qonem,jerlov(i,j),swfrac)
---
>         call swfrac_ij(chl,pij,kdm+1,qonem,jerlov(i,j),swfrac)
3147d3136
<       use mod_cb_arrays  ! HYCOM saved arrays
3151a3141,3142
>       include 'common_blocks.h'
> c
3329d3319
<       use mod_cb_arrays  ! HYCOM saved arrays
3333a3324,3325
>       include 'common_blocks.h'
> c
3354c3346
<       real    presu,dpbot,ubot
---
>       real presu
3402,3422c3394,3396
< c --- homogenize the bottom 10 cm
<       if     (nlayer.ne.kk) then
<         k = nlayer
<           dpbot   =         dpu(i,j,k,n)
<            ubot   =         dpu(i,j,k,n)*u(i,j,k,n)
<         do k= nlayer+1,kk
<           dpbot   = dpbot + dpu(i,j,k,n)
<            ubot   =  ubot + dpu(i,j,k,n)*u(i,j,k,n)
<           u1do(k) =                      u(i,j,k,n)
<         enddo !k
<         if     (dpbot.gt.onemm) then  !always true?
<           ubot = ubot / dpbot
<           do k= nlayer,kk
<             u(i,j,k,n) = ubot
<           enddo !k
<         endif !dpbot
<       endif !nlayer
< c
< cdiag if ((i.eq.itest.or.i.eq.itest+1).and.j.eq.jtest) then
< cdiag   write (lp,106) nlayer,(nstep,i+i0,j+j0,k,
< cdiag&    dpu(i,j,k,n)*qonem,u1do(k),u(i,j,k,n),k=1,kk)
---
> cdiag if (i.eq.itest.and.j.eq.jtest) then
> cdiag   write (lp,106) (nstep,i+i0,j+j0,k,
> cdiag&    hm(k),u1do(k),u1dn(k),k=1,nlayer)
3426,3427c3400
<  106  format( 'ciju ',23x,'   thick   u old   u new (nlayer =',i3,')' /
<      &       ('ciju ',i9,2i5,i3,1x,f10.3,2f8.3))
---
>  106  format(23x,'   thick   u old   u new'/(i9,2i5,i3,1x,f10.3,2f8.3))
3429d3401
< c
3432d3403
<       use mod_cb_arrays  ! HYCOM saved arrays
3436a3408,3409
>       include 'common_blocks.h'
> c
3457c3430
<       real    presv,dpbot,vbot
---
>       real presv
3506,3526c3479,3481
< c --- homogenize the bottom 10 cm
<       if     (nlayer.ne.kk) then
<         k = nlayer
<           dpbot   =         dpv(i,j,k,n)
<            vbot   =         dpv(i,j,k,n)*v(i,j,k,n)
<         do k= nlayer+1,kk
<           dpbot   = dpbot + dpv(i,j,k,n)
<            vbot   =  vbot + dpv(i,j,k,n)*v(i,j,k,n)
<           v1do(k) =                      v(i,j,k,n)
<         enddo !k
<         if     (dpbot.gt.onemm) then  !always true?
<           vbot = vbot / dpbot
<           do k= nlayer,kk
<             v(i,j,k,n) = vbot
<           enddo !k
<         endif !dpbot
<       endif !nlayer
< c
< cdiag if (i.eq.itest.and.(j.eq.jtest.or.j.eq.jtest+1)) then
< cdiag   write (lp,107) nlayer,(nstep,i+i0,j+j0,k,
< cdiag&    dpv(i,j,k,n)*qonem,v1do(k),v(i,j,k,n),k=1,kk)
---
> cdiag if (i.eq.itest.and.j.eq.jtest) then
> cdiag   write (lp,107) (nstep,i+i0,j+j0,k,
> cdiag&    hm(k),v1do(k),v1dn(k),k=1,nlayer)
3530,3532c3485
<  107  format( 'cijv ',23x,'   thick   v old   v new (nlayer =',i3,')' /
<      &       ('cijv ',i9,2i5,i3,1x,f10.3,2f8.3))
<       return
---
>  107  format(23x,'   thick   v old   v new'/(i9,2i5,i3,1x,f10.3,2f8.3))
3534d3486
< c
3537d3488
<       use mod_cb_arrays  ! HYCOM saved arrays
3539c3490
<       use mod_stokes     ! HYCOM Stokes drift
---
>       use mod_stokes  ! Stokes Drift Velocity Module
3543a3495,3496
>       include 'common_blocks.h'
> c
3616c3569
<       if     (isb.eq.1 .and. langmr.gt.0) then
---
>       if     (isb.eq.1 .and. langmr) then
3617a3571,3572
> c ---   Smyth et al, 2002 Ocean Dynamics 52, pp 104-115
> c ---     Nonlocal fluxes and Stokes drift effects in the KPP
3619,3627d3573
<         select case (langmr)
<           case (1) ! McWilliams & Sullivan (2001)
<                    !   Spill Sci Technol Bull 6: 225-237
<                    !   Vertical mixing by Langmuir circulations.
<                    ! flang=sqrt( 1. + 0.080 / la_t**4 )
<             flang = sqrt( 1. + 0.080 * ustk2 /(ust*ust + epsil)) 
<           case (2) ! Smyth et al, 2002 Ocean Dynamics 52, pp 104-115
<                    !   Nonlocal fluxes and Stokes drift effects in the KPP
<                    ! flang=max(1,min(5,sqrt(1+cw/La**4)))
3632c3578
<             flang=sqrt(1+cw*ustk2/(ust*ust + epsil))
---
>         flang=sqrt(1+cw*ustk2/(ust*ust + epsil))  !sqrt(1+cw/La**4)
3635,3648d3580
<           case (3) ! McWilliams & Sullivan (2001) and
<                    ! Harcourt & D'Asaro (2008) J. Phys. Oceanogr., 38,
<                    !   Large-Eddy Simulation of Langmuir Turbulence
<                    !   in Pure Wind Seas
<                    ! flang=sqrt( 1. + 0.098 / la_t**2 )
<             flang = sqrt( 1. + 0.098*sqrt(ustk2)/(ust + epsil) ) 
<           case (4) ! Takaya et al (2010), J. Geophys. Res., 115, C06009,
<                    !   Refinements to a prognostic scheme of 
<                    !   skin sea surface temperature
<                    ! flang=max(1,la_t**(-0.667))
<             flang = max( sqrt(ust/(sqrt(ustk2) + epsil))**(-0.667), 1. )
<           case default
<             flang = 1.
<         end select
3699,3701c3631
< c> Jan. 2014 - homogenize the bottom 10 cm velocities
< c> May  2014 - use land/sea masks (e.g. ip) to skip land
< c> Sep  2014 - added 3 new options for langmr
---
> c> Feb. 2014 - fixed jerlov in place of jerlov(i,j) bug
end
diff -ibw hycom/mxkrt.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxkrt.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxkrt.F: No such file or directory
end
diff -ibw hycom/mxkrtm.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxkrtm.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxkrtm.F: No such file or directory
end
diff -ibw hycom/mxpwp.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxpwp.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxpwp.F: No such file or directory
end
diff -ibw hycom/overtn.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/overtn.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/overtn.F: No such file or directory
end
diff -ibw hycom/poflat.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/poflat.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
34c23
<       parameter (kdpth=14,klat=19)  ! kdpth>1, klat>3
---
>       parameter (kdpth=14,klat=21)  ! kdpth>1, klat>3
40,41c29,30
<       data thet1,thet2,dthet/30.0,37.8,0.6/
<       data xlat1,xlat2,dlat/-90.,90.,10./
---
>       data thet1,thet2,dthet/22.0,28.5,0.5/
>       data xlat1,xlat2,dlat/-30.,70.,5./
43,44c32,33
< c---  depth (m) of isopycnals of potential density 30.0, 30.6, ... , 37.8
< c---  at latitudes  90s ... 90n  for GLBa (source: levitus atlas)
---
> c---  depth (m) of isopycnals of potential density 22.0, 22.5, ... , 28.5
> c---  at latitudes  30s ... 70n  for ATLd (source: levitus atlas)
47,54c36,39
<      + 0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !90s
<      +,0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !80s
<      +,0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !70s
<      +,0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !60s
<      +,0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !50s
<      +,0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !40s
<      +,0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !30s
<      +,0.,0., 0., 0., 0., 0., 1., 40.,159.,233.,478., 913.,8100.,8100. !20s
---
>      + 0.,0., 0., 0., 0., 0., 1., 23.,158.,257.,575.,1009.,8100.,8100. !30s
>      +,0.,0., 0., 0., 0., 0., 1., 28.,160.,252.,560., 969.,8100.,8100. !25s
>      +,0.,0., 0., 0., 0., 0., 0., 40.,159.,233.,478., 913.,8100.,8100. !20s
>      +,0.,0., 0., 0., 0., 0.,22., 78.,147.,194.,388., 968.,8100.,8100. !15s
55a41
>      +,0.,0., 0., 0.,21.,39.,67., 73., 92.,134.,376., 946.,8100.,8100. ! 5s
56a43
>      +,2.,3., 9.,46.,56.,65.,76., 85., 99.,134.,318., 879.,8100.,8100. ! 5n
57a45
>      +,1.,3., 8.,17.,40.,60.,93.,112.,142.,187.,350., 868.,8100.,8100. !15n
59c47,49
<      +,0.,0., 1., 3., 6.,15.,24., 42., 77.,193.,557., 761.,8100.,8100. !30n
---
>      +,0.,0., 2., 6.,16.,27.,42., 68.,131.,217.,527., 772.,8100.,8100. !25n
>      +,0.,1., 1., 3., 6.,15.,24., 42., 77.,193.,557., 761.,8100.,8100. !30n
>      +,0.,0., 0., 0., 1., 7.,15., 26., 48.,105.,389., 622.,8100.,8100. !35n
61c51,53
<      +,0.,0., 0., 0., 1., 2., 3.,  5.,  8., 28., 78., 353.,8100.,8100. !50n
---
>      +,0.,0., 0., 0., 1., 3., 5.,  9., 21., 55., 87., 607.,8100.,8100. !45n
>      +,0.,0., 0., 1., 1., 2., 3.,  5.,  8., 28., 78., 353.,8100.,8100. !50n
>      +,0.,0., 0., 0., 0., 0., 0.,  1.,  3.,  8., 36., 165.,8100.,8100. !55n
62a55
>      +,0.,0., 0., 0., 0., 0., 0.,  1.,  3.,  9., 30.,  90., 422.,8100. !65n
64,65d56
<      +,0.,0., 0., 0., 0., 0., 0.,  0.,  1.,  2.,  9.,  32., 239.,8100. !80n
<      +,0.,0., 0., 0., 0., 0., 0.,  0.,  1.,  2.,  9.,  32., 239.,8100. !90n
end
diff -ibw hycom/prtmsk.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/prtmsk.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
diff -ibw hycom/psmoo.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/psmoo.f
1,12c1
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
<       subroutine psmooth(a,margin_a,margin_smooth, imask, w)
---
>       subroutine psmooth(a,margin_smooth)
14d2
<       use mod_cb_arrays  ! HYCOM saved arrays
15a4
>       include 'common_blocks.h'
17,20c6,7
<       integer margin_a,margin_smooth
<       integer imask(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
<       real        a(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &            w(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
---
>       integer margin_smooth
>       real    a(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
25,28d11
< c --- margin_a      is the margin on entry, and 
< c --- margin_smooth is the margin on exit.
< c --- imask         is ip or ishlf.
< c
31c14
< c --- w used as workspace, overwritten on exit
---
> c --- util1 used as workspace, so array a can't be util1
46c29
<       if     (margin_a.lt.msmth+1) then
---
>       if     (margin.lt.msmth+1) then
55c38
<           w(i,j) = a(i,j)
---
>           util1(i,j) = a(i,j)
64c47
<           if     (imask(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
68,69c51,52
<                 if     (imask(i+ismth,j+jsmth).eq.1) then
<                   sh = sh + c(ismth,jsmth)*w(i+ismth,j+jsmth)
---
>                 if     (ip(i+ismth,j+jsmth).eq.1) then
>                   sh = sh + c(ismth,jsmth)*util1(i+ismth,j+jsmth)
71c54
<                   sh = sh + c(ismth,jsmth)*w(i,      j)
---
>                   sh = sh + c(ismth,jsmth)*util1(i,      j)
76c59
<           endif  !imask.eq.1
---
>           endif  !ip.eq.1
83c66
<       subroutine psmooth_new(a,b,margin_a,margin_smooth, imask, w)
---
>       subroutine psmooth_new(a,b,margin_smooth)
85d67
<       use mod_cb_arrays  ! HYCOM saved arrays
86a69
>       include 'common_blocks.h'
88,89c71
<       integer margin_a,margin_smooth
<       integer imask(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
---
>       integer margin_smooth
91,92c73
<      &            b(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &            w(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
---
>      &        b(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
98,101d78
< c --- margin_a      is the margin on entry, and 
< c --- margin_smooth is the margin on exit.
< c --- imask         is ip or ishlf.
< c
119c96
<       if     (margin_a.lt.msmth+1) then
---
>       if     (margin.lt.msmth+1) then
128c105
<           if     (imask(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
132c109
<                 if     (imask(i+ismth,j+jsmth).eq.1) then
---
>                 if     (ip(i+ismth,j+jsmth).eq.1) then
140c117
<           endif  !imask.eq.1
---
>           endif  !ip.eq.1
147c124
<       subroutine psmooth_ice(a,margin_a,margin_smooth, imask, w)
---
>       subroutine psmooth_ice(a,margin_smooth)
149d125
<       use mod_cb_arrays  ! HYCOM saved arrays
150a127
>       include 'common_blocks.h'
152,155c129,130
<       integer margin_a,margin_smooth
<       integer imask(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
<       real        a(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &            w(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
---
>       integer margin_smooth
>       real    a(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
163,166d137
< c --- margin_a      is the margin on entry, and 
< c --- margin_smooth is the margin on exit.
< c --- imask         is ip or ishlf.
< c
169,170c140
< c --- array a can't be covice
< c --- w used as workspace, overwritten on exit
---
> c --- util1 used as workspace, so array a can't be util1 or covice
185c155
<       if     (margin_a.lt.msmth+1) then
---
>       if     (margin.lt.msmth+1) then
194c164
<           w(i,j) = a(i,j)
---
>           util1(i,j) = a(i,j)
203c173
<           if     (imask(i,j).eq.1) then
---
>           if     (ip(i,j).eq.1) then
210c180
<                   if     ( imask(i+ismth,j+jsmth).eq.1 .and.
---
>                   if     (    ip(i+ismth,j+jsmth).eq.1 .and.
212c182
<                     sh = sh + c(ismth,jsmth)*w(i+ismth,j+jsmth)
---
>                     sh = sh + c(ismth,jsmth)*util1(i+ismth,j+jsmth)
214c184
<                     sh = sh + c(ismth,jsmth)*w(i,      j)
---
>                     sh = sh + c(ismth,jsmth)*util1(i,      j)
220c190
<           endif  !imask.eq.1
---
>           endif  !ip.eq.1
227,228c197
<       subroutine psmooth_dif(a,aklist,k,margin_a,margin_smooth,
<      &                       imask, w)
---
>       subroutine psmooth_dif(a,aklist,k,margin_smooth)
230d198
<       use mod_cb_arrays  ! HYCOM saved arrays
231a200
>       include 'common_blocks.h'
233,234c202
<       integer k,margin_a,margin_smooth
<       integer imask( 1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
---
>       integer k,margin_smooth
236,237c204
<      &        aklist(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy),
<      &        w(     1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
---
>      &        aklist(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy)
244,247d210
< c --- margin_a      is the margin on entry, and 
< c --- margin_smooth is the margin on exit.
< c --- imask         is ip or ishlf.
< c
250c213
< c --- w used as workspace, overwritten on exit
---
> c --- util1 used as workspace, so array a can't be util1
266c229
<       if     (margin_a.lt.msmth+1) then
---
>       if     (margin.lt.msmth+1) then
275c238
<           w(i,j) = a(i,j)
---
>           util1(i,j) = a(i,j)
284c247
<           if     ( imask(i,j).eq.1 .and.
---
>           if     (    ip(i,j).eq.1 .and.
289c252
<                 if     ( imask(i+ismth,j+jsmth).eq.1 .and.
---
>                 if     (    ip(i+ismth,j+jsmth).eq.1 .and.
291c254
<                   sh = sh + c(ismth,jsmth)*w(i+ismth,j+jsmth)
---
>                   sh = sh + c(ismth,jsmth)*util1(i+ismth,j+jsmth)
293c256
<                   sh = sh + c(ismth,jsmth)*w(i,      j)
---
>                   sh = sh + c(ismth,jsmth)*util1(i,      j)
298c261
<           endif  !imask.eq.1
---
>           endif  !ip.eq.1
304,308d266
< c
< c
< c> Revision history:
< c>
< c> Apr. 2014 - added imask
end
diff -ibw hycom/restart.f /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/restart.f
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
14d2
<       use mod_cb_arrays  ! HYCOM saved arrays
18a7,8
>       include 'common_blocks.h'
> c
208d197
<             call mem_stat_add( 2*(idm+2*nbdy)*(jdm+2*nbdy)*50 )
316,324c305,306
<         endif  !new ice:read ice
<       else
< c ---   no sea ice, but still need covice
<         do j= 1,jj
<           do i= 1,ii
<             covice(i,j) = 0.0
<           enddo
<         enddo
<       endif  !icegln:else
---
>         endif
>       endif
338,340d319
<           srfhgt(i,j) = 0.0 !for pipe_compareall
<           montg1(i,j) = 0.0 !for pipe_compareall
<             dpbl(i,j) = 0.0 !for pipe_compareall
448d426
<       use mod_cb_arrays  ! HYCOM saved arrays
452a431,432
>       include 'common_blocks.h'
> c
912d891
<       use mod_cb_arrays  ! HYCOM saved arrays
916a896,897
>       include 'common_blocks.h'
> c
977d957
< c> Sep. 2015 - if no sea ice, still set covice to zero
end
diff -ibw hycom/stmt_fns.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/stmt_fns.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
diff -ibw hycom/thermf.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/thermf.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/thermf.F: No such file or directory
end
diff -ibw hycom/trcupd.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/trcupd.F
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/trcupd.F: No such file or directory
end
diff -ibw hycom/unit_offset.h /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/unit_offset.h
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
diff -ibw hycom/wtime.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/wtime.F
1,11d0
< c #
< c DISTRIBUTION STATEMENT B: Distribution authorized to U.S. Government
< c agencies based upon the reasons of possible Premature Distribution
< c and the possibility of containing Software Documentation as listed
< c on Table 1 of DoD Instruction 5230.24, Distribution Statements on
< c Technical Documents, of 23 August 2012. Other requests for this
< c document shall be made to Dr. Ruth H. Preller, Superintendent,
< c Oceanography Division, U.S. Naval Research Laboratory, DEPARTMENT
< c OF THE NAVY, John C. Stennis Space Center, MS 39529-5004; (228)
< c 688-4670 (voice); ruth.preller@nrlssc.navy.mil (e-mail).
< c #
end
foreach n ( barotp cnuity diapfl momtum mxkprf )
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hycom/barotp.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/barotp.f
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/barotp.f: No such file or directory
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hycom/cnuity.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/cnuity.f
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/cnuity.f: No such file or directory
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hycom/diapfl.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/diapfl.f
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/diapfl.f: No such file or directory
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hycom/momtum.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/momtum.f
diff: hycom/momtum.F: No such file or directory
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/momtum.f: No such file or directory
end
echo *****     *****     *****     *****     *****     *****     *****
*****     *****     *****     *****     *****     *****     *****
diff -ibw hycom/mxkprf.F /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxkprf.f
diff: /gpfs/dell1/nco/ops/nwprod/rtofs_code.v2.2.86F2p0i/sorc/hycom/mxkprf.f: No such file or directory
end
